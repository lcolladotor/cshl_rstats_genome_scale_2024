[["index.html", "Statistical Analysis of Genome Scale Data 2024 Overview Download course materials Code of Conduct Course Schedule External links Course Prerequisites R session information License", " Statistical Analysis of Genome Scale Data 2024 Leonardo Collado-Torres Overview Here you can find the files for the June 2024 Statistical Analysis of Genome Scale Data course at CSHL portion taught by Leo and his team (June 9-11). Instructor: Leonardo Collado-Torres, Twitter Teach assistants: Daianna González Padilla, Twitter Melissa Mayén Quiroz, Twitter Happy to welcome @lcolladotor, @SubmarineGene, and @daianna_glez to @cshlcourses on Statistical Analysis of Genome Scale Data. Materials here:https://t.co/0JGzEEf3Yx — Sean Davis (@seandavis12) July 3, 2023 Interested in learning R/@Bioconductor for #RNAseq data analysis?Check https://t.co/jcNWOq7VWD that @daianna_glez @SubmarineGene and I built for a CSHL course organized by @seandavis12 &amp; Vincent Carey#rstats @LieberInstitute @cshlcourses Source at https://t.co/aQ8kLMadSl ⭐️ — 🇲🇽 Leonardo Collado-Torres (@lcolladotor) July 10, 2023 Download course materials Download the materials for this course with usethis::use_course('lcolladotor/cshl_rstats_genome_scale_2024') or view online at lcolladotor.github.io/cshl_rstats_genome_scale_2024. This command downloads a static version of the course materials. If you want to be able to easily download updates, we recommend using Git. Happy Git and GitHub for the useR is great for getting your computer ready to use Git and GitHub. If you already have a GitHub account, you can instead use this command to download the course: ## Download it the first time git clone https://github.com/lcolladotor/cshl_rstats_genome_scale_2024.git ## To update the contents, use: cd cshl_rstats_genome_scale_2024 git pull Or you could use the GitHub Desktop application. Code of Conduct We’ll follow the CSHL code of conduct as well as version 1.2.0 of the Bioconductor code of conduct bioconductor.github.io/bioc_coc_multilingual/. For reporting any violations of the code of conduct, report them to the Instructor and/or Course Coordinators. Course Schedule Local times in US Eastern See CSHLData2023 for the detailed schedule. Below is a list of the key packages we will use each day: Monday July 3rd: SummarizedExperiment, iSEE, smokingMouse, biocthis Tuesday July 4th: recount3, ExploreModelMatrix, limma Wednesday July 5th: variancePartition, ComplexHeatmap Thursday July 6th: spatialLIBD External links CSHL course GitHub source code Slack Example real project (by Daianna): LieberInstitute/smokingMouse_Indirects SPEAQeasyWorkshop2023 for BioC2023 (by Daianna and Renee): LieberInstitute/SPEAQeasyWorkshop2023 LieberInstitute/template_project LIBD rstats club: check the public schedule Course Prerequisites Install R 4.3.x from CRAN then install the following R packages: ## For installing Bioconductor packages if (!requireNamespace(&quot;BiocManager&quot;, quietly = TRUE)) { install.packages(&quot;BiocManager&quot;) } ## Install required packages BiocManager::install( c( &quot;usethis&quot;, ## Utilities &quot;BiocFileCache&quot;, &quot;RefManageR&quot;, &quot;here&quot;, &quot;Hmisc&quot;, &quot;biocthis&quot;, &quot;lobstr&quot;, &quot;postcards&quot;, &quot;scater&quot;, &quot;sessioninfo&quot;, &quot;smokingMouse&quot;, &quot;stringr&quot;, &quot;SummarizedExperiment&quot;, ## Main containers / vis &quot;iSEE&quot;, &quot;edgeR&quot;, ## RNA-seq &quot;ExploreModelMatrix&quot;, &quot;limma&quot;, &quot;recount3&quot;, &quot;rlang&quot;, &quot;pheatmap&quot;, ## Visualization &quot;ggplot2&quot;, &quot;ggrepel&quot;, &quot;patchwork&quot;, &quot;RColorBrewer&quot;, &quot;ComplexHeatmap&quot;, &quot;cowplot&quot;, &quot;Polychrome&quot;, &quot;spatialLIBD&quot;, ## Advanced &quot;variancePartition&quot; ) ) ## Install smokingMouse, which is currently under review at Bioconductor ## at https://github.com/Bioconductor/Contributions/issues/3024. BiocManager::install(&quot;LieberInstitute/smokingMouse&quot;) ## Required to access some recent bug fixes on biocthis BiocManager::install(&quot;lcolladotor/biocthis&quot;) You will also need to install RStudio version 2023.06.0+421 or newer. R session information Details on the R version used for making this book. The source code is available at lcolladotor/cshl_rstats_genome_scale_2024. ## Load the package at the top of your script library(&quot;sessioninfo&quot;) ## Utilities library(&quot;BiocFileCache&quot;) library(&quot;BiocStyle&quot;) library(&quot;biocthis&quot;) library(&quot;here&quot;) library(&quot;lobstr&quot;) library(&quot;postcards&quot;) library(&quot;usethis&quot;) library(&quot;sessioninfo&quot;) ## Data library(&quot;smokingMouse&quot;) ## Main containers / vis library(&quot;SummarizedExperiment&quot;) library(&quot;iSEE&quot;) ## RNA-seq library(&quot;edgeR&quot;) library(&quot;ExploreModelMatrix&quot;) library(&quot;limma&quot;) library(&quot;recount3&quot;) ## QCA library(&quot;scater&quot;) ## Variance Partition library(&quot;variancePartition&quot;) ## Visualization: plots &amp; text library(&quot;ComplexHeatmap&quot;) library(&quot;ggplot2&quot;) library(&quot;patchwork&quot;) library(&quot;pheatmap&quot;) library(&quot;RColorBrewer&quot;) library(&quot;Hmisc&quot;) library(&quot;stringr&quot;) library(&quot;cowplot&quot;) library(&quot;rlang&quot;) library(&quot;ggrepel&quot;) library(&quot;Polychrome&quot;) ## Spatial transcriptomics library(&quot;spatialLIBD&quot;) ## Reproducibility information options(width = 120) session_info() ## ─ Session info ─────────────────────────────────────────────────────────────────────────────────────────────────────── ## setting value ## version R version 4.3.3 (2024-02-29) ## os Ubuntu 22.04.4 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2024-05-28 ## pandoc 3.1.1 @ /usr/local/bin/ (via rmarkdown) ## ## ─ Packages ─────────────────────────────────────────────────────────────────────────────────────────────────────────── ## package * version date (UTC) lib source ## abind 1.4-5 2016-07-21 [1] RSPM (R 4.3.0) ## AnnotationDbi 1.64.1 2023-11-03 [1] Bioconductor ## AnnotationHub 3.10.1 2024-04-05 [1] Bioconductor 3.18 (R 4.3.2) ## aod 1.3.3 2023-12-13 [1] RSPM (R 4.3.0) ## attempt 0.3.1 2020-05-03 [1] RSPM (R 4.3.0) ## backports 1.4.1 2021-12-13 [1] RSPM (R 4.3.0) ## base64enc 0.1-3 2015-07-28 [2] RSPM (R 4.3.0) ## beachmat 2.18.1 2024-02-14 [1] Bioconductor 3.18 (R 4.3.2) ## beeswarm 0.4.0 2021-06-01 [1] RSPM (R 4.3.0) ## benchmarkme 1.0.8 2022-06-12 [1] RSPM (R 4.3.0) ## benchmarkmeData 1.0.4 2020-04-23 [1] RSPM (R 4.3.0) ## Biobase * 2.62.0 2023-10-24 [1] Bioconductor ## BiocFileCache * 2.10.2 2024-03-27 [1] Bioconductor 3.18 (R 4.3.2) ## BiocGenerics * 0.48.1 2023-11-01 [1] Bioconductor ## BiocIO 1.12.0 2023-10-24 [1] Bioconductor ## BiocManager 1.30.22 2023-08-08 [1] RSPM (R 4.3.0) ## BiocNeighbors 1.20.2 2024-01-07 [1] Bioconductor 3.18 (R 4.3.2) ## BiocParallel * 1.36.0 2023-10-24 [1] Bioconductor ## BiocSingular 1.18.0 2023-10-24 [1] Bioconductor ## BiocStyle * 2.30.0 2023-10-24 [1] Bioconductor ## biocthis * 1.12.0 2023-10-24 [1] Bioconductor ## BiocVersion 3.18.1 2023-11-15 [2] Bioconductor ## Biostrings 2.70.3 2024-03-13 [1] Bioconductor 3.18 (R 4.3.2) ## bit 4.0.5 2022-11-15 [1] RSPM (R 4.3.0) ## bit64 4.0.5 2020-08-30 [1] RSPM (R 4.3.0) ## bitops 1.0-7 2021-04-24 [1] RSPM (R 4.3.0) ## blob 1.2.4 2023-03-17 [1] RSPM (R 4.3.0) ## bookdown 0.39 2024-04-15 [1] RSPM (R 4.3.0) ## boot 1.3-30 2024-02-26 [3] RSPM (R 4.3.0) ## broom 1.0.5 2023-06-09 [1] RSPM (R 4.3.0) ## bslib 0.7.0 2024-03-29 [2] RSPM (R 4.3.0) ## cachem 1.0.8 2023-05-01 [2] RSPM (R 4.3.0) ## caTools 1.18.2 2021-03-28 [1] RSPM (R 4.3.0) ## checkmate 2.3.1 2023-12-04 [1] RSPM (R 4.3.0) ## circlize 0.4.16 2024-02-20 [1] RSPM (R 4.3.0) ## cli 3.6.2 2023-12-11 [2] RSPM (R 4.3.0) ## clue 0.3-65 2023-09-23 [1] RSPM (R 4.3.0) ## cluster 2.1.6 2023-12-01 [3] CRAN (R 4.3.3) ## codetools 0.2-20 2024-03-31 [3] RSPM (R 4.3.0) ## colorspace 2.1-0 2023-01-23 [1] RSPM (R 4.3.0) ## colourpicker 1.3.0 2023-08-21 [1] RSPM (R 4.3.0) ## ComplexHeatmap * 2.18.0 2023-10-24 [1] Bioconductor ## config 0.3.2 2023-08-30 [1] RSPM (R 4.3.0) ## corpcor 1.6.10 2021-09-16 [1] RSPM (R 4.3.0) ## cowplot * 1.1.3 2024-01-22 [1] RSPM (R 4.3.0) ## crayon 1.5.2 2022-09-29 [2] RSPM (R 4.3.0) ## curl 5.2.1 2024-03-01 [2] RSPM (R 4.3.0) ## data.table 1.15.4 2024-03-30 [1] RSPM (R 4.3.0) ## DBI 1.2.2 2024-02-16 [1] RSPM (R 4.3.0) ## dbplyr * 2.5.0 2024-03-19 [1] RSPM (R 4.3.0) ## DelayedArray 0.28.0 2023-10-24 [1] Bioconductor ## DelayedMatrixStats 1.24.0 2023-10-24 [1] Bioconductor ## digest 0.6.35 2024-03-11 [2] RSPM (R 4.3.0) ## doParallel 1.0.17 2022-02-07 [1] RSPM (R 4.3.0) ## dotCall64 1.1-1 2023-11-28 [1] RSPM (R 4.3.0) ## dplyr 1.1.4 2023-11-17 [1] RSPM (R 4.3.0) ## DT 0.33 2024-04-04 [1] RSPM (R 4.3.0) ## edgeR * 4.0.16 2024-02-18 [1] Bioconductor 3.18 (R 4.3.2) ## EnvStats 2.8.1 2023-08-22 [1] RSPM (R 4.3.0) ## evaluate 0.23 2023-11-01 [2] RSPM (R 4.3.0) ## ExperimentHub 2.10.0 2023-10-24 [1] Bioconductor ## ExploreModelMatrix * 1.14.0 2023-10-24 [1] Bioconductor ## fANCOVA 0.6-1 2020-11-13 [1] RSPM (R 4.3.0) ## fansi 1.0.6 2023-12-08 [2] RSPM (R 4.3.0) ## fastmap 1.1.1 2023-02-24 [2] RSPM (R 4.3.0) ## fields 15.2 2023-08-17 [1] RSPM (R 4.3.0) ## filelock 1.0.3 2023-12-11 [1] RSPM (R 4.3.0) ## foreach 1.5.2 2022-02-02 [1] RSPM (R 4.3.0) ## foreign 0.8-86 2023-11-28 [3] CRAN (R 4.3.3) ## Formula 1.2-5 2023-02-24 [1] RSPM (R 4.3.0) ## fs 1.6.3 2023-07-20 [2] RSPM (R 4.3.0) ## generics 0.1.3 2022-07-05 [1] RSPM (R 4.3.0) ## GenomeInfoDb * 1.38.8 2024-03-15 [1] Bioconductor 3.18 (R 4.3.2) ## GenomeInfoDbData 1.2.11 2024-04-06 [1] Bioconductor ## GenomicAlignments 1.38.2 2024-01-16 [1] Bioconductor 3.18 (R 4.3.2) ## GenomicRanges * 1.54.1 2023-10-29 [1] Bioconductor ## GetoptLong 1.0.5 2020-12-15 [1] RSPM (R 4.3.0) ## ggbeeswarm 0.7.2 2023-04-29 [1] RSPM (R 4.3.0) ## ggplot2 * 3.5.0 2024-02-23 [1] RSPM (R 4.3.0) ## ggrepel * 0.9.5 2024-01-10 [1] RSPM (R 4.3.0) ## GlobalOptions 0.1.2 2020-06-10 [1] RSPM (R 4.3.0) ## glue 1.7.0 2024-01-09 [2] RSPM (R 4.3.0) ## golem 0.4.1 2023-06-05 [1] RSPM (R 4.3.0) ## gplots 3.1.3.1 2024-02-02 [1] RSPM (R 4.3.0) ## gridExtra 2.3 2017-09-09 [1] RSPM (R 4.3.0) ## gtable 0.3.5 2024-04-22 [1] RSPM (R 4.3.0) ## gtools 3.9.5 2023-11-20 [1] RSPM (R 4.3.0) ## here * 1.0.1 2020-12-13 [1] RSPM (R 4.3.0) ## Hmisc * 5.1-2 2024-03-11 [1] RSPM (R 4.3.0) ## htmlTable 2.4.2 2023-10-29 [1] RSPM (R 4.3.0) ## htmltools 0.5.8.1 2024-04-04 [2] RSPM (R 4.3.0) ## htmlwidgets 1.6.4 2023-12-06 [2] RSPM (R 4.3.0) ## httpuv 1.6.15 2024-03-26 [2] RSPM (R 4.3.0) ## httr 1.4.7 2023-08-15 [2] RSPM (R 4.3.0) ## igraph 2.0.3 2024-03-13 [1] RSPM (R 4.3.0) ## interactiveDisplayBase 1.40.0 2023-10-24 [1] Bioconductor ## IRanges * 2.36.0 2023-10-24 [1] Bioconductor ## irlba 2.3.5.1 2022-10-03 [1] RSPM (R 4.3.0) ## iSEE * 2.14.0 2023-10-24 [1] Bioconductor ## iterators 1.0.14 2022-02-05 [1] RSPM (R 4.3.0) ## jquerylib 0.1.4 2021-04-26 [2] RSPM (R 4.3.0) ## jsonlite 1.8.8 2023-12-04 [2] RSPM (R 4.3.0) ## KEGGREST 1.42.0 2023-10-24 [1] Bioconductor ## KernSmooth 2.23-22 2023-07-10 [3] CRAN (R 4.3.3) ## knitr 1.46 2024-04-06 [2] RSPM (R 4.3.0) ## later 1.3.2 2023-12-06 [2] RSPM (R 4.3.0) ## lattice 0.22-6 2024-03-20 [3] RSPM (R 4.3.0) ## lazyeval 0.2.2 2019-03-15 [1] RSPM (R 4.3.0) ## lifecycle 1.0.4 2023-11-07 [2] RSPM (R 4.3.0) ## limma * 3.58.1 2023-10-31 [1] Bioconductor ## lme4 1.1-35.3 2024-04-16 [1] RSPM (R 4.3.0) ## lmerTest 3.1-3 2020-10-23 [1] RSPM (R 4.3.0) ## lobstr * 1.1.2 2022-06-22 [1] RSPM (R 4.3.0) ## locfit 1.5-9.9 2024-03-01 [1] RSPM (R 4.3.0) ## magick 2.8.3 2024-02-18 [1] RSPM (R 4.3.0) ## magrittr 2.0.3 2022-03-30 [2] RSPM (R 4.3.0) ## maps 3.4.2 2023-12-15 [1] RSPM (R 4.3.0) ## MASS 7.3-60.0.1 2024-01-13 [3] CRAN (R 4.3.3) ## Matrix 1.6-5 2024-01-11 [3] CRAN (R 4.3.3) ## MatrixGenerics * 1.14.0 2023-10-24 [1] Bioconductor ## matrixStats * 1.3.0 2024-04-11 [1] RSPM (R 4.3.0) ## memoise 2.0.1 2021-11-26 [2] RSPM (R 4.3.0) ## mgcv 1.9-1 2023-12-21 [3] CRAN (R 4.3.3) ## mime 0.12 2021-09-28 [2] RSPM (R 4.3.0) ## miniUI 0.1.1.1 2018-05-18 [2] RSPM (R 4.3.0) ## minqa 1.2.6 2023-09-11 [1] RSPM (R 4.3.0) ## munsell 0.5.1 2024-04-01 [1] RSPM (R 4.3.0) ## mvtnorm 1.2-4 2023-11-27 [1] RSPM (R 4.3.0) ## nlme 3.1-164 2023-11-27 [3] CRAN (R 4.3.3) ## nloptr 2.0.3 2022-05-26 [1] RSPM (R 4.3.0) ## nnet 7.3-19 2023-05-03 [3] CRAN (R 4.3.3) ## numDeriv 2016.8-1.1 2019-06-06 [1] RSPM (R 4.3.0) ## paletteer 1.6.0 2024-01-21 [1] RSPM (R 4.3.0) ## patchwork * 1.2.0 2024-01-08 [1] RSPM (R 4.3.0) ## pbkrtest 0.5.2 2023-01-19 [1] RSPM (R 4.3.0) ## pheatmap * 1.0.12 2019-01-04 [1] RSPM (R 4.3.0) ## pillar 1.9.0 2023-03-22 [2] RSPM (R 4.3.0) ## pkgconfig 2.0.3 2019-09-22 [2] RSPM (R 4.3.0) ## plotly 4.10.4 2024-01-13 [1] RSPM (R 4.3.0) ## plyr 1.8.9 2023-10-02 [1] RSPM (R 4.3.0) ## png 0.1-8 2022-11-29 [1] RSPM (R 4.3.0) ## Polychrome * 1.5.1 2022-05-03 [1] RSPM (R 4.3.0) ## postcards * 0.2.3 2022-01-07 [1] RSPM (R 4.3.0) ## promises 1.3.0 2024-04-05 [2] RSPM (R 4.3.0) ## purrr 1.0.2 2023-08-10 [2] RSPM (R 4.3.0) ## R.cache 0.16.0 2022-07-21 [1] RSPM (R 4.3.0) ## R.methodsS3 1.8.2 2022-06-13 [1] RSPM (R 4.3.0) ## R.oo 1.26.0 2024-01-24 [1] RSPM (R 4.3.0) ## R.utils 2.12.3 2023-11-18 [1] RSPM (R 4.3.0) ## R6 2.5.1 2021-08-19 [2] RSPM (R 4.3.0) ## rappdirs 0.3.3 2021-01-31 [2] RSPM (R 4.3.0) ## rbibutils 2.2.16 2023-10-25 [1] RSPM (R 4.3.0) ## RColorBrewer * 1.1-3 2022-04-03 [1] RSPM (R 4.3.0) ## Rcpp 1.0.12 2024-01-09 [2] RSPM (R 4.3.0) ## RCurl 1.98-1.14 2024-01-09 [1] RSPM (R 4.3.0) ## Rdpack 2.6 2023-11-08 [1] RSPM (R 4.3.0) ## recount3 * 1.12.0 2023-10-24 [1] Bioconductor ## remaCor 0.0.18 2024-02-08 [1] RSPM (R 4.3.0) ## rematch2 2.1.2 2020-05-01 [2] RSPM (R 4.3.0) ## reshape2 1.4.4 2020-04-09 [1] RSPM (R 4.3.0) ## restfulr 0.0.15 2022-06-16 [1] RSPM (R 4.3.2) ## RhpcBLASctl 0.23-42 2023-02-11 [1] RSPM (R 4.3.0) ## rintrojs 0.3.4 2024-01-11 [1] RSPM (R 4.3.0) ## rjson 0.2.21 2022-01-09 [1] RSPM (R 4.3.0) ## rlang * 1.1.3 2024-01-10 [2] RSPM (R 4.3.0) ## rmarkdown 2.26 2024-03-05 [2] RSPM (R 4.3.0) ## rpart 4.1.23 2023-12-05 [3] CRAN (R 4.3.3) ## rprojroot 2.0.4 2023-11-05 [2] RSPM (R 4.3.0) ## Rsamtools 2.18.0 2023-10-24 [1] Bioconductor ## RSQLite 2.3.6 2024-03-31 [1] RSPM (R 4.3.0) ## rstudioapi 0.16.0 2024-03-24 [2] RSPM (R 4.3.0) ## rsvd 1.0.5 2021-04-16 [1] RSPM (R 4.3.0) ## rtracklayer 1.62.0 2023-10-24 [1] Bioconductor ## S4Arrays 1.2.1 2024-03-04 [1] Bioconductor 3.18 (R 4.3.2) ## S4Vectors * 0.40.2 2023-11-23 [1] Bioconductor 3.18 (R 4.3.2) ## sass 0.4.9 2024-03-15 [2] RSPM (R 4.3.0) ## ScaledMatrix 1.10.0 2023-10-24 [1] Bioconductor ## scales 1.3.0 2023-11-28 [1] RSPM (R 4.3.0) ## scater * 1.30.1 2023-11-16 [1] Bioconductor ## scatterplot3d 0.3-44 2023-05-05 [1] RSPM (R 4.3.0) ## scuttle * 1.12.0 2023-10-24 [1] Bioconductor ## sessioninfo * 1.2.2 2021-12-06 [2] RSPM (R 4.3.0) ## shape 1.4.6.1 2024-02-23 [1] RSPM (R 4.3.0) ## shiny 1.8.1.1 2024-04-02 [2] RSPM (R 4.3.0) ## shinyAce 0.4.2 2022-05-06 [1] RSPM (R 4.3.0) ## shinydashboard 0.7.2 2021-09-30 [1] RSPM (R 4.3.0) ## shinyjs 2.1.0 2021-12-23 [1] RSPM (R 4.3.0) ## shinyWidgets 0.8.5 2024-04-17 [1] RSPM (R 4.3.0) ## SingleCellExperiment * 1.24.0 2023-10-24 [1] Bioconductor ## smokingMouse * 0.99.91 2024-05-28 [1] Github (LieberInstitute/smokingMouse@96d8480) ## spam 2.10-0 2023-10-23 [1] RSPM (R 4.3.0) ## SparseArray 1.2.4 2024-02-11 [1] Bioconductor 3.18 (R 4.3.2) ## sparseMatrixStats 1.14.0 2023-10-24 [1] Bioconductor ## SpatialExperiment * 1.12.0 2023-10-24 [1] Bioconductor ## spatialLIBD * 1.14.1 2023-11-30 [1] Bioconductor 3.18 (R 4.3.2) ## statmod 1.5.0 2023-01-06 [1] RSPM (R 4.3.0) ## stringi 1.8.3 2023-12-11 [2] RSPM (R 4.3.0) ## stringr * 1.5.1 2023-11-14 [2] RSPM (R 4.3.0) ## styler 1.10.3 2024-04-07 [1] RSPM (R 4.3.0) ## SummarizedExperiment * 1.32.0 2023-10-24 [1] Bioconductor ## tibble 3.2.1 2023-03-20 [2] RSPM (R 4.3.0) ## tidyr 1.3.1 2024-01-24 [1] RSPM (R 4.3.0) ## tidyselect 1.2.1 2024-03-11 [1] RSPM (R 4.3.0) ## usethis * 2.2.3 2024-02-19 [2] RSPM (R 4.3.0) ## utf8 1.2.4 2023-10-22 [2] RSPM (R 4.3.0) ## variancePartition * 1.32.5 2024-02-16 [1] Bioconductor 3.18 (R 4.3.2) ## vctrs 0.6.5 2023-12-01 [2] RSPM (R 4.3.0) ## vipor 0.4.7 2023-12-18 [1] RSPM (R 4.3.0) ## viridis 0.6.5 2024-01-29 [1] RSPM (R 4.3.0) ## viridisLite 0.4.2 2023-05-02 [1] RSPM (R 4.3.0) ## withr 3.0.0 2024-01-16 [2] RSPM (R 4.3.0) ## xfun 0.43 2024-03-25 [2] RSPM (R 4.3.0) ## XML 3.99-0.16.1 2024-01-22 [1] RSPM (R 4.3.0) ## xtable 1.8-4 2019-04-21 [2] RSPM (R 4.3.0) ## XVector 0.42.0 2023-10-24 [1] Bioconductor ## yaml 2.3.8 2023-12-11 [2] RSPM (R 4.3.0) ## zlibbioc 1.48.2 2024-03-13 [1] Bioconductor 3.18 (R 4.3.2) ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library ## ## ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── proc.time() ## user system elapsed ## 12.220 1.012 12.914 This interactive book was last updated at 2024-05-28 02:35:05.342809. License This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. "],["speaqeasy-introduction.html", "1 SPEAQeasy introduction 1.1 2022-04-20 overview slides 1.2 SPEAQeasy main links 1.3 Pipeline outputs 1.4 Exercises 1.5 Solutions", " 1 SPEAQeasy introduction Instructor: Leo Congrats Nick https://t.co/O3u5XRPXy2 for your @biorxivpreprint first pre-print! 🙌🏽SPEAQeasy is our @nextflowio implementation of the #RNAseq processing pipeline that produces @Bioconductor-friendly #rstats objects that we use at @LieberInstitute📜 https://t.co/zKuBRtBCmY pic.twitter.com/F83fXI90eP — 🇲🇽 Leonardo Collado-Torres (@lcolladotor) December 12, 2020 1.1 2022-04-20 overview slides 1.2 SPEAQeasy main links Paper: https://doi.org/10.1186/s12859-021-04142-3 Documentation website: http://research.libd.org/SPEAQeasy/ Source code: https://github.com/LieberInstitute/SPEAQeasy Example website: http://research.libd.org/SPEAQeasy-example/ Source code: https://github.com/LieberInstitute/SPEAQeasy-example Differential expression analysis bootcamp: https://lcolladotor.github.io/bioc_team_ds/differential-expression-analysis.html 3 sessions, each 2 hours long 1.3 Pipeline outputs Documentation chapter: http://research.libd.org/SPEAQeasy/outputs.html That’s enough links! Lets download some data to check it out. We’ll use BiocFileCache to keep the data in a local cache in case we want to run this example again and don’t want to re-download the data from the web. ## Load the container package for this type of data library(&quot;SummarizedExperiment&quot;) ## Download and cache the file library(&quot;BiocFileCache&quot;) bfc &lt;- BiocFileCache::BiocFileCache() cached_rse_gene_example &lt;- BiocFileCache::bfcrpath( x = bfc, &quot;https://github.com/LieberInstitute/SPEAQeasy-example/raw/master/rse_speaqeasy.RData&quot; ) ## adding rname &#39;https://github.com/LieberInstitute/SPEAQeasy-example/raw/master/rse_speaqeasy.RData&#39; ## Check the local path on our cache cached_rse_gene_example ## BFC1 ## &quot;/github/home/.cache/R/BiocFileCache/107d2e59e079_rse_speaqeasy.RData&quot; ## Load the rse_gene object load(cached_rse_gene_example, verbose = TRUE) ## Loading objects: ## rse_gene ## General overview of the object rse_gene ## class: RangedSummarizedExperiment ## dim: 60609 40 ## metadata(0): ## assays(1): counts ## rownames(60609): ENSG00000223972.5 ENSG00000227232.5 ... ENSG00000210195.2 ENSG00000210196.2 ## rowData names(10): Length gencodeID ... NumTx gencodeTx ## colnames(40): R13896_H7JKMBBXX R13903_HCTYLBBXX ... R15120_HFY2MBBXX R15134_HFFGHBBXX ## colData names(67): SAMPLE_ID FQCbasicStats ... AgeDeath BrNum ## We can check how big the object is with lobstr lobstr::obj_size(rse_gene) ## 35.78 MB 1.4 Exercises p.exercise { background-color: #E4EDE2; padding: 9px; border: 1px solid black; border-radius: 10px; font-family: sans-serif; } Exercise 1: Either by exploring the object rse_gene or by checking the SPEAQeasy documentation, what are the possible values for the variable trimmed? Exercise 2: Across genes (rse_gene), exons (rse_exon), exon-exon junctions (rse_jx), and transcripts (rse_tx), what part of the output is identical? If you want to answer this question with data, you could use the 4 RSE objects from the BrainSEQ Phase II study that are available at http://eqtl.brainseq.org/phase2/. They were created with the scripts at https://github.com/LieberInstitute/brainseq_phase2#rse_gene_unfilteredrdata. Note that these are much larger objects since they contain information for 900 samples. 1.5 Solutions p.solution { background-color: #C093D6; padding: 9px; border: 1px solid black; border-radius: 10px; font-family: sans-serif; } Solution 1: From http://research.libd.org/SPEAQeasy/outputs.html#quality-metrics the answer was: A boolean value (“TRUE” or “FALSE”), indicating whether the given sample underwent trimming With code, it’s this: class(rse_gene$trimmed) ## [1] &quot;logical&quot; ## logical vectors can take 2 values (plus the third `NA` if it&#39;s missing) Solution 2: From http://research.libd.org/SPEAQeasy/outputs.html#coldata-of-rse-objects the answer is that all objects have identical colData(). "],["smokingmouse-study.html", "2 smokingMouse study 2.1 Introduction 2.2 Overview 2.3 Goals 2.4 Study design", " 2 smokingMouse study Instructor: Daianna As part of your training, we’ll guide you through an analysis with real bulk RNA-seq data. The dataset that we’ll be using is a RangedSummarizedExperiment coming from the smokingMouse (Gonzalez-Padilla and Collado-Torres, 2024) package, but in this chapter we’ll explain you the study design and the experimental stages that preceded the data generation. The smoking mouse study is a project currently being developed at the Lieber Institute for Brain Development by Daianna Gonzalez-Padilla and Leonardo Collado-Torres. 2.1 Introduction Nowadays, maternal smoking during pregnancy (MSDP) is one of the major health concerns worldwide not only because of the effects on the smoker but because the health of the offspring could be dramatically affected by smoking exposure, particularly their cognitive and behavioral traits. But are those effects caused by cigarette smoke only? Or are those alterations given by a specific component of cigarettes such as nicotine? The latter is a very relevant question because most of the studies have focused on analyzing smoking effects, ignoring the role of nicotine, an active component of the cigarettes. Understanding which effects are specifically dictated by nicotine prenatal exposure will enable more directed studies of this drug on the developing brain, once affected genes have been identified and experimentally proven. 2.2 Overview This study consisted of a series of bulk RNA-sequencing experiments performed on brain samples from adult mice and pups and on blood samples from adults. Adult mice were either exposed to cigarette smoke (what we call smoking experiment and smoking mice) or controls of the smoking experiment, or they were administered nicotine (nicotine experiment and nicotine mice) or controls of the nicotine experiment, and they were either pregnant or not. Smoking, nicotine and control pups are pups that were born to smoking, nicotine and control pregnant mice, respectively. This experimental design allowed us to contrast the altered features in both conditions and to compare the effects in different mouse ages, sexes, tissues and pregnancy states. The original datasets contain gene, transcript, exon, and exon-exon junction expression levels across 208 samples, but in this course we’ll only use gene data in nicotine samples to simplify the analyses. 2.3 Goals This project actually aimed to answer 4 questions, all related to smoking and nicotine effects in mouse. 2.3.1 Main objective The main goal was to identify and differentiate the effects of prenatal nicotine and smoking exposures on gene, transcript, exon and junction expression of developing brain of pups. Basically, to perform a differential expression analysis on mouse data to find significant feature expression changes. 2.3.2 Secondary objectives To evaluate the affected genes by each substance on adult brain in order to compare pup and adult results. To examine the effects of smoking on adult blood and brain to search for overlapping biomarkers in both tissues (Can blood analyses capture environmental effects on brain?) To compare mouse differentially expressed genes (DEGs) with results from previous studies in human (Semick, S.A. et al. (2018) and Toikumo, S. et al. (2023)). Check here for the code of the original and complete analyses done. 2.4 Study design As presented in Figure 1: A), 36 pregnant dams and 35 non-pregnant female adult mice were either administered nicotine by intraperitoneal injection (IP; n=12), exposed to cigarette smoke in smoking chambers (n=24), or controls (n=35; 11 nicotine controls and 24 smoking controls). A total of 137 pups were born to pregnant dams: 19 were born to mice that were administered nicotine, 46 to mice exposed to cigarette smoke and the remaining 72 to control mice (23 to nicotine controls and 49 to smoking controls). Samples from frontal cortices of P0 pups and adults were obtained, as well as blood samples from smoking-exposed and smoking control adults. Then, as shown in B) RNA was extracted from all those samples and RNA-seq libraries were prepared and sequenced to obtain expression counts for genes, exons, transcripts, and exon-exon junctions. Figure 1: Experimental design of the study. "],["summarizedexperiment-review.html", "3 SummarizedExperiment review 3.1 Overview 3.2 Quiz 3.3 Exercises 3.4 Solutions", " 3 SummarizedExperiment review Instructor: Renee LIBD rstats club notes 3.1 Overview The SummarizedExperiment class is used to store experimental results in the form of matrixes. Objects of this class include observations (features) of the samples, as well as additional metadata. Usually, this type of object is automatically generated as the output of other software (ie. SPEAQeasy), but you can also build them. One of the main characteristics of SummarizedExperiment is that it allows you to handle you data in a “coordinated” way. For example, if you want to subset your data, with SummarizedExperiment you can do so without worrying your assays and metadata unsync. 3.2 Quiz How many classes does the SummarizedExperiment class has? What does features stand for? Which is the structure of the SummarizedExperiment class? What type of data can we store on an assay? What information does colData has? 3.3 Exercises We are gonna use the same sample data set as yesterday from the airway library library(SummarizedExperiment) library(airway) data(airway, package = &quot;airway&quot;) se &lt;- airway p.exercise { background-color: #E4EDE2; padding: 9px; border: 1px solid black; border-radius: 10px; font-family: sans-serif; } Exercise 1: a) How many genes do we have in this object? And samples? b) How many samples come from donors treated (trt) with dexamethasone (dex)? ## For a) you could only print the summary of the object but since the idea is to understand ## how to explore the object find other function that gives you the answer. se #&gt; class: RangedSummarizedExperiment #&gt; dim: 63677 8 #&gt; metadata(1): &#39;&#39; #&gt; assays(1): counts #&gt; rownames(63677): ENSG00000000003 ENSG00000000005 ... ENSG00000273492 ENSG00000273493 #&gt; rowData names(10): gene_id gene_name ... seq_coord_system symbol #&gt; colnames(8): SRR1039508 SRR1039509 ... SRR1039520 SRR1039521 #&gt; colData names(9): SampleName cell ... Sample BioSample ## Same thing for b, you could just print the colData and count the samples, but this is not ## efficient when our data consists in hundreds of samples. Find the answer using other tools. colData(se) #&gt; DataFrame with 8 rows and 9 columns #&gt; SampleName cell dex albut Run avgLength Experiment Sample BioSample #&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;integer&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; #&gt; SRR1039508 GSM1275862 N61311 untrt untrt SRR1039508 126 SRX384345 SRS508568 SAMN02422669 #&gt; SRR1039509 GSM1275863 N61311 trt untrt SRR1039509 126 SRX384346 SRS508567 SAMN02422675 #&gt; SRR1039512 GSM1275866 N052611 untrt untrt SRR1039512 126 SRX384349 SRS508571 SAMN02422678 #&gt; SRR1039513 GSM1275867 N052611 trt untrt SRR1039513 87 SRX384350 SRS508572 SAMN02422670 #&gt; [ reached getOption(&quot;max.print&quot;) -- omitted 4 rows ] Exercise 2: Add another assay that has the log10 of your original counts ## In our object, if you look at the part that says assays, we can see that at the moment ## we only have one with the name &quot;counts&quot; se #&gt; class: RangedSummarizedExperiment #&gt; dim: 63677 8 #&gt; metadata(1): &#39;&#39; #&gt; assays(1): counts #&gt; rownames(63677): ENSG00000000003 ENSG00000000005 ... ENSG00000273492 ENSG00000273493 #&gt; rowData names(10): gene_id gene_name ... seq_coord_system symbol #&gt; colnames(8): SRR1039508 SRR1039509 ... SRR1039520 SRR1039521 #&gt; colData names(9): SampleName cell ... Sample BioSample ## To see the data that&#39;s stored in that assay you can do either one of the next commands assay(se) #&gt; SRR1039508 SRR1039509 SRR1039512 SRR1039513 SRR1039516 SRR1039517 SRR1039520 SRR1039521 #&gt; ENSG00000000003 679 448 873 408 1138 1047 770 572 #&gt; ENSG00000000005 0 0 0 0 0 0 0 0 #&gt; ENSG00000000419 467 515 621 365 587 799 417 508 #&gt; ENSG00000000457 260 211 263 164 245 331 233 229 #&gt; ENSG00000000460 60 55 40 35 78 63 76 60 #&gt; ENSG00000000938 0 0 2 0 1 0 0 0 #&gt; [ reached getOption(&quot;max.print&quot;) -- omitted 63671 rows ] assays(se)$counts #&gt; SRR1039508 SRR1039509 SRR1039512 SRR1039513 SRR1039516 SRR1039517 SRR1039520 SRR1039521 #&gt; ENSG00000000003 679 448 873 408 1138 1047 770 572 #&gt; ENSG00000000005 0 0 0 0 0 0 0 0 #&gt; ENSG00000000419 467 515 621 365 587 799 417 508 #&gt; ENSG00000000457 260 211 263 164 245 331 233 229 #&gt; ENSG00000000460 60 55 40 35 78 63 76 60 #&gt; ENSG00000000938 0 0 2 0 1 0 0 0 #&gt; [ reached getOption(&quot;max.print&quot;) -- omitted 63671 rows ] ## Note that assay() does not support $ operator # assay(se)$counts ## We would have to do: assay(se, 1) #&gt; SRR1039508 SRR1039509 SRR1039512 SRR1039513 SRR1039516 SRR1039517 SRR1039520 SRR1039521 #&gt; ENSG00000000003 679 448 873 408 1138 1047 770 572 #&gt; ENSG00000000005 0 0 0 0 0 0 0 0 #&gt; ENSG00000000419 467 515 621 365 587 799 417 508 #&gt; ENSG00000000457 260 211 263 164 245 331 233 229 #&gt; ENSG00000000460 60 55 40 35 78 63 76 60 #&gt; ENSG00000000938 0 0 2 0 1 0 0 0 #&gt; [ reached getOption(&quot;max.print&quot;) -- omitted 63671 rows ] assay(se, &quot;counts&quot;) #&gt; SRR1039508 SRR1039509 SRR1039512 SRR1039513 SRR1039516 SRR1039517 SRR1039520 SRR1039521 #&gt; ENSG00000000003 679 448 873 408 1138 1047 770 572 #&gt; ENSG00000000005 0 0 0 0 0 0 0 0 #&gt; ENSG00000000419 467 515 621 365 587 799 417 508 #&gt; ENSG00000000457 260 211 263 164 245 331 233 229 #&gt; ENSG00000000460 60 55 40 35 78 63 76 60 #&gt; ENSG00000000938 0 0 2 0 1 0 0 0 #&gt; [ reached getOption(&quot;max.print&quot;) -- omitted 63671 rows ] ## If you use assays() without specifying the element you want to see it shows you the length ## of the list and the name of each element assays(se) #&gt; List of length 1 #&gt; names(1): counts ## To obtain a list of names as a vector you can do: assayNames(se) #&gt; [1] &quot;counts&quot; ## Which can also be use to change the name of the assays assayNames(se)[1] &lt;- &quot;foo&quot; assayNames(se) #&gt; [1] &quot;foo&quot; assayNames(se)[1] &lt;- &quot;counts&quot; Exercise 3: Explore the metadata and add a new column that has the library size of each sample. ## To calculate the library size use apply(assay(se), 2, sum) #&gt; SRR1039508 SRR1039509 SRR1039512 SRR1039513 SRR1039516 SRR1039517 SRR1039520 SRR1039521 #&gt; 20637971 18809481 25348649 15163415 24448408 30818215 19126151 21164133 3.4 Solutions p.solution { background-color: #C093D6; padding: 9px; border: 1px solid black; border-radius: 10px; font-family: sans-serif; } Solution 1: ## For a), dim() gives the desired answer dim(se) #&gt; [1] 63677 8 ## For b), colData(se)[colData(se)$dex == &quot;trt&quot;, ] #&gt; DataFrame with 4 rows and 9 columns #&gt; SampleName cell dex albut Run avgLength Experiment Sample BioSample #&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;integer&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; #&gt; SRR1039509 GSM1275863 N61311 trt untrt SRR1039509 126 SRX384346 SRS508567 SAMN02422675 #&gt; SRR1039513 GSM1275867 N052611 trt untrt SRR1039513 87 SRX384350 SRS508572 SAMN02422670 #&gt; SRR1039517 GSM1275871 N080611 trt untrt SRR1039517 126 SRX384354 SRS508576 SAMN02422673 #&gt; SRR1039521 GSM1275875 N061011 trt untrt SRR1039521 98 SRX384358 SRS508580 SAMN02422677 Solution 2: ## There are multiple ways to do it assay(se, &quot;logcounts&quot;) &lt;- log10(assay(se, &quot;counts&quot;)) assays(se)$logcounts_v2 &lt;- log10(assays(se)$counts) Solution 3: ## To add the library size we an use.. colData(se)$library_size &lt;- apply(assay(se), 2, sum) names(colData(se)) #&gt; [1] &quot;SampleName&quot; &quot;cell&quot; &quot;dex&quot; &quot;albut&quot; &quot;Run&quot; &quot;avgLength&quot; &quot;Experiment&quot; #&gt; [8] &quot;Sample&quot; &quot;BioSample&quot; &quot;library_size&quot; "],["smokingmouse-rse.html", "4 smokingMouse RSE 4.1 Download data 4.2 Data overview", " 4 smokingMouse RSE Instructor: Daianna Once you have reviewed how to use RangedSummarizedExperiment (RSE) objects in R, now we’ll start exploring the smokingMouse data. As previously described, the smoking mouse project is a complex study with more than 200 samples from brain and blood, adult mice and pups, pregnant and not pregnant mice, etc. The whole datasets of this project can be downloaded from the smokingMouse (Gonzalez-Padilla and Collado-Torres, 2024) package. Visit here for more details. 4.1 Download data For illustrative purposes, we’ll use nicotine data at the gene level which reside in a RangedSummarizedExperiment (RSE) object called rse_gene. We’ll use BiocFileCache to keep the data in a local cache in case we want to run this example again and don’t want to re-download the data from the web. ## Load the container package for this type of data library(&quot;SummarizedExperiment&quot;) ## Download and cache the file library(&quot;BiocFileCache&quot;) bfc &lt;- BiocFileCache::BiocFileCache() cached_rse_gene &lt;- BiocFileCache::bfcrpath( x = bfc, &quot;https://github.com/LieberInstitute/SPEAQeasyWorkshop2023/raw/devel/provisional_data/rse_gene_mouse_RNAseq_nic-smo.Rdata&quot; ) #&gt; adding rname &#39;https://github.com/LieberInstitute/SPEAQeasyWorkshop2023/raw/devel/provisional_data/rse_gene_mouse_RNAseq_nic-smo.Rdata&#39; ## Check the local path on our cache cached_rse_gene #&gt; BFC2 #&gt; &quot;/github/home/.cache/R/BiocFileCache/107d14e54709_rse_gene_mouse_RNAseq_nic-smo.Rdata&quot; ## Load the rse_gene object load(cached_rse_gene, verbose = TRUE) #&gt; Loading objects: #&gt; rse_gene ## General overview of the object rse_gene #&gt; class: RangedSummarizedExperiment #&gt; dim: 55401 208 #&gt; metadata(1): Obtained_from #&gt; assays(2): counts logcounts #&gt; rownames(55401): ENSMUSG00000102693.1 ENSMUSG00000064842.1 ... ENSMUSG00000064371.1 ENSMUSG00000064372.1 #&gt; rowData names(13): Length gencodeID ... DE_in_pup_brain_nicotine DE_in_pup_brain_smoking #&gt; colnames: NULL #&gt; colData names(71): SAMPLE_ID FQCbasicStats ... retained_after_QC_sample_filtering #&gt; retained_after_manual_sample_filtering 4.2 Data overview 4.2.1 Assays The dataset rse_gene contains the following assays: counts: original read counts of the 55,401 mouse genes across 208 samples (inlcuding the 65 nicotine samples of interest). logcounts: normalized and scaled counts (\\(log_2(CPM + 0.5)\\)) of the same genes across the same samples; normalization was carried out applying TMM method with cpm(calcNormFactors()) of edgeR. ## Explore main assay (of raw counts) assay(rse_gene)[1:3, 1:3] ## counts for first 3 genes and 3 samples #&gt; [,1] [,2] [,3] #&gt; ENSMUSG00000102693.1 0 0 0 #&gt; ENSMUSG00000064842.1 0 0 0 #&gt; ENSMUSG00000051951.5 811 710 812 ## Access the same raw data with assays() assays(rse_gene)$counts[1:3, 1:3] #&gt; [,1] [,2] [,3] #&gt; ENSMUSG00000102693.1 0 0 0 #&gt; ENSMUSG00000064842.1 0 0 0 #&gt; ENSMUSG00000051951.5 811 710 812 ## Access lognorm counts assays(rse_gene)$logcounts[1:3, 1:3] #&gt; [,1] [,2] [,3] #&gt; ENSMUSG00000102693.1 -5.985331 -5.985331 -5.985331 #&gt; ENSMUSG00000064842.1 -5.985331 -5.985331 -5.985331 #&gt; ENSMUSG00000051951.5 4.509114 4.865612 4.944597 4.2.2 Sample data Yellow variables correspond to SPEAQeasy outputs that are going to be used in downstream analyses. Pink variables are specific to the study, such as sample metadata and some others containing additional information about the genes. Blue variables are quality-control metrics computed by addPerCellQC() of scuttle. The same RSE contains the sample information in colData(RSE): SAMPLE_ID : is the name of the sample. ERCCsumLogErr : a summary statistic quantifying overall difference of expected and actual ERCC concentrations for one sample. For more about ERCC check their product page at https://www.thermofisher.com/order/catalog/product/4456740. overallMapRate : the decimal fraction of reads which successfully mapped to the reference genome (i.e. numMapped / numReads). mitoMapped : the number of reads which successfully mapped to the mitochondrial chromosome. totalMapped : the number of reads which successfully mapped to the canonical sequences in the reference genome (excluding mitochondrial chromosomes). mitoRate : the decimal fraction of reads which mapped to the mitochondrial chromosome, of those which map at all (i.e. mitoMapped / (totalMapped + mitoMapped)) totalAssignedGene : the decimal fraction of reads assigned unambiguously to a gene (including mitochondrial genes), with featureCounts (Liao et al. 2014), of those in total. rRNA_rate : the decimal fraction of reads assigned to a gene whose type is ‘rRNA’, of those assigned to any gene. Tissue : tissue (mouse brain or blood) from which the sample comes. Age : if the sample comes from an adult or a pup mouse. Sex : if the sample comes from a female (F) or male (M) mouse. Expt : the experiment (nicotine or smoking exposure) to which the sample mouse was subjected; it could be an exposed or a control mouse of that experiment. Group : if the sample belongs to a nicotine/smoking-exposed mouse (Expt) or a nicotine/smoking control mouse (Ctrl). plate : is the plate (1,2 or 3) in which the sample library was prepared. Pregnancy : if the sample comes from a pregnant (Yes) or not pregnant (No) mouse. medium : is the medium in which the sample was treated: water for brain samples and an elution buffer (EB) for the blood ones. flowcell : is the sequencing batch of each sample. sum : library size (total sum of counts across all genes for each sample). detected : number of non-zero expressed genes in each sample. subsets_Mito_sum : total sum of read counts of mt genes in each sample. subsets_Mito_detected : total number of mt genes in each sample. subsets_Mito_percent : % of mt genes’ counts of the total counts of the sample. subsets_Ribo_sum : total sum of read counts of ribosomal genes in each sample. subsets_Ribo_detected : total number of ribosomal genes in each sample. subsets_Ribo_percent : % of ribosomal genes’ counts of the total counts of the sample. Note: in our case, we’ll use samples from the nicotine experiment only, so all samples come from brain and were treated in water. ## Data for first 3 samples and 5 variables colData(rse_gene)[1:3, 1:5] #&gt; DataFrame with 3 rows and 5 columns #&gt; SAMPLE_ID FQCbasicStats perBaseQual perTileQual perSeqQual #&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; #&gt; 1 Sample_2914 PASS PASS PASS PASS #&gt; 2 Sample_4042 PASS PASS PASS PASS #&gt; 3 Sample_4043 PASS PASS PASS PASS 4.2.3 Gene Information Among the information in rowData(RSE) the next variables are of interest for the analysis: gencodeID : GENCODE ID of each gene. ensemblID : gene ID in Ensembl database. EntrezID : identifier of each gene in NCBI Entrez database. Symbol : official gene symbol for each mouse gene. retained_after_feature_filtering : Boolean variable that equals TRUE if the gene passed the gene filtering (with filterByExpr() of edgeR) based on its expression levels and FALSE if not. DE_in_adult_brain_nicotine : Boolean variable that equals TRUE if the feature is differentially expressed (DE) in adult brain samples exposed to nicotine and FALSE if not. DE_in_pup_brain_nicotine : Boolean variable that equals TRUE if the feature is differentially expressed (DE) in pup brain samples exposed to nicotine and FALSE if not. ## Data for first 3 genes and 5 variables rowData(rse_gene)[1:3, 1:5] #&gt; DataFrame with 3 rows and 5 columns #&gt; Length gencodeID ensemblID gene_type EntrezID #&gt; &lt;integer&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; #&gt; ENSMUSG00000102693.1 1070 ENSMUSG00000102693.1 ENSMUSG00000102693 TEC 71042 #&gt; ENSMUSG00000064842.1 110 ENSMUSG00000064842.1 ENSMUSG00000064842 snRNA NA #&gt; ENSMUSG00000051951.5 6094 ENSMUSG00000051951.5 ENSMUSG00000051951 protein_coding 497097 p.exercise { background-color: #E4EDE2; padding: 9px; border: 1px solid black; border-radius: 10px; font-family: sans-serif; } 📑 Exercise 1: How would you access data of a specific sample variable? For illustrative purposes, we’ll use nicotine data at the gene level only so let’s access that data. ## Original dimensions of the data dim(rse_gene) #&gt; [1] 55401 208 rse_gene_nic &lt;- rse_gene[, which(rse_gene$Expt == &quot;Nicotine&quot;)] ## New dimensions dim(rse_gene_nic) #&gt; [1] 55401 65 📑 Exercise 2: How could you check that all samples are from the nicotine experiment? 📑 Exercise 3: How many nicotine samples correspond to adults and how many to pups? How many pups were males and how many were females? "],["isee-introduction.html", "5 iSEE introduction 5.1 Toy RSE data 5.2 iSEE 5.3 Exercise with data from spatialLIBD 5.4 Community", " 5 iSEE introduction Instructor: Leo 5.1 Toy RSE data ## Lets build a simple SummarizedExperiment object following information ## from the documentation library(&quot;SummarizedExperiment&quot;) ## ?SummarizedExperiment ## Adapted from the official documentation: ## First we create the data pieces that we&#39;ll use to build our ## SummarizedExperiment object. In this case, we&#39;ll have 200 genes ## measured in 6 samples. nrows &lt;- 200 ncols &lt;- 6 ## Let&#39;s make up some count numbers at random set.seed(20210223) counts &lt;- matrix(runif(nrows * ncols, 1, 1e4), nrows) ## Then some basic infomratino for our genes rowRanges &lt;- GRanges( rep(c(&quot;chr1&quot;, &quot;chr2&quot;), c(50, 150)), IRanges(floor(runif(200, 1e5, 1e6)), width = 100), strand = sample(c(&quot;+&quot;, &quot;-&quot;), 200, TRUE), feature_id = sprintf(&quot;ID%03d&quot;, 1:200) ) names(rowRanges) &lt;- paste0(&quot;gene_&quot;, seq_len(length(rowRanges))) ## Next, we create some information about samples colData &lt;- DataFrame( Treatment = rep(c(&quot;ChIP&quot;, &quot;Input&quot;), 3), row.names = LETTERS[1:6] ) ## Finally we put all these pieces together in a single R object rse &lt;- SummarizedExperiment( assays = SimpleList(counts = counts), rowRanges = rowRanges, colData = colData ) ## Overview rse #&gt; class: RangedSummarizedExperiment #&gt; dim: 200 6 #&gt; metadata(0): #&gt; assays(1): counts #&gt; rownames(200): gene_1 gene_2 ... gene_199 gene_200 #&gt; rowData names(1): feature_id #&gt; colnames(6): A B ... E F #&gt; colData names(1): Treatment 5.2 iSEE How can you make plots from SummarizedExperiment objects without having to write any code? The answer is with iSEE 🎨 http://bioconductor.org/packages/iSEE http://bioconductor.org/packages/release/bioc/vignettes/iSEE/inst/doc/basic.html ## Let&#39;s explore the `rse` object interactively library(&quot;iSEE&quot;) iSEE::iSEE(rse) 5.3 Exercise with data from spatialLIBD We’ll download a SingleCellExperiment object, which is similar to SummarizedExperiment as it extends it. http://bioconductor.org/packages/SingleCellExperiment http://bioconductor.org/packages/spatialLIBD https://doi.org/10.1038/s41593-020-00787-0 https://osca.bioconductor.org/ https://www.nature.com/articles/s41592-019-0654-x Figures 2 and 3 ## Lets get some data using spatialLIBD sce_layer &lt;- spatialLIBD::fetch_data(&quot;sce_layer&quot;) #&gt; adding rname &#39;https://www.dropbox.com/s/bg8xwysh2vnjwvg/Human_DLPFC_Visium_processedData_sce_scran_sce_layer_spatialLIBD.Rdata?dl=1&#39; #&gt; 2024-05-28 02:35:18.612336 loading file /github/home/.cache/R/BiocFileCache/107d428bede0_Human_DLPFC_Visium_processedData_sce_scran_sce_layer_spatialLIBD.Rdata%3Fdl%3D1 sce_layer #&gt; class: SingleCellExperiment #&gt; dim: 22331 76 #&gt; metadata(0): #&gt; assays(2): counts logcounts #&gt; rownames(22331): ENSG00000243485 ENSG00000238009 ... ENSG00000278384 ENSG00000271254 #&gt; rowData names(10): source type ... is_top_hvg is_top_hvg_sce_layer #&gt; colnames(76): 151507_Layer1 151507_Layer2 ... 151676_Layer6 151676_WM #&gt; colData names(13): sample_name layer_guess ... layer_guess_reordered_short spatialLIBD #&gt; reducedDimNames(6): PCA TSNE_perplexity5 ... UMAP_neighbors15 PCAsub #&gt; mainExpName: NULL #&gt; altExpNames(0): ## We can check how big the object is with lobstr lobstr::obj_size(sce_layer) #&gt; 33.99 MB Just like with our rse object, we can use iSEE::iSEE() to explore the data. iSEE::iSEE(sce_layer) p.exercise { background-color: #E4EDE2; padding: 9px; border: 1px solid black; border-radius: 10px; font-family: sans-serif; } Exercise 1: Create a plot and download a PDF that reproduces as closely as possible the plot on the right side of the following slide. Exercise 2: Explore with a heatmap the expression of the genes MOBP, MBP, and PCP4. If we use clustering (group genes based on similar expression patterns), which two genes are most similar to each other? Exercise 3: In which dorsolateral prefrontal cortex (DLPFC) layers (L1, L2, …, L6 grey matter layers, and WM for white matter) do we see the highest expression for the genes MOBP and MBP? This list of ENSEMBL IDs will be useful: ENSG00000168314 ENSG00000183036 ENSG00000197971 5.4 Community iSEE authors: Kévin Rue-Albrecht https://twitter.com/KevinRUE67 Federico Marini https://twitter.com/FedeBioinfo Charlotte Soneson https://twitter.com/CSoneson Aaron Lun https://twitter.com/realAaronLun Another example exploring data with SummarizedExperiment and iSEE: Today we explored RNA-seq data from @StefanoBerto83 et al who made it easy to re-use. Thank you! ^^@lcolladotor used #shiny + #ggpubr as well as #iSEE📔 https://t.co/iUQHE0xqRc🗞️ https://t.co/qhAdXbhY9c#rstats @Bioconductorhttps://t.co/OXTukByhoo — LIBD rstats club (@LIBDrstats) February 12, 2021 Are you making a heatmap to 👀 gene expression? Have you wondered whether to center &amp;scale the data?I made this 5 min video to help answer these ❓Shoutout to #iSEE by @KevinRUE67 @FedeBioinfo @CSoneson et al #rstats @Bioconductor@LieberInstitute https://t.co/KwQHLODTQV — 🇲🇽 Leonardo Collado-Torres (@lcolladotor) December 1, 2022 "],["rse-plotting-basics-with-smokingmouse.html", "6 RSE plotting basics with smokingMouse 6.1 Download the smokingMouse data 6.2 Data preparation 6.3 Exploratory Data Analysis 6.4 Quality Control Analysis 6.5 Miscellaneous about CPM values References", " 6 RSE plotting basics with smokingMouse Instructor: Daianna 6.1 Download the smokingMouse data We’ve used these commands already in an earlier chapter. Here we’ll re-download the data, though technically we are using the cached data we had previously downloaded so this time the code below will run faster. ## Load the container package for this type of data library(&quot;SummarizedExperiment&quot;) ## Download data library(&quot;BiocFileCache&quot;) bfc &lt;- BiocFileCache::BiocFileCache() cached_rse_gene &lt;- BiocFileCache::bfcrpath( x = bfc, &quot;https://github.com/LieberInstitute/SPEAQeasyWorkshop2023/raw/devel/provisional_data/rse_gene_mouse_RNAseq_nic-smo.Rdata&quot; ) ## Check the local path on our cache cached_rse_gene #&gt; BFC2 #&gt; &quot;/github/home/.cache/R/BiocFileCache/107d14e54709_rse_gene_mouse_RNAseq_nic-smo.Rdata&quot; ## Load the rse_gene object load(cached_rse_gene, verbose = TRUE) #&gt; Loading objects: #&gt; rse_gene ## Nicotine data rse_gene_nic &lt;- rse_gene[, which(rse_gene$Expt == &quot;Nicotine&quot;)] In this part of the course you’ll have a plotting session in which you’ll learn what type of plots you can create to explore your data, but please note that this is not a differential expression analysis itself. The steps that will be performed are shown in Figure 1. The main objective of this first part is to explore the quality of the samples, their differences in gene expression variations and the impact of sample variables on gene expression variance. You’ll also learn how to visualize gene expression counts. Figure 1: Summary of the analyses for differential expression. Steps in yellow will be properly performed. 1. Data Preparation: in this initial part counts are normalized and scaled and low-expressed genes are filtered. 2. Exploratory Data Analysis: the quality of the samples is compared, poor-quality samples are removed and both gene-level and sample-level effects are explored. 3. Differential Expression Analysis: a linear model is fitted for each gene and log fold changes are obtained for the contrast of interest; other statistics are also computed and compared. Here the differentially expressed genes (DEGs) are determined and quantified. 4. GO &amp; KEGG Analyses: in this part Gene Ontology and KEGG enrichment analyses are performed to identify biological processes and functions in which DEGs are significantly involved. 5. DEG visualization: heatmaps are created to visually contrast gene expression levels of DEGs in control and experimental samples. Abbreviations: CPM: counts per million; QC: quality control; PC: principal component; DEG: differentially expressed genes; GO: Gene Ontology; KEGG: Kyoto Encyclopedia of Genes and Genomes. 6.2 Data preparation Even before exploring the samples, we must normalize the counts and filter non-expressed genes; we won’t do the processes themselves since we already have normalized and filtered data but let’s check why these steps are important and where to extract the data we need for posterior analyses. 6.2.1 Data normalization Data normalization is a relevant preliminary step when working with expression data because raw counts do not necessarily reflect real expression measures of the genes, since there are technical differences in the way the libraries are prepared and sequenced, as well as intrinsic differences in the genes that are translated into more or less mapped reads. Particularly, there are within-sample effects that are the differences between genes in the same sample, such as their length (the longer the gene, the more reads it will have) and GC content, factors that contribute to variations in their counts. On the other hand, between-sample effects are differences between samples such as the sequencing depth, i.e., the total number of molecules sequenced, and the library size, i.e., the total number of reads of each sample [1]. These variables lead to virtually different mRNA amounts but of course are not due to the biological or treatment conditions of interest (such as nicotine administration in this example) so in order to remove, or at least, to minimize this technical bias and obtain measures comparable and consistent across samples, raw counts must be normalized by these factors. The data that we’ll use in this case are already normalized in assays(rse_gene)$logcounts. Specifically, the assay contains counts per million (CPM), also known as reads per million (RPM), one basic gene expression unit that only normalizes by the sequencing depth and is computed by dividing the read counts of a gene in a sample by a scaling factor given by the total mapping reads of the sample per million [2]: \\[CPM = \\frac{read \\ \\ counts \\ \\ of \\ \\ gene \\ \\ \\times \\ \\ 10^6 }{Total \\ \\ mapping \\ \\ reads \\ \\ of \\ \\ sample}\\] As outlined in Data overview and download, the scaling factors were obtained with calcNormFactors() applying the Trimmed Mean of M-Values (TMM) method, the edgeR package’s default normalization method that assumes that most genes are not differentially expressed. The effective library sizes of the samples and the CPM of each observation were computed with the edgeR function cpm() setting the log argument to TRUE and prior.count to 0.5 to receive values in \\(log_2(CPM+0.5)\\). After data normalization and scaling, we’d expect the read counts to follow a normal distribution, something we can confirm by comparing the counts’ distribution before and after the normalization. Consider both datasets contain the exact same genes. library(&quot;ggplot2&quot;) ## Histogram and density plot of read counts before and after normalization ## Raw counts counts_data &lt;- data.frame(counts = as.vector(assays(rse_gene_nic)$counts)) plot &lt;- ggplot(counts_data, aes(x = counts)) + geom_histogram(colour = &quot;black&quot;, fill = &quot;lightgray&quot;) + labs(x = &quot;read counts&quot;, y = &quot;Frecuency&quot;) + theme_classic() plot + theme(plot.margin = unit(c(2, 4, 2, 4), &quot;cm&quot;)) ## Normalized counts logcounts_data &lt;- data.frame(logcounts = as.vector(assays(rse_gene_nic)$logcounts)) plot &lt;- ggplot(logcounts_data, aes(x = logcounts)) + geom_histogram(aes(y = ..density..), colour = &quot;darkgray&quot;, fill = &quot;lightgray&quot;) + theme_classic() + geom_density(fill = &quot;#69b3a2&quot;, alpha = 0.3) + labs(x = &quot;log(CPM+0.5)&quot;, y = &quot;Frecuency&quot;) plot + theme(plot.margin = unit(c(2, 4, 2, 4), &quot;cm&quot;)) As presented, after data transformation, we can now see a more widespread distribution of the counts, but note that most of them are zeros in the first plot (the one with the raw counts) and those zeros remain after normalization, corresponding to counts below 0 in the second plot. That is because we haven’t filtered the low and zero-expressed genes. 6.2.2 Gene filtering Lowly-expressed or non-expressed genes in many samples are not of biological interest in a study of differential expression because they don’t inform about the gene expression changes and they are, by definition, not differentially expressed, so we have to drop them using filterByExpr() from edgeR that only keeps genes with at least K CPM in n samples and with a minimum total number of counts across all samples. ## Retain genes that passed filtering step rse_gene_filt &lt;- rse_gene_nic[rowData(rse_gene_nic)$retained_after_feature_filtering == TRUE, ] ## Normalized counts and filtered genes filt_logcounts_data &lt;- data.frame(logcounts = as.vector(assays(rse_gene_filt)$logcounts)) ## Plot plot &lt;- ggplot(filt_logcounts_data, aes(x = logcounts)) + geom_histogram(aes(y = ..density..), colour = &quot;darkgray&quot;, fill = &quot;lightgray&quot;) + theme_classic() + geom_density(fill = &quot;#69b3a2&quot;, alpha = 0.3) + labs(x = &quot;log(CPM+0.5)&quot;, y = &quot;Frecuency&quot;) plot + theme(plot.margin = unit(c(2, 4, 2, 4), &quot;cm&quot;)) In this third plot we can observe a curve that is closer (though not completely) to a normal distribution and with less lowly-expressed genes. With the object rse_gene_filt we can proceed with downstream analyses. 6.3 Exploratory Data Analysis The first formal step that we will be performing is the sample exploration. This crucial initial part of the analysis consists of an examination of differences and relationships between Quality-Control (QC) metrics of the samples from different groups in order to identify poor-quality samples that must be removed before DEA. After that, the sample variables in the metadata also need to be analyzed and filtered based on the percentage of gene expression variance that they explain for each gene. 6.4 Quality Control Analysis First we have to explore and compare the the quality-control metrics of the samples in the different groups given by covariates such as age, sex, pregnancy state, group, plate and flowcell. See Sample Information section in chapter 04 for a description of these variables. p.comment { background-color: #E6E6E6; padding: 10px; border: 1px solid black; margin-left: 25px; border-radius: 5px; font-family: sans-serif; } ❓ Why is that relevant? As you could imagine, technical and methodological differences in all the steps that were carried out during the experimental stages are potential sources of variation in the quality of the samples. Just imagine all that could have been gone wrong or unexpected while experimenting with mice, during the sampling, in the RNA extraction using different batches, when treating samples in different mediums, when preparing libraries in different plates and sequencing in different flowcells. Moreover, the inherent features of the mice from which the samples come from such as age, tissue, sex and pregnancy state could also affect the samples’ metrics if, for example, they were separately analyzed and processed. ❓But why do we care about mitochodrial and ribosomal counts as QC metrics? In the process of mRNA extraction, either by mRNA enrichment (capturing polyadenilated mRNAs) or rRNA-depletion (removing rRNA), we’d expect to have a low number of ribosomal counts, i.e., counts that map to rDNA, and if we don’t, something must have gone wrong with the procedures. In the case of mitochondrial counts something similar occurs: higher mitochondrial rates will be obtained if the cytoplasmic mRNA capture was deficient or if the transcripts were lost by some technical issue, increasing the proportion of mitochondrial mRNAs. As a result, high mitoRate and rRNA_rate imply poor quality in the samples. Note: the QC metrics were computed with the unprocessed datasets (neither filtered nor normalized) to preserve the original estimates of the samples. 6.4.1 Evaluate QC metrics for groups of samples Fortunately, we can identify to some extent possible factors that could have influenced on the quality of the samples, as well as isolated samples that are problematic. To do that, we will create boxplots that present the distribution of the samples’ metrics separating them by sample variables. library(&quot;Hmisc&quot;) library(&quot;stringr&quot;) library(&quot;cowplot&quot;) ## Define QC metrics of interest qc_metrics &lt;- c(&quot;mitoRate&quot;, &quot;overallMapRate&quot;, &quot;totalAssignedGene&quot;, &quot;rRNA_rate&quot;, &quot;sum&quot;, &quot;detected&quot;, &quot;ERCCsumLogErr&quot;) ## Define sample variables of interest sample_variables &lt;- c(&quot;Group&quot;, &quot;Age&quot;, &quot;Sex&quot;, &quot;Pregnancy&quot;, &quot;plate&quot;, &quot;flowcell&quot;) ## Function to create boxplots of QC metrics for groups of samples QC_boxplots &lt;- function(qc_metric, sample_var) { ## Define sample colors depending on the sample variable if (sample_var == &quot;Group&quot;) { colors &lt;- c(&quot;Control&quot; = &quot;brown2&quot;, &quot;Experimental&quot; = &quot;deepskyblue3&quot;) } else if (sample_var == &quot;Age&quot;) { colors &lt;- c(&quot;Adult&quot; = &quot;slateblue3&quot;, &quot;Pup&quot; = &quot;yellow3&quot;) } else if (sample_var == &quot;Sex&quot;) { colors &lt;- c(&quot;F&quot; = &quot;hotpink1&quot;, &quot;M&quot; = &quot;dodgerblue&quot;) } else if (sample_var == &quot;Pregnancy&quot;) { colors &lt;- c(&quot;Yes&quot; = &quot;darkorchid3&quot;, &quot;No&quot; = &quot;darkolivegreen4&quot;) } else if (sample_var == &quot;plate&quot;) { colors &lt;- c(&quot;Plate1&quot; = &quot;darkorange&quot;, &quot;Plate2&quot; = &quot;lightskyblue&quot;, &quot;Plate3&quot; = &quot;deeppink1&quot;) } else if (sample_var == &quot;flowcell&quot;) { colors &lt;- c( &quot;HKCG7DSXX&quot; = &quot;chartreuse2&quot;, &quot;HKCMHDSXX&quot; = &quot;magenta&quot;, &quot;HKCNKDSXX&quot; = &quot;turquoise3&quot;, &quot;HKCTMDSXX&quot; = &quot;tomato&quot; ) } ## Axis labels x_label &lt;- capitalize(sample_var) y_label &lt;- str_replace_all(qc_metric, c(&quot;_&quot; = &quot;&quot;)) ## x-axis text angle and position if (sample_var == &quot;flowcell&quot;) { x_axis_angle &lt;- 18 x_axis_hjust &lt;- 0.5 x_axis_vjust &lt;- 0.7 x_axis_size &lt;- 4 } else { x_axis_angle &lt;- 0 x_axis_hjust &lt;- 0.5 x_axis_vjust &lt;- 0.5 x_axis_size &lt;- 6 } ## Extract sample data in colData(rse_gene_filt) data &lt;- data.frame(colData(rse_gene_filt)) ## Sample variable separating samples in x-axis and QC metric in y-axis ## (Coloring by sample variable) plot &lt;- ggplot(data = data, mapping = aes(x = !!rlang::sym(sample_var), y = !!rlang::sym(qc_metric), color = !!rlang::sym(sample_var))) + ## Add violin plots geom_violin(alpha = 0, size = 0.4, color = &quot;black&quot;, width = 0.7) + ## Spread dots geom_jitter(width = 0.08, alpha = 0.7, size = 1.3) + ## Add boxplots geom_boxplot(alpha = 0, size = 0.4, width = 0.1, color = &quot;black&quot;) + ## Set colors scale_color_manual(values = colors) + ## Define axis labels labs(y = y_label, x = x_label) + ## Get rid of the background theme_bw() + ## Hide legend and define plot margins and size of axis title and text theme( legend.position = &quot;none&quot;, plot.margin = unit(c(0.5, 0.4, 0.5, 0.4), &quot;cm&quot;), axis.title = element_text(size = 7), axis.text = element_text(size = x_axis_size), axis.text.x = element_text(angle = x_axis_angle, hjust = x_axis_hjust, vjust = x_axis_vjust) ) return(plot) } ## Plots of all QC metrics for each sample variable multiple_QC_boxplots &lt;- function(sample_var) { i &lt;- 1 plots &lt;- list() for (qc_metric in qc_metrics) { ## Call function to create each individual plot plots[[i]] &lt;- QC_boxplots(qc_metric, sample_var) i &lt;- i + 1 } ## Arrange multiple plots into a grid print(plot_grid(plots[[1]], plots[[2]], plots[[3]], plots[[4]], plots[[5]], plots[[6]], plots[[7]], nrow = 2)) } multiple_QC_boxplots(&quot;Age&quot;) Initially, when we separate samples by Age, we can appreciate a clear segregation of adult and pup samples in mitoRate , with higher mitochondrial rates for adult samples and thus, being lower quality samples than the pup ones. We can also see that pup samples have higher totalAssignedGene , again being higher quality. The samples are very similar in the rest of the QC metrics. The former differences must be taken into account because they guide further sample separation by Age, which is necessary to avoid dropping most of the adult samples (that are lower quality) in the QC-based sample filtering (see below) and to prevent misinterpreting sample variation given by quality and not by mouse age itself. multiple_QC_boxplots(&quot;Sex&quot;) With Sex, female and male samples have similar QC metrics but there are some female samples that have high mitoRate and low totalAssignedGene , but males don´t. That is consistent with the fact that all males are pups and as we previously observed, pup samples present better QC metrics, but since not all pups are males, some female pups also have smaller mitoRate and greater totalAssignedGene . So in this case samples’ differences are actually dictated by Age and not by Sex. multiple_QC_boxplots(&quot;Group&quot;) Notably, for Group no evident contrasts are seen in the quality of the samples, which means that both control and exposed samples have similar metrics and therefore the differences between them won’t be determined by technical factors but effectively by gene expression changes. multiple_QC_boxplots(&quot;Pregnancy&quot;) Pregnancy variable is interesting because pregnant dams were obviously females and adults, which we already noted are lower quality. Accordingly to that, pregnant samples present overall higher mitoRate and lower totalAssignedGene , sum (library size) and detected (number of expressed genes) than some samples coming from non-pregnant mice. However, these samples have smaller | ERCCsumLogErr |, which means that they had smaller differences between expected and observed concentrations of control transcripts. Notwithstanding, we must clarify one more time that as in Sex, the trends observed in Pregnancy are all given by Age: it is Age the variable that fully segregates samples in mitoRate and almost completely in , lower totalAssignedGene . Because all pregnant dams were adults, their metrics will be positioned where the adult samples were, but there were also not-pregnant adults that share similar QC values. multiple_QC_boxplots(&quot;plate&quot;) In plate, no alarming differences are presented but some samples from the 1st plate have low (though not much lower) overallMapRate , totalAssignedGene and sum . multiple_QC_boxplots(&quot;flowcell&quot;) For the flowcell, again no worrying distinctions are seen, with the exception of a few individual samples far from the rest. In all the previous plots we can appreciate a group of samples placed below in mitoRate that correspond to pup samples. The relationship is more fuzzy in totalAssignedGene . 6.4.2 Examine relationships between QC metrics of samples Secondly, we want to analyze if there are relationships between QC variables that explain the presence of samples with two or more particular QC metrics. For that, scatterplots are useful because they enable the evaluation of pairs of samples’ QC metrics. ## Scatterplots for a pair of QC metrics QC_scatterplots &lt;- function(sample_var, qc_metric1, qc_metric2) { ## Define sample colors if (sample_var == &quot;Group&quot;) { colors &lt;- c(&quot;Control&quot; = &quot;brown2&quot;, &quot;Experimental&quot; = &quot;deepskyblue3&quot;) } else if (sample_var == &quot;Age&quot;) { colors &lt;- c(&quot;Adult&quot; = &quot;slateblue3&quot;, &quot;Pup&quot; = &quot;yellow3&quot;) } else if (sample_var == &quot;Sex&quot;) { colors &lt;- c(&quot;F&quot; = &quot;hotpink1&quot;, &quot;M&quot; = &quot;dodgerblue&quot;) } else if (sample_var == &quot;Pregnancy&quot;) { colors &lt;- c(&quot;Yes&quot; = &quot;darkorchid3&quot;, &quot;No&quot; = &quot;darkolivegreen4&quot;) } else if (sample_var == &quot;plate&quot;) { colors &lt;- c(&quot;Plate1&quot; = &quot;darkorange&quot;, &quot;Plate2&quot; = &quot;lightskyblue&quot;, &quot;Plate3&quot; = &quot;deeppink1&quot;) } else if (sample_var == &quot;flowcell&quot;) { colors &lt;- c( &quot;HKCG7DSXX&quot; = &quot;chartreuse2&quot;, &quot;HKCMHDSXX&quot; = &quot;magenta&quot;, &quot;HKCNKDSXX&quot; = &quot;turquoise3&quot;, &quot;HKCTMDSXX&quot; = &quot;tomato&quot; ) } data &lt;- colData(rse_gene_filt) ## Scatterplots for continuous variable vs continuous variable ## First QC metric in x-axis and second QC metric in y-axis plot &lt;- ggplot(as.data.frame(data), aes( x = !!rlang::sym(qc_metric1), y = !!rlang::sym(qc_metric2), ## Color samples by a variable color = !!rlang::sym(sample_var) )) + ## Add scatterplot geom_point(size = 1) + ## Add regression line stat_smooth(geom = &quot;line&quot;, alpha = 0.4, size = 0.4, span = 0.25, method = lm, color = &quot;orangered3&quot;) + ## Colors scale_color_manual(name = sample_var, values = colors) + theme_bw() + ## Add Pearson correlation coefficient between the metrics as subtitle labs( subtitle = paste0(&quot;Corr: &quot;, signif(cor(data[, qc_metric1], data[, qc_metric2], method = &quot;pearson&quot;), digits = 3)), ## Add axis labels y = gsub(&quot;_&quot;, &quot; &quot;, qc_metric2), x = gsub(&quot;_&quot;, &quot; &quot;, qc_metric1) ) + ## Plot margins and text size theme( plot.margin = unit(c(0.1, 1.2, 0.1, 1.2), &quot;cm&quot;), axis.title = element_text(size = (7)), axis.text = element_text(size = (6)), plot.subtitle = element_text(size = 7, color = &quot;gray40&quot;), legend.text = element_text(size = 6), legend.title = element_text(size = 7) ) return(plot) } ## QC scatterplots coloring by all sample variables multiple_QC_scatterplots &lt;- function(qc_metric1, qc_metric2) { sample_variables &lt;- c(&quot;Age&quot;, &quot;Sex&quot;, &quot;plate&quot;, &quot;Pregnancy&quot;, &quot;Group&quot;, &quot;flowcell&quot;) i &lt;- 1 plots &lt;- list() for (sample_var in sample_variables) { plots[[i]] &lt;- QC_scatterplots(sample_var, qc_metric1, qc_metric2) i &lt;- i + 1 } plot_grid(plots[[1]], plots[[2]], plots[[3]], plots[[4]], plots[[5]], plots[[6]], nrow = 3, rel_widths = c(1, 1)) } multiple_QC_scatterplots(&quot;mitoRate&quot;, &quot;rRNA_rate&quot;) For mitoRate vs rRNA_rate plots there’s a negligible positive correlation which was anticipated since no obvious relationship exists between them, though if cytoplasmic mRNAs weren’t well captured (lowering the total number of mapping reads) we could expect an increase in both mitochondrial and ribosomal rates. Note the complete separation of samples in mitoRate (but not in rRNA_rate ) by Age, which in turn causes the grouping of male samples (all pups). multiple_QC_scatterplots(&quot;mitoRate&quot;, &quot;totalAssignedGene&quot;) Forcefully, mitoRate and totalAssignedGene have a strong negative correlation, which reveals the existence of very bad quality samples (with small totalAssignedGene and high mitoRate ). multiple_QC_scatterplots(&quot;sum&quot;, &quot;detected&quot;) Noticeably, a positive correlation is present for sum and detected and that is also congruent because a higher number of expressed-genes implies bigger library sizes, but that is not necessarily true in the other way around: just a few highly expressed genes (small number of detected genes) could increase the library size. Interestingly, in this case samples are diagonally separated by age. multiple_QC_scatterplots(&quot;sum&quot;, &quot;totalAssignedGene&quot;) Contrary to expectations, sum is not correlated to totalAssignedGene and this is unexpected because higher proportions of genes’ reads could initially increase library size. However, since totalAssignedGene is a fraction of the total reads, it could be that a high fraction of reads mapping to genes reflects a small number of total reads and does not necessarily imply more expressed genes (and therefore bigger libraries). In other words, even when totalAssignedGene equals 1, if the total number of reads is small, the genes won’t be widely covered by them and the libraries won’t be sizeable. Observe the separarion of samples by Age. multiple_QC_scatterplots(&quot;detected&quot;, &quot;totalAssignedGene&quot;) Lastly, there’s a slight positive correlation between totalAssignedGene and detected , which makes sense because reads assigned to genes rise the number of non-zero expressed genes but as mentioned, those genes are not necessarily highly expressed and thus, library sizes are not perforce so much bigger. Also note that the correlation wouldn’t be conserved within pup samples. p.exercise { background-color: #E4EDE2; padding: 10px; border: 1px solid black; border-radius: 10px; font-family: sans-serif; } 📑 Exercise 1: What’s the correlation between subsets_Mito_sum and mitoMapped ? What factor could explain that correlation? Why are mitoMapped numbers bigger than subsets_Mito_sum values? Remarkably, samples were not differentiated by any other variable (including Group!) but the differences between adult and pup metrics suggest that they must be splitted into two different groups for the following analyses. 6.4.3 QC sample filtering After assessing how different or similar are the QC values between samples, we can now proceed to sample filtering based precisely, on these metrics. For that, we will use isOutlier() from scater to identify outlier samples only at the lower end or the higher end, depending on the QC metric. library(&quot;scater&quot;) library(&quot;rlang&quot;) library(&quot;ggrepel&quot;) ## Separate data by Age rse_gene_pups &lt;- rse_gene_filt[, which(rse_gene_filt$Age == &quot;Pup&quot;)] rse_gene_adults &lt;- rse_gene_filt[, which(rse_gene_filt$Age == &quot;Adult&quot;)] ## Find outlier samples based on their QC metrics (samples that are 3 median-absolute-deviations away from the median) ## Filter all samples together ## Drop samples with lower library sizes (sum), detected number of genes and totalAssignedGene outliers_library_size &lt;- isOutlier(rse_gene_filt$sum, nmads = 3, type = &quot;lower&quot;) outliers_detected_num &lt;- isOutlier(rse_gene_filt$detected, nmads = 3, type = &quot;lower&quot;) outliers_totalAssignedGene &lt;- isOutlier(rse_gene_filt$totalAssignedGene, nmads = 3, type = &quot;lower&quot;) ## Drop samples with higher mitoRates and rRNA rates outliers_mito &lt;- isOutlier(rse_gene_filt$mitoRate, nmads = 3, type = &quot;higher&quot;) outliers_rRNArate &lt;- isOutlier(rse_gene_filt$rRNA_rate, nmads = 3, type = &quot;higher&quot;) ## Keep not outlier samples not_outliers &lt;- which(!(outliers_library_size | outliers_detected_num | outliers_totalAssignedGene | outliers_mito | outliers_rRNArate)) rse_gene_qc &lt;- rse_gene_filt[, not_outliers] ## Number of samples retained dim(rse_gene_qc)[2] #&gt; [1] 39 ## Add new variables to rse_gene_filt with info of samples retained/dropped rse_gene_filt$Retention_after_QC_filtering &lt;- as.vector(sapply(rse_gene_filt$SAMPLE_ID, function(x) { if (x %in% rse_gene_qc$SAMPLE_ID) { &quot;Retained&quot; } else { &quot;Dropped&quot; } })) ## Filter adult samples outliers_library_size &lt;- isOutlier(rse_gene_adults$sum, nmads = 3, type = &quot;lower&quot;) outliers_detected_num &lt;- isOutlier(rse_gene_adults$detected, nmads = 3, type = &quot;lower&quot;) outliers_totalAssignedGene &lt;- isOutlier(rse_gene_adults$totalAssignedGene, nmads = 3, type = &quot;lower&quot;) outliers_mito &lt;- isOutlier(rse_gene_adults$mitoRate, nmads = 3, type = &quot;higher&quot;) outliers_rRNArate &lt;- isOutlier(rse_gene_adults$rRNA_rate, nmads = 3, type = &quot;higher&quot;) not_outliers &lt;- which(!(outliers_library_size | outliers_detected_num | outliers_totalAssignedGene | outliers_mito | outliers_rRNArate)) rse_gene_adults_qc &lt;- rse_gene_adults[, not_outliers] ## Number of samples retained dim(rse_gene_adults_qc)[2] #&gt; [1] 20 rse_gene_adults$Retention_after_QC_filtering &lt;- as.vector(sapply(rse_gene_adults$SAMPLE_ID, function(x) { if (x %in% rse_gene_adults_qc$SAMPLE_ID) { &quot;Retained&quot; } else { &quot;Dropped&quot; } })) ## Filter pup samples outliers_library_size &lt;- isOutlier(rse_gene_pups$sum, nmads = 3, type = &quot;lower&quot;) outliers_detected_num &lt;- isOutlier(rse_gene_pups$detected, nmads = 3, type = &quot;lower&quot;) outliers_totalAssignedGene &lt;- isOutlier(rse_gene_pups$totalAssignedGene, nmads = 3, type = &quot;lower&quot;) outliers_mito &lt;- isOutlier(rse_gene_pups$mitoRate, nmads = 3, type = &quot;higher&quot;) outliers_rRNArate &lt;- isOutlier(rse_gene_pups$rRNA_rate, nmads = 3, type = &quot;higher&quot;) not_outliers &lt;- which(!(outliers_library_size | outliers_detected_num | outliers_totalAssignedGene | outliers_mito | outliers_rRNArate)) rse_gene_pups_qc &lt;- rse_gene_pups[, not_outliers] ## Number of samples retained dim(rse_gene_pups_qc)[2] #&gt; [1] 41 rse_gene_pups$Retention_after_QC_filtering &lt;- as.vector(sapply(rse_gene_pups$SAMPLE_ID, function(x) { if (x %in% rse_gene_pups_qc$SAMPLE_ID) { &quot;Retained&quot; } else { &quot;Dropped&quot; } })) We already filtered outlier samples … but what have we removed? It is always important to trace the QC metrics of the filtered samples to verify that they really are poor quality. We don’t want to get rid of useful samples! So let’s go back to the QC boxplots but now color samples according to whether they passed or not the filtering step and also distinguishing samples’ groups by shape. ## Boxplots of QC metrics after sample filtering ## Boxplots boxplots_after_QC_filtering &lt;- function(rse_gene, qc_metric, sample_var) { ## Color samples colors &lt;- c(&quot;Retained&quot; = &quot;deepskyblue&quot;, &quot;Dropped&quot; = &quot;brown2&quot;) ## Sample shape by sample variables if (sample_var == &quot;Group&quot;) { shapes &lt;- c(&quot;Control&quot; = 0, &quot;Experimental&quot; = 15) } else if (sample_var == &quot;Age&quot;) { shapes &lt;- c(&quot;Adult&quot; = 16, &quot;Pup&quot; = 1) } else if (sample_var == &quot;Sex&quot;) { shapes &lt;- c(&quot;F&quot; = 11, &quot;M&quot; = 19) } else if (sample_var == &quot;Pregnancy&quot;) { shapes &lt;- c(&quot;Yes&quot; = 10, &quot;No&quot; = 1) } else if (sample_var == &quot;plate&quot;) { shapes &lt;- c(&quot;Plate1&quot; = 12, &quot;Plate2&quot; = 5, &quot;Plate3&quot; = 4) } else if (sample_var == &quot;flowcell&quot;) { shapes &lt;- c( &quot;HKCG7DSXX&quot; = 3, &quot;HKCMHDSXX&quot; = 8, &quot;HKCNKDSXX&quot; = 14, &quot;HKCTMDSXX&quot; = 17 ) } y_label &lt;- str_replace_all(qc_metric, c(&quot;_&quot; = &quot; &quot;)) data &lt;- data.frame(colData(rse_gene)) ## Median of the QC var values median &lt;- median(eval(parse_expr(paste(&quot;rse_gene$&quot;, qc_metric, sep = &quot;&quot;)))) ## Median-absolute-deviation of the QC var values mad &lt;- mad(eval(parse_expr(paste(&quot;rse_gene$&quot;, qc_metric, sep = &quot;&quot;)))) plot &lt;- ggplot(data = data, mapping = aes( x = &quot;&quot;, y = !!rlang::sym(qc_metric), color = !!rlang::sym(&quot;Retention_after_QC_filtering&quot;) )) + geom_jitter(alpha = 1, size = 2, aes(shape = eval(parse_expr((sample_var))))) + geom_boxplot(alpha = 0, size = 0.15, color = &quot;black&quot;) + scale_color_manual(values = colors) + scale_shape_manual(values = shapes) + labs(x = &quot;&quot;, y = y_label, color = &quot;Retention after QC filtering&quot;, shape = sample_var) + theme_classic() + ## Median line geom_hline(yintercept = median, size = 0.5) + ## Line of median + 3 MADs geom_hline(yintercept = median + (3 * mad), size = 0.5, linetype = 2) + ## Line of median - 3 MADs geom_hline(yintercept = median - (3 * mad), size = 0.5, linetype = 2) + theme( axis.title = element_text(size = (9)), axis.text = element_text(size = (8)), legend.position = &quot;right&quot;, legend.text = element_text(size = 8), legend.title = element_text(size = 9) ) return(plot) } In the following plot we can confirm that taking all samples together (both adults and pups) all adult samples are dropped by their high mitoRate , but that is not desirable because we want to analyze these samples too, so we need to analyze pup and adult samples separately. ## Plots ## All samples together p &lt;- boxplots_after_QC_filtering(rse_gene_filt, &quot;mitoRate&quot;, &quot;Age&quot;) p + theme(plot.margin = unit(c(2, 4, 2, 4), &quot;cm&quot;)) For adults, only 3 controls are dropped, 3 of them by their mitoRate . ## Adult samples p &lt;- boxplots_after_QC_filtering(rse_gene_adults, &quot;mitoRate&quot;, &quot;Group&quot;) p + theme(plot.margin = unit(c(2, 4, 2, 4), &quot;cm&quot;)) For pups, 1 experimental sample was dropped by its rRNA_rate . ## Pup samples p &lt;- boxplots_after_QC_filtering(rse_gene_pups, &quot;rRNA_rate&quot;, &quot;Group&quot;) p + theme(plot.margin = unit(c(2, 4, 2, 4), &quot;cm&quot;)) 📑 Exercise 2: Were the filtered adult samples from pregnant or not pregnant mice? From which plates and flowcells? What were their library sizes? Try the function yourself with different QC metrics and sample variables! 6.5 Miscellaneous about CPM values ## Why do we see log(CPM + 0.5) values smaller than -1? log2(0.5) #&gt; [1] -1 ## Maybe the prior count is getting shrunk log2(0.05) #&gt; [1] -4.321928 ## logcounts values we see across all samples summary(as.vector(assays(rse_gene)$logcounts)) #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; -5.9853 -5.9853 -5.9853 -2.7514 0.4171 18.2732 ## Sample 203 in particular has some cases like it summary(assays(rse_gene)$logcounts[, 203]) #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; -5.9853 -5.9853 -5.9853 -2.6620 0.6067 12.5785 ## Where we find one gene in sample 203 with that property i_gene &lt;- which.min(assays(rse_gene)$logcounts[, 203]) ## We can check the logcounts and counts assays(rse_gene)$logcounts[i_gene, 203] #&gt; ENSMUSG00000102693.1 #&gt; -5.985331 assays(rse_gene)$counts[i_gene, 203] #&gt; ENSMUSG00000102693.1 #&gt; 0 ## What if we try to reverse engineer the number? 2^assays(rse_gene)$logcounts[i_gene, 203] #&gt; ENSMUSG00000102693.1 #&gt; 0.01578469 log2(0.01578469) #&gt; [1] -5.98533 0.01578469 / 0.5 #&gt; [1] 0.03156938 0.5 * 0.03156938 #&gt; [1] 0.01578469 ## Hm... 31 doesn&#39;t ring any bells 1 / 0.03156938 #&gt; [1] 31.67626 Bioconductor website for browsing code: https://code.bioconductor.org/ Bioconductor support website: https://support.bioconductor.org/ Links Leo showed: smokingMouse_indirects code for computing the logcounts https://github.com/LieberInstitute/smokingMouse_Indirects/blob/704692a357ec391348ebc3568188d41827328ba5/code/02_build_objects/02_build_objects.R#L100 https://code.bioconductor.org/browse/edgeR/blob/devel/R/cpm.R#L9 https://code.bioconductor.org/browse/edgeR/blob/devel/R/cpm.R#L14 https://code.bioconductor.org/browse/edgeR/blob/devel/R/cpm.R#L78 https://code.bioconductor.org/browse/edgeR/blob/devel/src/R_calculate_cpm.cpp#L30 https://code.bioconductor.org/browse/edgeR/blob/devel/src/add_prior.cpp#L29 https://support.bioconductor.org/post/search/?query=prior.count+edgeR https://support.bioconductor.org/p/59846/ https://support.bioconductor.org/p/59846/ ## Check the documentation ## ?edgeR::cpm ## &gt; If log-values are computed, then a small count, given by prior.count but scaled to be proportional to the library size, is added to y to avoid taking the log of zero. ## https://github.com/LieberInstitute/smokingMouse_Indirects/blob/704692a357ec391348ebc3568188d41827328ba5/code/02_build_objects/02_build_objects.R#L100C51-L100C135 ## Let&#39;s save the output of calcNormFactors DGElist_with_norm &lt;- edgeR::calcNormFactors(rse_gene, method = &quot;TMM&quot;) class(DGElist_with_norm) #&gt; [1] &quot;DGEList&quot; #&gt; attr(,&quot;package&quot;) #&gt; [1] &quot;edgeR&quot; ## https://code.bioconductor.org/browse/edgeR/blob/devel/R/cpm.R#L9 ## We can see that it has the lib.size and norm.factors values there head(DGElist_with_norm$samples[, seq_len(3)]) #&gt; group lib.size norm.factors #&gt; Sample1 1 37119948 0.9601434 #&gt; Sample2 1 24904754 0.9783991 #&gt; Sample3 1 27083602 0.9740923 #&gt; Sample4 1 48312479 0.9408362 #&gt; Sample5 1 34921004 0.9772143 #&gt; Sample6 1 31558549 0.9246274 ## Exploring lib.size across all samples summary(DGElist_with_norm$samples$lib.size) #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 6908739 26209304 29205003 29475155 34809355 114202414 DGElist_with_norm$samples$lib.size[203] #&gt; [1] 34869201 ## https://code.bioconductor.org/browse/edgeR/blob/devel/R/cpm.R#L14 ## We can see there how edgeR::cpm() computes the adjusted library sizes summary(DGElist_with_norm$samples$norm.factors) #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 0.3595 0.9656 1.1230 1.0306 1.1589 1.2336 DGElist_with_norm$samples$norm.factors[203] #&gt; [1] 1.19894 ## adjusted library sizes DGElist_with_norm$samples$lib.size[203] * DGElist_with_norm$samples$norm.factors[203] #&gt; [1] 41806065 ## Let&#39;s save these values for all samples adj_lib_size &lt;- DGElist_with_norm$samples$lib.size * DGElist_with_norm$samples$norm.factors adj_lib_size[203] #&gt; [1] 41806065 ## Proportional adjusted library size to the mean adjusted library size adj_lib_size[203] / mean(adj_lib_size) #&gt; [1] 1.319791 1 / (adj_lib_size[203] / mean(adj_lib_size)) #&gt; [1] 0.7576956 ## Hm.... we are missing something to get to the values we saw earlier when we ## tried to reverse engineer the issue. ## Hm.... I couldn&#39;t recalculate that -5.98 value manually log2(0.5 / (adj_lib_size[203] / mean(adj_lib_size) * 2)) #&gt; [1] -2.40031 In the end, I (Leo) don’t know enough C++ to fully understand the math of what edgeR is doing. But well, the point is that it is scaling that prior.count (0.5 in the smokingMouse case instead of the default value of 2) which results in a smaller number, and hence why the log2() value of it is smaller than -1. References Evans, C., Hardin, J., &amp; Stoebel, D. M. (2018). Selecting between-sample RNA-Seq normalization methods from the perspective of their assumptions. Briefings in bioinformatics, 19(5), 776-792. Bedre, R. (2023). Gene expression units explained: RPM, RPKM, FPKM, TPM, DESeq, TMM, SCnorm, GeTMM, and ComBat-Seq. Web site: https://www.reneshbedre.com/blog/expression_units.html "],["biocthis-introduction.html", "7 biocthis introduction 7.1 Related past materials 7.2 biocthis main commands 7.3 Live demo 7.4 Community", " 7 biocthis introduction Instructor: Leo 7.1 Related past materials I’ve taught a lot about biocthis over the years. Here’s a 2020 video: and more recently, these are the LIBD rstats club 2023-03-10 notes. 1 7.2 biocthis main commands https://bioconductor.org/packages/biocthis pkgdown documentation website: https://lcolladotor.github.io/biocthis/ biocthis::use_bioc_pkg_templates() documentation: https://lcolladotor.github.io/biocthis/reference/use_bioc_pkg_templates.html These are the main steps you will need to know to make a Bioconductor package with biocthis: You first will need to create a package using a command from usethis. For example: usethis::create_package(\"~/Desktop/cshl2023pkg\") Now that you have a package, we can use biocthis to create 4 template R scripts that will guide you and help you make the full structure for a Bioconductor R package. On your new R package (cshl2023pkg), we can now use biocthis::use_bioc_pkg_templates(). In part these commands were born out of my own self interest to make it easier to make new packages instead of copy-pasting the contents of an older one, then manually adjusting all the pieces for a new package. See https://lcolladotor.github.io/pkgs/ for the list of all the R packages I’ve been involved in. 7.3 Live demo Here is the live demo result https://github.com/lcolladotor/cshl2023pkg/ with its companion documentation website at https://lcolladotor.github.io/cshl2023pkg/. Note that you will currently need the development version of biocthis which addresses the issues documented at https://github.com/r-lib/usethis/issues/1856. ## Install biocthis development version BiocManager::install(&quot;lcolladotor/biocthis&quot;) Check the git commit history at https://github.com/lcolladotor/cshl2023pkg/commits/devel and the GitHub Actions history at https://github.com/lcolladotor/cshl2023pkg/actions. We can see at https://app.codecov.io/gh/lcolladotor/cshl2023pkg the code coverage results for this demonstration package. 7.4 Community For more materials on R/Bioconductor package development check http://contributions.bioconductor.org/. I’m on a Friday night mood now enjoying @lmwebr’s #OSTA workshop 🔥, feeling grateful 🙏🏽 to everyone who nominated me for the #BioC2021 community award 🥇&amp; celebrating 🍺 https://t.co/2oFLdGO3UhSee you in #BioC2022🤞🏽 @Bioconductor #rstats @CDSBMexico https://t.co/0SGHDfiRCs pic.twitter.com/UmM9nMP2W2 — 🇲🇽 Leonardo Collado-Torres (@lcolladotor) August 7, 2021 biocthis is one of the reasons for my 2021 Bioconductor community award :-) Do you want to play an active role? Join the cloud-working-group Slack channel. Soon I’ll process and upload the video to YouTube. By soon, I mean, later this summer.↩︎ "],["recount3-introduction.html", "8 recount3 introduction 8.1 recount projects 8.2 Using recount3 8.3 Exercise 8.4 Community", " 8 recount3 introduction Instructor: Leo Don’t let useful data go to waste by Franziska Denk https://doi.org/10.1038/543007a 8.1 recount projects ReCount: data from 20 studies http://bowtie-bio.sourceforge.net/recount/index.shtml Paper from 2011 https://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-12-449 recount: over 70k human bulk RNA-seq samples uniformly processed https://jhubiostatistics.shinyapps.io/recount/ pkgdown documentation website: http://leekgroup.github.io/recount/ Bioconductor documentation website: http://bioconductor.org/packages/recount Main paper (2017) http://www.nature.com/nbt/journal/v35/n4/full/nbt.3838.html Paper that explains why the counts are different from the usual ones https://f1000research.com/articles/6-1558/v1 Example analyses we did and provided as a companion website for the 2017 paper http://leekgroup.github.io/recount-analyses/ recount3: over 700k bulk RNA-seq samples from human and mouse http://rna.recount.bio/ pkgdown documentation website: http://research.libd.org/recount3/ Bioconductor documentation website: http://bioconductor.org/packages/recount3 Pre-print: May 2021 https://doi.org/10.1101/2021.05.21.445138 Paper: November 2021 https://doi.org/10.1186/s13059-021-02533-6 These projects help such that anyone, particularly those without access to a high performance computing (HPC) system (aka a compute cluster), can access these datasets. It’s like democratizing access to the gene expression data ^^. 8.2 Using recount3 Check the original documentation here and here. Let’s first load recount3 which will load all the required dependencies including SummarizedExperiment. ## Load recount3 R package library(&quot;recount3&quot;) Next we need to identify a study of interest as well as choose whether we want the data at the gene, exon, or some other feature level. Once we have identified our study of interest, we can download the files and build a SummarizedExperiment object using recount3::create_rse() as we’ll show next. create_rse() has arguments through which we can control what annotation we want to use (they are organism-dependent). ## Lets download all the available projects human_projects &lt;- available_projects() #&gt; 2024-05-28 02:35:55.179052 caching file sra.recount_project.MD.gz. #&gt; adding rname &#39;http://duffel.rail.bio/recount3/human/data_sources/sra/metadata/sra.recount_project.MD.gz&#39; #&gt; 2024-05-28 02:35:56.166384 caching file gtex.recount_project.MD.gz. #&gt; adding rname &#39;http://duffel.rail.bio/recount3/human/data_sources/gtex/metadata/gtex.recount_project.MD.gz&#39; #&gt; 2024-05-28 02:35:57.095957 caching file tcga.recount_project.MD.gz. #&gt; adding rname &#39;http://duffel.rail.bio/recount3/human/data_sources/tcga/metadata/tcga.recount_project.MD.gz&#39; ## Find your project of interest. Here we&#39;ll use ## SRP009615 as an example proj_info &lt;- subset( human_projects, project == &quot;SRP009615&quot; &amp; project_type == &quot;data_sources&quot; ) ## Build a RangedSummarizedExperiment (RSE) object ## with the information at the gene level rse_gene_SRP009615 &lt;- create_rse(proj_info) #&gt; 2024-05-28 02:35:59.96805 downloading and reading the metadata. #&gt; 2024-05-28 02:36:00.264533 caching file sra.sra.SRP009615.MD.gz. #&gt; adding rname &#39;http://duffel.rail.bio/recount3/human/data_sources/sra/metadata/15/SRP009615/sra.sra.SRP009615.MD.gz&#39; #&gt; 2024-05-28 02:36:01.093514 caching file sra.recount_project.SRP009615.MD.gz. #&gt; adding rname &#39;http://duffel.rail.bio/recount3/human/data_sources/sra/metadata/15/SRP009615/sra.recount_project.SRP009615.MD.gz&#39; #&gt; 2024-05-28 02:36:01.960486 caching file sra.recount_qc.SRP009615.MD.gz. #&gt; adding rname &#39;http://duffel.rail.bio/recount3/human/data_sources/sra/metadata/15/SRP009615/sra.recount_qc.SRP009615.MD.gz&#39; #&gt; 2024-05-28 02:36:02.788055 caching file sra.recount_seq_qc.SRP009615.MD.gz. #&gt; adding rname &#39;http://duffel.rail.bio/recount3/human/data_sources/sra/metadata/15/SRP009615/sra.recount_seq_qc.SRP009615.MD.gz&#39; #&gt; 2024-05-28 02:36:03.620513 caching file sra.recount_pred.SRP009615.MD.gz. #&gt; adding rname &#39;http://duffel.rail.bio/recount3/human/data_sources/sra/metadata/15/SRP009615/sra.recount_pred.SRP009615.MD.gz&#39; #&gt; 2024-05-28 02:36:04.218974 downloading and reading the feature information. #&gt; 2024-05-28 02:36:04.481362 caching file human.gene_sums.G026.gtf.gz. #&gt; adding rname &#39;http://duffel.rail.bio/recount3/human/annotations/gene_sums/human.gene_sums.G026.gtf.gz&#39; #&gt; 2024-05-28 02:36:05.536493 downloading and reading the counts: 12 samples across 63856 features. #&gt; 2024-05-28 02:36:05.793692 caching file sra.gene_sums.SRP009615.G026.gz. #&gt; adding rname &#39;http://duffel.rail.bio/recount3/human/data_sources/sra/gene_sums/15/SRP009615/sra.gene_sums.SRP009615.G026.gz&#39; #&gt; 2024-05-28 02:36:06.655214 constructing the RangedSummarizedExperiment (rse) object. ## Explore the resulting object rse_gene_SRP009615 #&gt; class: RangedSummarizedExperiment #&gt; dim: 63856 12 #&gt; metadata(8): time_created recount3_version ... annotation recount3_url #&gt; assays(1): raw_counts #&gt; rownames(63856): ENSG00000278704.1 ENSG00000277400.1 ... ENSG00000182484.15_PAR_Y ENSG00000227159.8_PAR_Y #&gt; rowData names(10): source type ... havana_gene tag #&gt; colnames(12): SRR387777 SRR387778 ... SRR389077 SRR389078 #&gt; colData names(175): rail_id external_id ... recount_pred.curated.cell_line BigWigURL ## How large is it? lobstr::obj_size(rse_gene_SRP009615) #&gt; 24.81 MB We can also interactively choose our study of interest using the following code or through the recount3 study explorer. ## Explore available human projects interactively proj_info_interactive &lt;- interactiveDisplayBase::display(human_projects) ## Choose only 1 row in the table, then click on &quot;send&quot;. ## Lets double check that you indeed selected only 1 row in the table stopifnot(nrow(proj_info_interactive) == 1) ## Now we can build the RSE object rse_gene_interactive &lt;- create_rse(proj_info_interactive) Now that we have the data, we can use recount3::transform_counts() or recount3::compute_read_counts() to convert the raw counts into a format expected by downstream tools. For more details, check the recountWorkflow paper. ## We&#39;ll compute read counts, which is what most downstream software ## uses. ## For other types of transformations such as RPKM and TPM, use ## transform_counts(). assay(rse_gene_SRP009615, &quot;counts&quot;) &lt;- compute_read_counts(rse_gene_SRP009615) ## Lets make it easier to use the information available for this study ## that was provided by the original authors of the study. rse_gene_SRP009615 &lt;- expand_sra_attributes(rse_gene_SRP009615) colData(rse_gene_SRP009615)[ , grepl(&quot;^sra_attribute&quot;, colnames(colData(rse_gene_SRP009615))) ] #&gt; DataFrame with 12 rows and 4 columns #&gt; sra_attribute.cells sra_attribute.shRNA_expression sra_attribute.source_name sra_attribute.treatment #&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; #&gt; SRR387777 K562 no SL2933 Puromycin #&gt; SRR387778 K562 yes, targeting SRF SL2934 Puromycin, doxycycline #&gt; SRR387779 K562 no SL5265 Puromycin #&gt; SRR387780 K562 yes targeting SRF SL3141 Puromycin, doxycycline #&gt; SRR389079 K562 no shRNA expression SL6485 Puromycin #&gt; ... ... ... ... ... #&gt; SRR389082 K562 expressing shRNA tar.. SL2592 Puromycin, doxycycline #&gt; SRR389083 K562 no shRNA expression SL4337 Puromycin #&gt; SRR389084 K562 expressing shRNA tar.. SL4326 Puromycin, doxycycline #&gt; SRR389077 K562 no shRNA expression SL1584 Puromycin #&gt; SRR389078 K562 expressing shRNA tar.. SL1583 Puromycin, doxycycline We are now ready to use other bulk RNA-seq data analysis software tools. 8.3 Exercise p.exercise { background-color: #E4EDE2; padding: 9px; border: 1px solid black; border-radius: 10px; font-family: sans-serif; } Exercise 1: Use iSEE to reproduce the following image Hints: Use dynamic feature selection Use information from columns (samples) for the X axis Use information from columns (samples) for the colors (optional) Create your free account at https://www.shinyapps.io/ and share your iSEE app with the world. Real examples used on a paper: https://github.com/LieberInstitute/10xPilot_snRNAseq-human#explore-the-data-interactively. Example from another course: https://libd.shinyapps.io/SRP009615/. It was created with https://github.com/lcolladotor/rnaseq_2023_notas_en_vivo/blob/main/app.R. 8.4 Community recount2 and 3 authors on Twitter: https://twitter.com/chrisnwilks https://twitter.com/BenLangmead https://twitter.com/KasperDHansen https://twitter.com/AbhiNellore https://twitter.com/Shannon_E_Ellis https://twitter.com/jtleek More about the different types of counts: If I'm using recount2 data for a differential analysis in DEseq2, should I be using the original counts, or the scaled counts?@mikelove @lcolladotor #rstats #Bioconductor — Dr. Robert M Flight, PhD (@rmflight) January 29, 2021 Tweets from the community From a student in the LCG-UNAM 2021 course: @lcolladotor Earlier I was looking for some data to analyze in recount, they have so much, I seriously can't decide what to use! https://t.co/fIJwXq46TzThanks for such an useful package!@chrisnwilks @BenLangmead @KasperDHansen @AbhiNellore @Shannon_E_Ellis @jtleek — Axel Zagal Norman (@NormanZagal) February 25, 2021 Exploring the possibility of using recount3 data for an analysis (January 2022): I have found a novel exon expressed in a cancer sample. I would like to search TCGA/SRA to identify other samples with the same/similar exon. It will be rare. Can I use Recount3, megadepth for this? @jtleek @lcolladotor @BenLangmead — Alicia Oshlack (@AliciaOshlack) January 5, 2022 Others discussing meta analyses publicly on Twitter: Thinking on this a bit it is strange how few people are doing “medium-sized” meta analyses of transcriptiomics. One on end you have @BenLangmead @lcolladotor reprocessing (with a touch of analysis) most of SRA. And you see papers pulling an dataset or two to corroborate. — David McGaughey (@David_McGaughey) February 1, 2022 "],["interpreting-model-coefficients-with-exploremodelmatrix.html", "9 Interpreting model coefficients with ExploreModelMatrix 9.1 Model objects in R 9.2 ExploreModelMatrix 9.3 Example 1 9.4 Example 2 9.5 Example 3 9.6 Exercise 9.7 To learn more 9.8 Community", " 9 Interpreting model coefficients with ExploreModelMatrix Instructor: Leo 9.1 Model objects in R Linear regression review https://lcolladotor.github.io/bioc_team_ds/helping-others.html#linear-regression-example With R, we use the model.matrix() to build regression models using the Y ~ X1 + X2 formula syntax as exemplified below. ## ?model.matrix mat &lt;- with(trees, model.matrix(log(Volume) ~ log(Height) + log(Girth))) mat #&gt; (Intercept) log(Height) log(Girth) #&gt; 1 1 4.248495 2.116256 #&gt; 2 1 4.174387 2.151762 #&gt; 3 1 4.143135 2.174752 #&gt; 4 1 4.276666 2.351375 #&gt; 5 1 4.394449 2.370244 #&gt; 6 1 4.418841 2.379546 #&gt; 7 1 4.189655 2.397895 #&gt; 8 1 4.317488 2.397895 #&gt; 9 1 4.382027 2.406945 #&gt; 10 1 4.317488 2.415914 #&gt; 11 1 4.369448 2.424803 #&gt; 12 1 4.330733 2.433613 #&gt; 13 1 4.330733 2.433613 #&gt; 14 1 4.234107 2.459589 #&gt; 15 1 4.317488 2.484907 #&gt; 16 1 4.304065 2.557227 #&gt; [ reached getOption(&quot;max.print&quot;) -- omitted 15 rows ] #&gt; attr(,&quot;assign&quot;) #&gt; [1] 0 1 2 colnames(mat) #&gt; [1] &quot;(Intercept)&quot; &quot;log(Height)&quot; &quot;log(Girth)&quot; How do we interpret the columns of our model matrix mat? summary(lm(log(Volume) ~ log(Height) + log(Girth), data = trees)) #&gt; #&gt; Call: #&gt; lm(formula = log(Volume) ~ log(Height) + log(Girth), data = trees) #&gt; #&gt; Residuals: #&gt; Min 1Q Median 3Q Max #&gt; -0.168561 -0.048488 0.002431 0.063637 0.129223 #&gt; #&gt; Coefficients: #&gt; Estimate Std. Error t value Pr(&gt;|t|) #&gt; (Intercept) -6.63162 0.79979 -8.292 5.06e-09 *** #&gt; log(Height) 1.11712 0.20444 5.464 7.81e-06 *** #&gt; log(Girth) 1.98265 0.07501 26.432 &lt; 2e-16 *** #&gt; --- #&gt; Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 #&gt; #&gt; Residual standard error: 0.08139 on 28 degrees of freedom #&gt; Multiple R-squared: 0.9777, Adjusted R-squared: 0.9761 #&gt; F-statistic: 613.2 on 2 and 28 DF, p-value: &lt; 2.2e-16 9.2 ExploreModelMatrix It’s a Bioconductor package which is useful to understand statistical models we use in differential expression analyses. It is interactive and helps us by creating some visual aids. http://www.bioconductor.org/packages/ExploreModelMatrix For more details, check their paper https://doi.org/10.12688/f1000research.24187.2. We’ll go over the examples they provide at http://www.bioconductor.org/packages/release/bioc/vignettes/ExploreModelMatrix/inst/doc/ExploreModelMatrix.html 9.3 Example 1 ## Load ExploreModelMatrix library(&quot;ExploreModelMatrix&quot;) ## Example data (sampleData &lt;- data.frame( genotype = rep(c(&quot;A&quot;, &quot;B&quot;), each = 4), treatment = rep(c(&quot;ctrl&quot;, &quot;trt&quot;), 4) )) #&gt; genotype treatment #&gt; 1 A ctrl #&gt; 2 A trt #&gt; 3 A ctrl #&gt; 4 A trt #&gt; 5 B ctrl #&gt; 6 B trt #&gt; 7 B ctrl #&gt; 8 B trt ## Let&#39;s make the visual aids provided by ExploreModelMatrix vd &lt;- ExploreModelMatrix::VisualizeDesign( sampleData = sampleData, designFormula = ~ genotype + treatment, textSizeFitted = 4 ) ## Now lets plot these images cowplot::plot_grid(plotlist = vd$plotlist) Interactively, we can run the following code: ## We are using shiny again here app &lt;- ExploreModelMatrix( sampleData = sampleData, designFormula = ~ genotype + treatment ) if (interactive()) shiny::runApp(app) 9.4 Example 2 http://bioconductor.org/packages/release/bioc/vignettes/ExploreModelMatrix/inst/doc/ExploreModelMatrix.html#example-2 9.5 Example 3 http://bioconductor.org/packages/release/bioc/vignettes/ExploreModelMatrix/inst/doc/ExploreModelMatrix.html#example-3 9.6 Exercise p.exercise { background-color: #E4EDE2; padding: 9px; border: 1px solid black; border-radius: 10px; font-family: sans-serif; } Exercise 1: Interpret ResponseResistant.Treatmentpre from the second example. It could be useful to take a screenshot and to draw some annotations on it. Exercise 2: Whis is the 0 important at the beginning of the formula in the third example? 9.7 To learn more A guide to creating design matrices for gene expression experiments: http://bioconductor.org/packages/release/workflows/vignettes/RNAseq123/inst/doc/designmatrices.html https://f1000research.com/articles/9-1444 “Model matrix not full rank” http://bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#model-matrix-not-full-rank 9.8 Community Some of the ExploreModelMatrix authors: https://twitter.com/CSoneson https://twitter.com/FedeBioinfo https://twitter.com/mikelove "],["differential-gene-expression-analysis-with-limma.html", "10 Differential gene expression analysis with limma 10.1 SRP045638 data 10.2 Data normalization 10.3 Differential expression 10.4 Visualizing DEGs 10.5 Community", " 10 Differential gene expression analysis with limma Instructor: Leo 10.1 SRP045638 data We’ll use data from https://www.ncbi.nlm.nih.gov/sra/?term=SRP045638 processed and made available through the recount3 project. First, we need to download the data with the same commands we saw earlier. library(&quot;recount3&quot;) human_projects &lt;- available_projects() #&gt; 2024-05-28 02:36:07.392636 caching file sra.recount_project.MD.gz. #&gt; 2024-05-28 02:36:07.656205 caching file gtex.recount_project.MD.gz. #&gt; 2024-05-28 02:36:07.908241 caching file tcga.recount_project.MD.gz. rse_gene_SRP045638 &lt;- create_rse( subset( human_projects, project == &quot;SRP045638&quot; &amp; project_type == &quot;data_sources&quot; ) ) #&gt; 2024-05-28 02:36:09.875243 downloading and reading the metadata. #&gt; 2024-05-28 02:36:10.163861 caching file sra.sra.SRP045638.MD.gz. #&gt; adding rname &#39;http://duffel.rail.bio/recount3/human/data_sources/sra/metadata/38/SRP045638/sra.sra.SRP045638.MD.gz&#39; #&gt; 2024-05-28 02:36:11.032273 caching file sra.recount_project.SRP045638.MD.gz. #&gt; adding rname &#39;http://duffel.rail.bio/recount3/human/data_sources/sra/metadata/38/SRP045638/sra.recount_project.SRP045638.MD.gz&#39; #&gt; 2024-05-28 02:36:12.152217 caching file sra.recount_qc.SRP045638.MD.gz. #&gt; adding rname &#39;http://duffel.rail.bio/recount3/human/data_sources/sra/metadata/38/SRP045638/sra.recount_qc.SRP045638.MD.gz&#39; #&gt; 2024-05-28 02:36:13.024807 caching file sra.recount_seq_qc.SRP045638.MD.gz. #&gt; adding rname &#39;http://duffel.rail.bio/recount3/human/data_sources/sra/metadata/38/SRP045638/sra.recount_seq_qc.SRP045638.MD.gz&#39; #&gt; 2024-05-28 02:36:13.882173 caching file sra.recount_pred.SRP045638.MD.gz. #&gt; adding rname &#39;http://duffel.rail.bio/recount3/human/data_sources/sra/metadata/38/SRP045638/sra.recount_pred.SRP045638.MD.gz&#39; #&gt; 2024-05-28 02:36:14.502974 downloading and reading the feature information. #&gt; 2024-05-28 02:36:14.740687 caching file human.gene_sums.G026.gtf.gz. #&gt; 2024-05-28 02:36:15.131229 downloading and reading the counts: 66 samples across 63856 features. #&gt; 2024-05-28 02:36:15.382199 caching file sra.gene_sums.SRP045638.G026.gz. #&gt; adding rname &#39;http://duffel.rail.bio/recount3/human/data_sources/sra/gene_sums/38/SRP045638/sra.gene_sums.SRP045638.G026.gz&#39; #&gt; 2024-05-28 02:36:16.486352 constructing the RangedSummarizedExperiment (rse) object. assay(rse_gene_SRP045638, &quot;counts&quot;) &lt;- compute_read_counts(rse_gene_SRP045638) Now that we have the data and have computed the read counts (which will be needed for downstream analyses), we can use expand_sra_attributes() to make it easier to use the sample information in downstream analyses. However, we have to resolve some issues with this data first. ## Can you notice the problem with the sample information? rse_gene_SRP045638$sra.sample_attributes[1:3] #&gt; [1] &quot;age;;67.78|biomaterial_provider;;LIBD|BioSampleModel;;Human|dev_stage;;Fetal|disease;;Control|Fraction;;total|isolate;;DLPFC|race;;AA|RIN;;8.3|sex;;female|tissue;;DLPFC&quot; #&gt; [2] &quot;age;;40.42|biomaterial_provider;;LIBD|BioSampleModel;;Human|disease;;Control|Fraction;;total|isolate;;DLPFC|race;;AA|RIN;;8.4|sex;;male|tissue;;DLPFC&quot; #&gt; [3] &quot;age;;41.58|biomaterial_provider;;LIBD|BioSampleModel;;Human|disease;;control|Fraction;;total|isolate;;R2869|race;;AA|RIN;;8.7|sex;;male|tissue;;DLPFC&quot; Lets resolve the issue we detected with this sample information. We’ll resolve this by eliminating some information that is only present in a subset of samples and that we don’t need. rse_gene_SRP045638$sra.sample_attributes &lt;- gsub(&quot;dev_stage;;Fetal\\\\|&quot;, &quot;&quot;, rse_gene_SRP045638$sra.sample_attributes) rse_gene_SRP045638$sra.sample_attributes[1:3] #&gt; [1] &quot;age;;67.78|biomaterial_provider;;LIBD|BioSampleModel;;Human|disease;;Control|Fraction;;total|isolate;;DLPFC|race;;AA|RIN;;8.3|sex;;female|tissue;;DLPFC&quot; #&gt; [2] &quot;age;;40.42|biomaterial_provider;;LIBD|BioSampleModel;;Human|disease;;Control|Fraction;;total|isolate;;DLPFC|race;;AA|RIN;;8.4|sex;;male|tissue;;DLPFC&quot; #&gt; [3] &quot;age;;41.58|biomaterial_provider;;LIBD|BioSampleModel;;Human|disease;;control|Fraction;;total|isolate;;R2869|race;;AA|RIN;;8.7|sex;;male|tissue;;DLPFC&quot; Now we can continue our work using similar code from the one we used earlier. rse_gene_SRP045638 &lt;- expand_sra_attributes(rse_gene_SRP045638) colData(rse_gene_SRP045638)[ , grepl(&quot;^sra_attribute&quot;, colnames(colData(rse_gene_SRP045638))) ] #&gt; DataFrame with 66 rows and 10 columns #&gt; sra_attribute.age sra_attribute.biomaterial_provider sra_attribute.BioSampleModel sra_attribute.disease #&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; #&gt; SRR2071341 67.78 LIBD Human Control #&gt; SRR2071345 40.42 LIBD Human Control #&gt; SRR2071346 41.58 LIBD Human control #&gt; SRR2071347 44.17 LIBD Human control #&gt; sra_attribute.Fraction sra_attribute.isolate sra_attribute.race sra_attribute.RIN sra_attribute.sex #&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; #&gt; SRR2071341 total DLPFC AA 8.3 female #&gt; SRR2071345 total DLPFC AA 8.4 male #&gt; SRR2071346 total R2869 AA 8.7 male #&gt; SRR2071347 total R3098 AA 5.3 female #&gt; sra_attribute.tissue #&gt; &lt;character&gt; #&gt; SRR2071341 DLPFC #&gt; SRR2071345 DLPFC #&gt; SRR2071346 DLPFC #&gt; SRR2071347 DLPFC #&gt; [ reached getOption(&quot;max.print&quot;) -- omitted 7 rows ] As well use the sampel information for building our statistical model, it will important that we make sure that it is on the correct format R expects later on. ## Recast character vectors into numeric or factor ones rse_gene_SRP045638$sra_attribute.age &lt;- as.numeric(rse_gene_SRP045638$sra_attribute.age) rse_gene_SRP045638$sra_attribute.disease &lt;- factor(tolower(rse_gene_SRP045638$sra_attribute.disease)) rse_gene_SRP045638$sra_attribute.RIN &lt;- as.numeric(rse_gene_SRP045638$sra_attribute.RIN) rse_gene_SRP045638$sra_attribute.sex &lt;- factor(rse_gene_SRP045638$sra_attribute.sex) ## Summary of our variables of interest summary(as.data.frame(colData(rse_gene_SRP045638)[ , grepl(&quot;^sra_attribute.[age|disease|RIN|sex]&quot;, colnames(colData(rse_gene_SRP045638))) ])) #&gt; sra_attribute.age sra_attribute.disease sra_attribute.isolate sra_attribute.RIN sra_attribute.sex #&gt; Min. :-0.4986 control:66 Length:66 Min. :5.30 female:22 #&gt; 1st Qu.: 0.3424 Class :character 1st Qu.:8.00 male :44 #&gt; Median :14.9000 Mode :character Median :8.30 #&gt; Mean :22.6286 Mean :8.15 #&gt; 3rd Qu.:41.2900 3rd Qu.:8.70 #&gt; Max. :73.9100 Max. :9.60 We’ll now create a few variables from this sample information so we can use them in our analysis. ## We&#39;ll want to look for differences between prenatal and postnatal samples rse_gene_SRP045638$prenatal &lt;- factor(ifelse(rse_gene_SRP045638$sra_attribute.age &lt; 0, &quot;prenatal&quot;, &quot;postnatal&quot;)) table(rse_gene_SRP045638$prenatal) #&gt; #&gt; postnatal prenatal #&gt; 56 10 ## http://rna.recount.bio/docs/quality-check-fields.html rse_gene_SRP045638$assigned_gene_prop &lt;- rse_gene_SRP045638$recount_qc.gene_fc_count_all.assigned / rse_gene_SRP045638$recount_qc.gene_fc_count_all.total summary(rse_gene_SRP045638$assigned_gene_prop) #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 0.1942 0.7004 0.7591 0.7170 0.7991 0.8493 with(colData(rse_gene_SRP045638), plot(assigned_gene_prop, sra_attribute.RIN)) ## Hm... lets check if there is a difference between these two groups with(colData(rse_gene_SRP045638), tapply(assigned_gene_prop, prenatal, summary)) #&gt; $postnatal #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 0.1942 0.7072 0.7719 0.7179 0.8017 0.8493 #&gt; #&gt; $prenatal #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 0.6856 0.7004 0.7088 0.7116 0.7259 0.7347 We can next drop some samples that we consider of low quality as well as genes that have low expression levels. ## Lets save our full object for now in case we change our minds later on rse_gene_SRP045638_unfiltered &lt;- rse_gene_SRP045638 ## Lets drop some bad samples. On a real analysis, you would likely use ## some statistical method for identifying outliers such as scuttle::isOutlier() hist(rse_gene_SRP045638$assigned_gene_prop) table(rse_gene_SRP045638$assigned_gene_prop &lt; 0.3) #&gt; #&gt; FALSE TRUE #&gt; 65 1 rse_gene_SRP045638 &lt;- rse_gene_SRP045638[, rse_gene_SRP045638$assigned_gene_prop &gt; 0.3] ## Lets compute the mean expression levels. ## ## Note: in a real analysis we would likely do this with RPKMs or CPMs instead ## of counts. That is, we would use one of the following options: # edgeR::filterByExpr() https://bioconductor.org/packages/edgeR/ https://rdrr.io/bioc/edgeR/man/filterByExpr.html # genefilter::genefilter() https://bioconductor.org/packages/genefilter/ https://rdrr.io/bioc/genefilter/man/genefilter.html # jaffelab::expression_cutoff() http://research.libd.org/jaffelab/reference/expression_cutoff.html # gene_means &lt;- rowMeans(assay(rse_gene_SRP045638, &quot;counts&quot;)) summary(gene_means) #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 0.0 0.1 2.5 815.2 170.2 1362047.9 ## We can now drop genes with low expression levels rse_gene_SRP045638 &lt;- rse_gene_SRP045638[gene_means &gt; 0.1, ] ## Final dimensions of our RSE object dim(rse_gene_SRP045638) #&gt; [1] 46929 65 ## Percent of genes that we retained: round(nrow(rse_gene_SRP045638) / nrow(rse_gene_SRP045638_unfiltered) * 100, 2) #&gt; [1] 73.49 We are now ready to continue with the differential expression analysis. Well, almost! 😅 10.2 Data normalization Read the A hypothetical scenario in one of the edgeR papers https://genomebiology.biomedcentral.com/articles/10.1186/gb-2010-11-3-r25#Sec2 to understand the concept of composition bias. This concept is still relevant nowadays with single cell RNA-seq (scRNA-seq) data as you can see at http://bioconductor.org/books/3.16/OSCA.multisample/multi-sample-comparisons.html#performing-the-de-analysis. In that chapter they describe a series of steps for re-using bulk RNA-seq methods with scRNA-seq data. ## Use edgeR::calcNormFactors() to address the composition bias library(&quot;edgeR&quot;) dge &lt;- DGEList( counts = assay(rse_gene_SRP045638, &quot;counts&quot;), genes = rowData(rse_gene_SRP045638) ) dge &lt;- calcNormFactors(dge) 10.3 Differential expression First of all, lets define our differential expression model. Typically, we would explore the data more to check that there are no other quality control issues with our samples and to explore in more detail the relationship between our sample phenotype variables. library(&quot;ggplot2&quot;) ggplot(as.data.frame(colData(rse_gene_SRP045638)), aes(y = assigned_gene_prop, x = prenatal)) + geom_boxplot() + theme_bw(base_size = 20) + ylab(&quot;Assigned Gene Prop&quot;) + xlab(&quot;Age Group&quot;) For example, we would explore the contribution of different variables to the gene expression variability we observe using the variancePartition and scater Bioconductor packages, among others. We’ll do more of this tomorrow but you can also check these LIBD rstats club notes. For now, we’ll use the following stastistical model. mod &lt;- model.matrix(~ prenatal + sra_attribute.RIN + sra_attribute.sex + assigned_gene_prop, data = colData(rse_gene_SRP045638) ) colnames(mod) #&gt; [1] &quot;(Intercept)&quot; &quot;prenatalprenatal&quot; &quot;sra_attribute.RIN&quot; &quot;sra_attribute.sexmale&quot; #&gt; [5] &quot;assigned_gene_prop&quot; Now that we have a model, we can use limma to actually compute the differential expression statistics and extract the results. library(&quot;limma&quot;) vGene &lt;- voom(dge, mod, plot = TRUE) eb_results &lt;- eBayes(lmFit(vGene)) de_results &lt;- topTable( eb_results, coef = 2, number = nrow(rse_gene_SRP045638), sort.by = &quot;none&quot; ) dim(de_results) #&gt; [1] 46929 16 head(de_results) #&gt; source type bp_length phase gene_id gene_type gene_name level #&gt; ENSG00000223972.5 HAVANA gene 1735 NA ENSG00000223972.5 transcribed_unprocessed_pseudogene DDX11L1 2 #&gt; ENSG00000278267.1 ENSEMBL gene 68 NA ENSG00000278267.1 miRNA MIR6859-1 3 #&gt; ENSG00000227232.5 HAVANA gene 1351 NA ENSG00000227232.5 unprocessed_pseudogene WASH7P 2 #&gt; havana_gene tag logFC AveExpr t P.Value adj.P.Val B #&gt; ENSG00000223972.5 OTTHUMG00000000961.2 &lt;NA&gt; -0.4522185 -3.444164 -1.637034 1.064080e-01 1.348462e-01 -5.554484 #&gt; ENSG00000278267.1 &lt;NA&gt; &lt;NA&gt; 1.1158860 -1.311645 6.123756 5.743771e-08 2.105690e-07 7.763912 #&gt; ENSG00000227232.5 OTTHUMG00000000958.1 &lt;NA&gt; 0.6860298 3.641131 5.644804 3.816951e-07 1.247133e-06 5.500784 #&gt; [ reached &#39;max&#39; / getOption(&quot;max.print&quot;) -- omitted 3 rows ] ## Differentially expressed genes between pre and post natal with FDR &lt; 5% table(de_results$adj.P.Val &lt; 0.05) #&gt; #&gt; FALSE TRUE #&gt; 12851 34078 ## We can now visualize the resulting differential expression results plotMA(eb_results, coef = 2) ## We can also make a volcano plot volcanoplot(eb_results, coef = 2, highlight = 3, names = de_results$gene_name) de_results[de_results$gene_name %in% c(&quot;ZSCAN2&quot;, &quot;VASH2&quot;, &quot;KIAA0922&quot;), ] #&gt; source type bp_length phase gene_id gene_type gene_name level havana_gene #&gt; ENSG00000143494.15 HAVANA gene 9086 NA ENSG00000143494.15 protein_coding VASH2 2 OTTHUMG00000036925.5 #&gt; ENSG00000176371.13 HAVANA gene 4878 NA ENSG00000176371.13 protein_coding ZSCAN2 1 OTTHUMG00000074027.5 #&gt; ENSG00000121210.15 HAVANA gene 6393 NA ENSG00000121210.15 protein_coding KIAA0922 2 OTTHUMG00000153244.5 #&gt; tag logFC AveExpr t P.Value adj.P.Val B #&gt; ENSG00000143494.15 &lt;NA&gt; 5.444271 1.876990 37.85216 2.561452e-46 6.010319e-42 95.10126 #&gt; ENSG00000176371.13 &lt;NA&gt; 2.735639 2.751109 36.59344 2.137022e-45 3.342943e-41 92.99949 #&gt; ENSG00000121210.15 &lt;NA&gt; 3.283050 2.945269 41.89725 4.235912e-49 1.987871e-44 101.31124 https://www.genecards.org/cgi-bin/carddisp.pl?gene=ZSCAN2 https://www.genecards.org/cgi-bin/carddisp.pl?gene=VASH2 https://www.genecards.org/cgi-bin/carddisp.pl?gene=KIAA0922 10.4 Visualizing DEGs From vGene$E we can extract the normalized expression values that limma-voom computed. We can check the top 50 differentially expressed genes (DEGs) for example. ## Extract the normalized expression values from our limma-voom result ## from earlier exprs_heatmap &lt;- vGene$E[rank(de_results$adj.P.Val) &lt;= 50, ] ## We can now build a table with information about our samples and ## then make the names a bit more friendly by making them easier to ## understand df &lt;- as.data.frame(colData(rse_gene_SRP045638)[, c(&quot;prenatal&quot;, &quot;sra_attribute.RIN&quot;, &quot;sra_attribute.sex&quot;)]) colnames(df) &lt;- c(&quot;AgeGroup&quot;, &quot;RIN&quot;, &quot;Sex&quot;) ## Next, we can make a basic heatmap library(&quot;pheatmap&quot;) pheatmap( exprs_heatmap, cluster_rows = TRUE, cluster_cols = TRUE, show_rownames = FALSE, show_colnames = FALSE, annotation_col = df ) We’ll learn more about gene expression heatmaps tomorrow! Overall, these DEG results are not as surprising since there is a huge difference between pre and post natal gene expression in the human DLPFC. We can see that more clearly with a MDS (multidimensional scaling) plot just like its described in the limma workflow. Tomas will teach you more about dimension reduction tomorrow. ## For nicer colors library(&quot;RColorBrewer&quot;) ## Mapping age groups into colors col.group &lt;- df$AgeGroup levels(col.group) &lt;- brewer.pal(nlevels(col.group), &quot;Set1&quot;) #&gt; Warning in brewer.pal(nlevels(col.group), &quot;Set1&quot;): minimal value for n is 3, returning requested palette with 3 different levels col.group &lt;- as.character(col.group) ## MDS by age groups limma::plotMDS(vGene$E, labels = df$AgeGroup, col = col.group) ## Mapping Sex values into colors col.sex &lt;- df$Sex levels(col.sex) &lt;- brewer.pal(nlevels(col.sex), &quot;Dark2&quot;) #&gt; Warning in brewer.pal(nlevels(col.sex), &quot;Dark2&quot;): minimal value for n is 3, returning requested palette with 3 different levels col.sex &lt;- as.character(col.sex) ## MDS by Sex limma::plotMDS(vGene$E, labels = df$Sex, col = col.sex) A lot of times, running the differential expression analysis is not the hard part. Building your model and having all the covariates you need can take much more work! 10.5 Community Some edgeR and limma authors: https://twitter.com/mritchieau https://twitter.com/davisjmcc https://twitter.com/markrobinsonca https://twitter.com/AliciaOshlack If you've ever been dazed by design matrices or confused by contrasts when performing gene expression analysis in limma, the new article by Charity Law is for you https://t.co/ZSMOA20tdm #bioconductor #rstats (1/2) — Matt Ritchie (@mritchieau) December 15, 2020 "],["differential-gene-expression-exercise.html", "11 Differential gene expression exercise 11.1 Recap 11.2 Exercise", " 11 Differential gene expression exercise Instructor: Leo 11.1 Recap So far we know how to: choose a study from recount3 download data for a study with recount3::create_rse() explore the data interactively with iSEE expand Sequence Read Archive (SRA) attributes sometimes we need to clean them up a bit before we can use them use edgeR::calcNormFactors() to reduce composition bias build a differential gene expression model with model.matrix() explore and interpret the model with ExploreModelMatrix use limma::voom() and related functions to compute the differential gene expression statistics extract the DEG statistics with limma::topTable(sort.by = \"none\") use some limma functions for making MA or volcano plots among several other plots and tools we learned along the way. Alternatively to recount3, we have learned about the RangedSummarizedExperiment objects produced by SPEAQeasy and in particular the one we are using on the smokingMouse project. You might have your own data already. Maybe you have it as an AnnData python object. If so, you can convert it to R with zellkonverter. 11.2 Exercise p.exercise { background-color: #E4EDE2; padding: 9px; border: 1px solid black; border-radius: 10px; font-family: sans-serif; } Exercise option 1: This will be an open ended exercise. Think of it as time to practice what we’ve learnt using data from recount3 or another subset of the smokingMouse dataset. You could also choose to re-run code from earlier parts of the course and ask clarifying questions. You could also use this time to adapt some of the code we’ve covered to use it with your own dataset. If you prefer a more structured exercise: Exercise option 2: Choose two recount3 studies that can be used to study similar research questions. For example, two studies with brain samples across age. Download and process each dataset independently, up to the point where you have differential expression t-statistics for both. Skip most of the exploratory data analyses steps as for the purpose of this exercise, we are most interested in the DEG t-statistics. If you don’t want to choose another recount3 study, you could use the smokingMouse data and subset it once to the pups in nicotine arm of the study and a second time for the pups in the smoking arm of the study. Or you could use the GTEx brain data from recount3, subset it to the prefrontal cortex (PFC), and compute age related expression changes. That would be in addition to SRA study SRP045638 that we used previously. recount3::create_rse_manual( project = &quot;BRAIN&quot;, project_home = &quot;data_sources/gtex&quot;, organism = &quot;human&quot;, annotation = &quot;gencode_v26&quot;, type = &quot;gene&quot; ) Make a scatterplot of the t-statistics between the two datasets to assess correlation / concordance. You might want to use GGally::ggpairs() for this https://ggobi.github.io/ggally/reference/ggpairs.html. Or ggpubr::ggscatter() https://rpkgs.datanovia.com/ggpubr/reference/ggscatter.html. For example, between the GTEx PFC data and the data we used previously from SRA study SRP045638. Or between the nicotine-exposed pups and the smoking-exposed pups in smokingMouse. Or using the two recount3 studies you chose. Are there any DEGs FDR &lt; 5% in both datasets? Or FDR &lt; 5% in dataset 1 that have a p-value &lt; 5% in the other one? You could choose to make a concordance at the top plot like at http://leekgroup.github.io/recount-analyses/example_de/recount_SRP019936.html, though you will likely need more time to complete this. "],["dge-model-building-with-variancepartition.html", "12 DGE model building with variancePartition 12.1 Download the smokingMouse data and subset it 12.2 Explore gene-level effects 12.3 Variance Partition Analysis 12.4 Solutions References", " 12 DGE model building with variancePartition Instructor: Daianna 12.1 Download the smokingMouse data and subset it We’ve used these commands already in an earlier chapters. ## Load the container package for this type of data library(&quot;SummarizedExperiment&quot;) ## Download data library(&quot;BiocFileCache&quot;) bfc &lt;- BiocFileCache::BiocFileCache() cached_rse_gene &lt;- BiocFileCache::bfcrpath( x = bfc, &quot;https://github.com/LieberInstitute/SPEAQeasyWorkshop2023/raw/devel/provisional_data/rse_gene_mouse_RNAseq_nic-smo.Rdata&quot; ) ## Check the local path on our cache cached_rse_gene #&gt; BFC2 #&gt; &quot;/github/home/.cache/R/BiocFileCache/107d14e54709_rse_gene_mouse_RNAseq_nic-smo.Rdata&quot; ## Load the rse_gene object load(cached_rse_gene, verbose = TRUE) #&gt; Loading objects: #&gt; rse_gene ## Nicotine data rse_gene_nic &lt;- rse_gene[, which(rse_gene$Expt == &quot;Nicotine&quot;)] ## Retain genes that passed filtering step rse_gene_filt &lt;- rse_gene_nic[rowData(rse_gene_nic)$retained_after_feature_filtering == TRUE, ] ## Separate data by Age rse_gene_pups &lt;- rse_gene_filt[, which(rse_gene_filt$Age == &quot;Pup&quot;)] rse_gene_adults &lt;- rse_gene_filt[, which(rse_gene_filt$Age == &quot;Adult&quot;)] library(&quot;scuttle&quot;) ## Filter adult samples outliers_library_size &lt;- isOutlier(rse_gene_adults$sum, nmads = 3, type = &quot;lower&quot;) outliers_detected_num &lt;- isOutlier(rse_gene_adults$detected, nmads = 3, type = &quot;lower&quot;) outliers_totalAssignedGene &lt;- isOutlier(rse_gene_adults$totalAssignedGene, nmads = 3, type = &quot;lower&quot;) outliers_mito &lt;- isOutlier(rse_gene_adults$mitoRate, nmads = 3, type = &quot;higher&quot;) outliers_rRNArate &lt;- isOutlier(rse_gene_adults$rRNA_rate, nmads = 3, type = &quot;higher&quot;) not_outliers &lt;- which(!(outliers_library_size | outliers_detected_num | outliers_totalAssignedGene | outliers_mito | outliers_rRNArate)) rse_gene_adults_qc &lt;- rse_gene_adults[, not_outliers] ## Filter pup samples outliers_library_size &lt;- isOutlier(rse_gene_pups$sum, nmads = 3, type = &quot;lower&quot;) outliers_detected_num &lt;- isOutlier(rse_gene_pups$detected, nmads = 3, type = &quot;lower&quot;) outliers_totalAssignedGene &lt;- isOutlier(rse_gene_pups$totalAssignedGene, nmads = 3, type = &quot;lower&quot;) outliers_mito &lt;- isOutlier(rse_gene_pups$mitoRate, nmads = 3, type = &quot;higher&quot;) outliers_rRNArate &lt;- isOutlier(rse_gene_pups$rRNA_rate, nmads = 3, type = &quot;higher&quot;) not_outliers &lt;- which(!(outliers_library_size | outliers_detected_num | outliers_totalAssignedGene | outliers_mito | outliers_rRNArate)) rse_gene_pups_qc &lt;- rse_gene_pups[, not_outliers] 12.2 Explore gene-level effects Once the quality and the variability of the samples have been evaluated, the next step is to explore the differences in the expression of the genes themselves in the sample groups, or in other words, to quantify the contribution of the multiple sample variables of the study in the gene expression variation, which constitutes one of the fundamental challenges when analyzing complex RNA-seq datasets [1]. To determine which variables are the major drivers of expression variability, and importantly to define if the technical variability of RNA-seq data is low enough to study nicotine effects, we can implement an analysis of variance partition. variancePartition is a package that decomposes for each gene the expression variation into fractions of variance explained (FVE) by the sample variables of the experimental design of high-throughput genomics studies [1]. 12.3 Variance Partition Analysis 12.3.1 Canonical Correlation Analysis Before the analysis itself, we need to measure the correlation between the sample variables. This is an important step because highly correlated variables can produce unstable estimates of the variance fractions and hinder the identification of the variables that really contribute to the expression variation. There are at least two problems with that: If two variables are correlated, we could incorrectly determine that one of them contributes to gene expression changes when in reality it was just correlated with a real contributory variable. The part of variance explained by a biologically relevant variable can be reduced by the apparent contributions of correlated variables, if for example, they contain very similar information. Additionally, the analysis is better performed with simpler models, specially when we have a limited number of samples in the study. Hence, to drop such variables we must identify them first. Pearson correlation can be used for comparing continuous variables but the models can contain categorical variables as well, so in order to obtain the correlation between a continuous and a categorical variable, or between two categorical variables, we will perform a Canonical Correlation Analysis (CCA) with canCorPairs() that assesses the degree to which the variables co-vary and contain the same information. This function returns rho / sum(rho), the fraction of the maximum possible correlation. Note that CCA returns correlations values between 0 and 1 [2]. library(&quot;variancePartition&quot;) library(&quot;pheatmap&quot;) library(&quot;rlang&quot;) ####################### Variance Partition Analysis ####################### ## Fraction of variation attributable to each variable after correcting for all other variables ## 1. Canonical Correlation Analysis (CCA) ## Assess the correlation between each pair of sample variables ## Plot heatmap of correlations plot_CCA &lt;- function(age) { ## Data rse_gene &lt;- eval(parse_expr(paste0(&quot;rse_gene_&quot;, age, &quot;_qc&quot;))) ## Define variables to examine: remove those with single values ## For adults: all are females (so we drop &#39;Sex&#39; variable) if (age == &quot;adults&quot;) { formula &lt;- ~ Group + Pregnancy + plate + flowcell + mitoRate + overallMapRate + totalAssignedGene + rRNA_rate + sum + detected + ERCCsumLogErr } ## For pups: none is pregnant (so the &#39;Pregnancy&#39; variable is not considered) else { formula &lt;- ~ Group + Sex + plate + flowcell + mitoRate + overallMapRate + totalAssignedGene + rRNA_rate + sum + detected + ERCCsumLogErr } ## Measure correlations C &lt;- canCorPairs(formula, colData(rse_gene)) ## Heatmap pheatmap( C, ## data color = hcl.colors(50, &quot;YlOrRd&quot;, rev = TRUE), ## color scale fontsize = 8, ## text size border_color = &quot;black&quot;, ## border color for heatmap cells cellwidth = unit(0.4, &quot;cm&quot;), ## height of cells cellheight = unit(0.4, &quot;cm&quot;) ## width of cells ) return(C) } As you can see, and in agreement to what we observed in the previous correlation plots, for adults there’s a strong correlation between mitoRate and totalAssignedGene ; we already know it’s a negative correlation. There’s also a strong correlation between plate and flowcell and between plate and overallMapRate . ## Heatmap for adult samples CCA_adults &lt;- plot_CCA(&quot;adults&quot;) In pups overallMapRate has a relationship with rRNA_rate , plate and flowcell . ## Heatmap for pup samples CCA_pups &lt;- plot_CCA(&quot;pups&quot;) Importantly, in both groups of age Group is not highly correlated with any other variable. This is desirable because if this variable, the one that separates experimental and control samples, were correlated with another, then its individual contribution to gene expression changes would be diminished, affecting the results of the differential expression analysis: we would obtain gene differences driven by other variables rather than Group . Also, sum and detected are correlated. Let’s explore why these variables are correlated in the following plots. library(&quot;ggplot2&quot;) library(&quot;cowplot&quot;) ## 1.1 Barplots/Boxplots/Scatterplots for each pair of correlated variables corr_plots &lt;- function(age, sample_var1, sample_var2, sample_color) { ## Data rse_gene &lt;- eval(parse_expr(paste(&quot;rse_gene&quot;, age, &quot;qc&quot;, sep = &quot;_&quot;))) CCA &lt;- eval(parse_expr(paste0(&quot;CCA_&quot;, age))) ## Sample color by one variable colors &lt;- list( &quot;Group&quot; = c(&quot;Control&quot; = &quot;brown2&quot;, &quot;Experimental&quot; = &quot;deepskyblue3&quot;), &quot;Age&quot; = c(&quot;Adult&quot; = &quot;slateblue3&quot;, &quot;Pup&quot; = &quot;yellow3&quot;), &quot;Sex&quot; = c(&quot;F&quot; = &quot;hotpink1&quot;, &quot;M&quot; = &quot;dodgerblue&quot;), &quot;Pregnancy&quot; = c(&quot;Yes&quot; = &quot;darkorchid3&quot;, &quot;No&quot; = &quot;darkolivegreen4&quot;), &quot;plate&quot; = c(&quot;Plate1&quot; = &quot;darkorange&quot;, &quot;Plate2&quot; = &quot;lightskyblue&quot;, &quot;Plate3&quot; = &quot;deeppink1&quot;), &quot;flowcell&quot; = c( &quot;HKCG7DSXX&quot; = &quot;chartreuse2&quot;, &quot;HKCMHDSXX&quot; = &quot;magenta&quot;, &quot;HKCNKDSXX&quot; = &quot;turquoise3&quot;, &quot;HKCTMDSXX&quot; = &quot;tomato&quot; ) ) data &lt;- colData(rse_gene) ## Barplots for categorical variable vs categorical variable if (class(data[, sample_var1]) == &quot;character&quot; &amp; class(data[, sample_var2]) == &quot;character&quot;) { ## y-axis label if (sample_var2 == &quot;Pregnancy&quot;) { y_label &lt;- paste(&quot;Number of samples from each &quot;, sample_var2, &quot; group&quot;, sep = &quot;&quot;) } else { y_label &lt;- paste(&quot;Number of samples from each &quot;, sample_var2, sep = &quot;&quot;) } # Stacked barplot with counts for 2nd variable plot &lt;- ggplot(data = as.data.frame(data), aes( x = !!rlang::sym(sample_var1), fill = !!rlang::sym(sample_var2) )) + geom_bar(position = &quot;stack&quot;) + ## Colors by 2nd variable scale_fill_manual(values = colors[[sample_var2]]) + ## Show sample counts on stacked bars geom_text(aes(label = after_stat(count)), stat = &quot;count&quot;, position = position_stack(vjust = 0.5), colour = &quot;gray20&quot;, size = 3 ) + theme_bw() + labs( subtitle = paste0(&quot;Corr: &quot;, signif(CCA[sample_var1, sample_var2], digits = 3)), y = y_label ) + theme( axis.title = element_text(size = (7)), axis.text = element_text(size = (6)), plot.subtitle = element_text(size = 7, color = &quot;gray40&quot;), legend.text = element_text(size = 6), legend.title = element_text(size = 7) ) } ## Boxplots for categorical variable vs continuous variable else if (class(data[, sample_var1]) == &quot;character&quot; &amp; class(data[, sample_var2]) == &quot;numeric&quot;) { plot &lt;- ggplot(data = as.data.frame(data), mapping = aes( x = !!rlang::sym(sample_var1), y = !!rlang::sym(sample_var2), color = !!rlang::sym(sample_var1) )) + geom_boxplot(size = 0.25, width = 0.32, color = &quot;black&quot;, outlier.color = &quot;#FFFFFFFF&quot;) + geom_jitter(width = 0.15, alpha = 1, size = 1) + stat_smooth(geom = &quot;line&quot;, alpha = 0.6, size = 0.4, span = 0.3, method = lm, aes(group = 1), color = &quot;orangered3&quot;) + scale_color_manual(values = colors[[sample_var1]]) + theme_bw() + guides(color = &quot;none&quot;) + labs( subtitle = paste0(&quot;Corr: &quot;, signif(CCA[sample_var1, sample_var2], digits = 3)), y = gsub(&quot;_&quot;, &quot; &quot;, sample_var2), x = sample_var1 ) + theme( axis.title = element_text(size = (7)), axis.text = element_text(size = (6)), plot.subtitle = element_text(size = 7, color = &quot;gray40&quot;), legend.text = element_text(size = 6), legend.title = element_text(size = 7) ) } ## Scatterplots for continuous variable vs continuous variable else if (class(data[, sample_var1]) == &quot;numeric&quot; &amp; class(data[, sample_var2]) == &quot;numeric&quot;) { plot &lt;- ggplot(as.data.frame(data), aes( x = !!rlang::sym(sample_var1), y = !!rlang::sym(sample_var2), color = !!rlang::sym(sample_color) )) + geom_point(size = 2) + stat_smooth(geom = &quot;line&quot;, alpha = 0.4, size = 0.4, span = 0.25, method = lm, color = &quot;orangered3&quot;) + ## Color by sample_color variale scale_color_manual(name = sample_color, values = colors[[sample_color]]) + theme_bw() + labs(subtitle = paste0(&quot;Corr: &quot;, signif(CCA[sample_var1, sample_var2], digits = 3)), y = gsub(&quot;_&quot;, &quot; &quot;, sample_var2), x = gsub(&quot;_&quot;, &quot; &quot;, sample_var1)) + theme( axis.title = element_text(size = (7)), axis.text = element_text(size = (6)), plot.subtitle = element_text(size = 7, color = &quot;gray40&quot;), legend.text = element_text(size = 6), legend.title = element_text(size = 7) ) } return(plot) } As shown above and as previously demonstrated, the mitochondrial rate and the fraction of reads that mapped to genes are negatively correlated in adults but control and experimental samples are evenly distributed. ## Correlation plot for adults p &lt;- corr_plots(&quot;adults&quot;, &quot;mitoRate&quot;, &quot;totalAssignedGene&quot;, &quot;Group&quot;) p + theme(plot.margin = unit(c(2, 4, 2, 4), &quot;cm&quot;)) Altought not expected, the flowcell and the plate of the adult samples were correlated, but that is due to the fact that all samples from the first flowcell (HKCG7DSXX) were in the 1st plate, and almost all samples from the second flowcell were in the 3rd plate. p &lt;- corr_plots(&quot;adults&quot;, &quot;flowcell&quot;, &quot;plate&quot;, NULL) p + theme(plot.margin = unit(c(1.5, 4.5, 1.5, 4.5), &quot;cm&quot;)) Plate was also slightly correlated with the overall mapping rate, but if we look closely, the trend is given by the plate 1 samples that have lower rates; the rates of samples from the 2nd and 3rd plates are similar. p &lt;- corr_plots(&quot;adults&quot;, &quot;plate&quot;, &quot;overallMapRate&quot;, NULL) p + theme(plot.margin = unit(c(2, 5.3, 2, 5.3), &quot;cm&quot;)) We also appreciated and described already that the library size and the number of detected of genes are correlated in pups and adults. Note however that in pups control samples have bigger numbers of expressed genes. ## Correlation plots p &lt;- corr_plots(&quot;adults&quot;, &quot;sum&quot;, &quot;detected&quot;, &quot;Group&quot;) p + theme(plot.margin = unit(c(2, 4, 2, 4), &quot;cm&quot;)) p &lt;- corr_plots(&quot;pups&quot;, &quot;sum&quot;, &quot;detected&quot;, &quot;Group&quot;) p + theme(plot.margin = unit(c(2, 4, 2, 4), &quot;cm&quot;)) In pups, the overall mapping rate was slightly and negatively correlated with the ribosomal rate, but again controls and experimental samples are equally distributed and the rRNA_rate is pretty small for all of them. ## ## Correlation plot for pups p &lt;- corr_plots(&quot;pups&quot;, &quot;rRNA_rate&quot;, &quot;overallMapRate&quot;, &quot;Group&quot;) p + theme(plot.margin = unit(c(2, 4, 2, 4), &quot;cm&quot;)) Overall mapping rate is also positively correlated with plate and flowcell, relationships mainly given by samples from the 1st plate with the lowest overallMapRate , most of which were also in the 1st flowcell. p &lt;- corr_plots(&quot;pups&quot;, &quot;plate&quot;, &quot;overallMapRate&quot;, NULL) p + theme(plot.margin = unit(c(2, 5.3, 2, 5.3), &quot;cm&quot;)) p &lt;- corr_plots(&quot;pups&quot;, &quot;flowcell&quot;, &quot;overallMapRate&quot;, NULL) p + theme(plot.margin = unit(c(2, 5.3, 2, 5.3), &quot;cm&quot;)) Now look at the following plots. Why is it important that experimental and control samples are distributed throughout all the plates and flowcells? p1 &lt;- corr_plots(&quot;adults&quot;, &quot;Group&quot;, &quot;plate&quot;, NULL) p2 &lt;- corr_plots(&quot;pups&quot;, &quot;Group&quot;, &quot;plate&quot;, NULL) p3 &lt;- corr_plots(&quot;adults&quot;, &quot;Group&quot;, &quot;flowcell&quot;, NULL) p4 &lt;- corr_plots(&quot;pups&quot;, &quot;Group&quot;, &quot;flowcell&quot;, NULL) plots &lt;- plot_grid(p1, p2, p3, p4, ncol = 2) plots + theme(plot.margin = unit(c(1, 2.5, 1, 2.5), &quot;cm&quot;)) Hint: What would happen if all experimental samples were in one plate or flowcell and controls in another? After identifying which variables are correlated and exploring the metrics of control and experimental samples the next step is to determine which of these variables must be removed. How do we discern which of the correlated variables to keep and which to drop? As recommended in the variancePartition user’s guide [2], initially we can fit a linear model for each gene taking all sample variables and then define which ones explain a higher percentage of variance in many genes. But first let’s review how variancePartition works. 12.3.2 Fit model and extract fraction of variance explained Briefly, variancePartition fits a linear model for each gene separately and calcVarPart() computes the fraction of variance in gene expression that is explained by each variable of the study design, plus the residual variation. The effect of each variable is assessed while jointly accounting for all others [1]. Basically what it does is calculate the data variance given by each variable and that of the total model fit, summarizing the contribution of each variable in terms of the fraction of variation explained (FVE). Since it calculates the fraction of total variation attributable to each aspect of the study design, these fractions naturally sum to 1 [1]. variancePartition fits two types of models: Linear mixed model (LMM) where all categorical variables are modeled as random effects and all continuous variables are fixed effects. The function lmer() from lme4 is used to fit this model. ## Fit LMM specifying the existence of random effects with &#39;(1| )&#39; fit &lt;- lmer(expr ~ a + b + (1|c), data=data) Fixed effects model, which is basically the standard linear model (LM), where all variables are modeled as fixed effects. The function lm() is used to fit this model. ## Fit LM modeling all variables as fixed effects fit &lt;- lm(expr ~ a + b + c, data=data) In our case, the function will be modeled a mixed model since we have both effects. p.comment { background-color: #E6E6E6; padding: 10px; border: 1px solid black; margin-left: 25px; border-radius: 10px; font-family: sans-serif; } ❓What are random and fixed effects? How to determine if a variable is one or the other? Categorical variables are usually modeled as random effects, i.e., traits such as the batch, sex, flowcell, plate, individual, variables ‘randomly chosen or selected from a population’ and whose specific levels are not of particular interest, only the grouping of the samples by those variables. These are control variables/factors that vary randomly across individuals or groups and we use them because we must control for these effects. Think of them as having different effects on gene expression (the dependent variable) depending on their values. Continuous variables must be modeled as fixed effects; they cannot be modeled as random effects. These correspond to variables that can be measured somehow and whose levels are themselves of interest (the QC metrics, for instance); these effects would be the same for all genes. ❓Why is this effect distinction important? Because when we have clustered data, like gene expression values grouped by sex, plate, etc. we are violating the relevant assumption of independence, making an incorrect inference when using a general linear model (GLM). If we have clustered data where the variables’ values have distinct effects on gene expression, we must work with an extension of GLM, with the linear mixed model (LMM) that contains a mix of both fixed and random effects [3]. Linear mixed model framework 1️⃣ For a single gene, after fitting the linear model we obtain the predicted expression of the genes given by the predicted coefficients of the variables: \\(\\hat y =\\sum_{1}^j\\beta_{j}X_{j} + \\sum_{1}^k\\alpha_{k}Z_{k}\\) ← the expression of a gene across all samples is given by the samples’ values in the \\(j\\) fixed effects and \\(k\\) random effects. So basically the gene expression in the sample \\(i\\) is given by \\(\\hat y_i =\\sum_{1}^j\\beta_{j}X_{ij} + \\sum_{1}^k\\alpha_{k}Z_{ik}\\). Then \\(y=\\hat y+\\epsilon\\), which means that the real (observed) expression value is given by the predicted value plus an error term (\\(\\epsilon\\)), also called noise or residual: \\[y =\\sum_{1}^j\\beta_{j}X_{j} + \\sum_{1}^k\\alpha_{k}Z_{k} + \\epsilon\\] \\(X_j\\) is the vector of the values of the samples in the \\(j\\)th fixed effect. \\(\\beta_j\\) is the predicted coefficient of the fixed effect \\(j\\). \\[ X_j\\beta_j= \\ \\ _{n \\ \\ samples}\\stackrel{j^{th}\\ \\ fixed\\ \\ effect }{\\begin{bmatrix} X_{1j} \\\\ ... \\\\ X_{(n-1)j} \\\\ X_{nj} \\end{bmatrix}}\\beta_j = {\\begin{bmatrix} X_{1j}\\beta_j \\\\ ... \\\\ X_{(n-1)j}\\beta_j \\\\ X_{nj} \\beta_j \\end{bmatrix}} \\] \\(Z_k\\) is the vector of values the samples have for the \\(k\\)th random effect. \\(\\alpha_k\\) is the predicted coefficient of the random effect \\(k\\). These are drawn from a normal distribution \\(∼N(0, \\sigma_{\\alpha_k}^2 )\\). \\[ Z_k\\alpha_k= \\ \\ _{n \\ \\ samples}\\stackrel{{k^{th}\\ \\ random\\ \\ effect }}{\\begin{bmatrix} Z_{1k} \\\\ ... \\\\ Z_{(n-1)k}\\\\ Z_{nk} \\end{bmatrix}}\\alpha_k = {\\begin{bmatrix} Z_{1k}\\alpha_k \\\\ ... \\\\ Z_{(n-1)k}\\alpha_k\\\\ Z_{nk}\\alpha_k \\end{bmatrix}} \\] \\(\\epsilon\\) is the noise term which is \\(y-\\hat y\\), the difference between the observed and predicted expression and is also drawn from a \\(∼N(0, \\sigma_{\\epsilon}^2 )\\). Expanding, \\[ y= {\\begin{bmatrix} X_{11}\\beta_1 \\\\ ... \\\\ X_{(n-1)1}\\beta_1 \\\\ X_{n1} \\beta_1 \\end{bmatrix}} + {\\begin{bmatrix} X_{12}\\beta_2 \\\\ ... \\\\ X_{(n-1)2}\\beta_2 \\\\ X_{n2} \\beta_2 \\end{bmatrix}} + ... +{\\begin{bmatrix} X_{1j}\\beta_j \\\\ ... \\\\ X_{(n-1)j}\\beta_j \\\\ X_{nj} \\beta_j \\end{bmatrix}} + {\\begin{bmatrix} Z_{11}\\alpha_1 \\\\ ... \\\\ Z_{(n-1)1}\\alpha_1\\\\ Z_{n1}\\alpha_1 \\end{bmatrix}} +{\\begin{bmatrix} Z_{12}\\alpha_2 \\\\ ... \\\\ Z_{(n-1)2}\\alpha_2\\\\ Z_{n2}\\alpha_2 \\end{bmatrix}} \\] \\[ + ... + {\\begin{bmatrix} Z_{1k}\\alpha_k \\\\ ... \\\\ Z_{(n-1)k}\\alpha_k\\\\ Z_{nk}\\alpha_k \\end{bmatrix}} + {\\begin{bmatrix} \\epsilon_1 \\\\ ... \\\\ \\epsilon_{(n-1)} \\\\ \\epsilon_n \\end{bmatrix}} \\] All parameters are estimated with maximum likelihood, the default method in the variancePartition software when random effects are specified because it performs best in simulations. 2️⃣ Then, calcVarPart() computes for each fixed effect \\(\\sum_{i=1}^n(\\beta_{j}X_{ij}-\\bar{\\beta_{j}X_{j}})^2=var(\\beta_{j}X_{j})(n-1)\\), the squared sum of the predicted expression values of a gene in the samples (\\(i=1, ..., n\\)), only taking into account the variable \\(j\\) in the regression model: \\(\\hat y = \\beta_{j}X_{j}\\) . Each of these squared sums is scaled by the total sum of squares of the predicted values taking all fixed effects: \\(var(\\hat y)\\times (n-1)\\) and by the sum of the squared sums for all variables: \\(\\sum_1^j var(\\beta_jX_j)(n-1)\\). To simplify let’s just take the variance of the \\(j\\)th fixed effect because the squared sum is proportional to it: \\(\\sigma_{\\beta_j}^2=var(X_j{\\beta_j})\\) For random effects the variances are computed by variance component estimates with VarCorr() from nmle: The variance of the \\(k\\)th random effect is \\(\\sigma_{\\alpha_k}^2=var(Z_k{\\alpha_k})\\) After that it calculates the total variance of the expression values \\(\\sum_{i=1}^n(y_i - \\bar { y})^2=var(y)(n-1)\\), where \\(y_i = \\sum_{1}^j\\beta_{j}X_{ij} + \\sum_{1}^k\\alpha_{k}Z_{ik} + \\epsilon_i\\), considering all variables in the model and the error: The total variance is: \\(var(y)= \\sigma_{Total}^2= var(X_{1}\\beta_1)+var(X_{2}\\beta_2)+...+var(X_{j}\\beta_j)+var(Z_{1}\\alpha_1)+var(Z_{2}\\alpha_2)+...+var(Z_{k}\\alpha_k)+var(\\epsilon)=\\) \\(\\sum_1^jvar(X_j\\beta_j)+\\sum_1^kvar(Z_k\\alpha_k)+var(\\epsilon)=\\) \\(\\sigma_{Total}^2=\\sum_1^j{ \\sigma_{\\beta_j}^2} + \\sum_1^k{ \\sigma_{\\alpha_k}^2} + \\sigma_{\\epsilon}^2\\) 3️⃣ Finally, it computes: The fraction of the total data variance explained by the \\(j\\)th fixed effect is \\(\\sigma_{\\beta_j}^2\\) / \\(\\sigma_{Total}^2\\) The fraction of the total data variance explained by the \\(k\\)th random effect is \\(\\sigma_{\\alpha_k}^2\\) / \\(\\sigma_{Total}^2\\) Note that \\(y=\\hat y+\\epsilon\\) because the expression can’t be completely described by a straight line, so not all the variation of \\(y\\) can be explained by the variation of the sample variables, instead \\(var(y)=var(\\hat y)+var(\\epsilon)=var(\\hat y) + \\sigma_{\\epsilon}^2\\), where \\(\\sigma_{\\epsilon}^2=\\sum_{i=1}^n(\\hat y_i -y_i)^2/n-1\\). The residual variance is \\(\\sigma_{\\epsilon}^2\\) / \\(\\sigma_{Total}^2\\) ; this is the variance that the model couldn’t explain (we don’t know where these residuals come from). 👉🏼Source code of calcVarPart() here. Once we understood what it computes, we can use variancePartition to quantify the FVE of each variable. ## 2. Fit model ## Fit a linear mixed model (LMM) that takes continuous variables as fixed effects and categorical variables as random effects varPartAnalysis &lt;- function(age, formula) { RSE &lt;- eval(parse_expr(paste(&quot;rse_gene&quot;, age, &quot;qc&quot;, sep = &quot;_&quot;))) ## Ignore genes with variance 0 genes_var_zero &lt;- which(apply(assays(RSE)$logcounts, 1, var) == 0) if (length(genes_var_zero) &gt; 0) { RSE &lt;- RSE[-genes_var_zero, ] } ## Loop over each gene to fit model and extract variance explained by each variable varPart &lt;- fitExtractVarPartModel(assays(RSE)$logcounts, formula, colData(RSE)) # Sort variables by median fraction of variance explained vp &lt;- sortCols(varPart) p &lt;- plotVarPart(vp) return(list(p, vp)) } ## Violin plots ##### Model with all variables ##### ## Adults ## Define variables; random effects indicated with (1| ) formula &lt;- ~ (1 | Group) + (1 | Pregnancy) + (1 | plate) + (1 | flowcell) + mitoRate + overallMapRate + totalAssignedGene + rRNA_rate + sum + detected + ERCCsumLogErr # plot &lt;- varPartAnalysis(&quot;adults&quot;, formula)[[1]] # plot + theme( # plot.margin = unit(c(1, 1, 1, 1), &quot;cm&quot;), # axis.text.x = element_text(size = (7)), # axis.text.y = element_text(size = (7.5)) #) As presented above, in adults we can notice that totalAssignedGene has a larger mean FVE than mitoRate so we keep the former. Same reason to remove plate that is correlated with flowcell and with overallMapRate , and to drop sum that goes after detected . ##### Model without correlated variables ##### ## Adult plots without mitoRate, plate and sum formula &lt;- ~ (1 | Group) + (1 | Pregnancy) + (1 | flowcell) + overallMapRate + totalAssignedGene + rRNA_rate + detected + ERCCsumLogErr # varPart &lt;- varPartAnalysis(&quot;adults&quot;, formula) # varPart_data_adults &lt;- varPart[[2]] # plot &lt;- varPart[[1]] # plot + theme( # plot.margin = unit(c(1, 1, 1, 1), &quot;cm&quot;), # axis.text.x = element_text(size = (7)), # axis.text.y = element_text(size = (7.5)) #) Notwithstanding, in this new reduced model Group contribution doesn’t increment much in comparison with the complete model and also note that the % of variance explained by the residuals, i.e., the % of gene expression variance that the model couldn’t explain, increments in this model compared to the previous; by removing independent variables to a regression equation, we can explain less of the variance of the dependent variable [3]. That’s the price to pay when dropping variables but it is convenient in this case since we don’t have many samples for the model to determine their real unique contributions. In pups, based on the model with all variables, again sum must be removed, as well as rRNA_rate and plate that are correlated with overallMapRate . ##### Model with all variables ##### ## Pups formula &lt;- ~ (1 | Group) + (1 | Sex) + (1 | plate) + (1 | flowcell) + mitoRate + overallMapRate + totalAssignedGene + rRNA_rate + sum + detected + ERCCsumLogErr # plot &lt;- varPartAnalysis(&quot;pups&quot;, formula)[[1]] # plot + theme( # plot.margin = unit(c(1, 1, 1, 1), &quot;cm&quot;), # axis.text.x = element_text(size = (7)), # axis.text.y = element_text(size = (7.5)) #) Without correlated variables, Group’s contribution increases but so does the residual source. ##### Model without correlated variables ##### ## Pup plots without sum, rRNA_rate and plate formula &lt;- ~ (1 | Group) + (1 | Sex) + (1 | flowcell) + mitoRate + overallMapRate + totalAssignedGene + detected + ERCCsumLogErr # varPart &lt;- varPartAnalysis(&quot;pups&quot;, formula) # varPart_data_pups &lt;- varPart[[2]] # plot &lt;- varPart[[1]] # plot + theme( # plot.margin = unit(c(1, 1, 1, 1), &quot;cm&quot;), # axis.text.x = element_text(size = (7)), # axis.text.y = element_text(size = (7.5)) #) But what does it mean that a variable explains a high percentage of the expression variation of a gene? Look at the following plots and try the function with other variables to observe the relationships that exists between the gene expression values in the samples and samples’ variables. 12.3.3 Examine expression of most affected genes by each sample variable In the following plots you can appreciate the expression values in the samples of the most affected genes by a certain variable (i.e., the genes for which the variable explains the highest percentages of variance) vs. the values of the samples for the same variable. In simple words, each dot is a sample, in the y-axis the expression of the gene in each sample and in the x-axis the samples’ values for the variable. The idea is to observe the strong relationships that exists for the sample variables and the gene expression of such affected genes, which ends up causing the variables to explain high percentages of gene expression variation and which obligate us to adjust for them the models of DEA so that we don´t get DEGs driven by sample quality differences. ## Plot of gene expression lognorm counts vs. sample variable plot_gene_expr &lt;- function(age, sample_var, gene_id) { rse_gene &lt;- eval(parse_expr(paste(&quot;rse_gene&quot;, age, &quot;qc&quot;, sep = &quot;_&quot;))) varPart_data &lt;- eval(parse_expr(paste0(&quot;varPart_data_&quot;, age))) colors &lt;- list( &quot;Group&quot; = c(&quot;Control&quot; = &quot;brown2&quot;, &quot;Experimental&quot; = &quot;deepskyblue3&quot;), &quot;Age&quot; = c(&quot;Adult&quot; = &quot;slateblue3&quot;, &quot;Pup&quot; = &quot;yellow3&quot;), &quot;Sex&quot; = c(&quot;F&quot; = &quot;hotpink1&quot;, &quot;M&quot; = &quot;dodgerblue&quot;), &quot;Pregnancy&quot; = c(&quot;Yes&quot; = &quot;darkorchid3&quot;, &quot;No&quot; = &quot;darkolivegreen4&quot;), &quot;plate&quot; = c(&quot;Plate1&quot; = &quot;darkorange&quot;, &quot;Plate2&quot; = &quot;lightskyblue&quot;, &quot;Plate3&quot; = &quot;deeppink1&quot;), &quot;flowcell&quot; = c( &quot;HKCG7DSXX&quot; = &quot;chartreuse2&quot;, &quot;HKCMHDSXX&quot; = &quot;magenta&quot;, &quot;HKCNKDSXX&quot; = &quot;turquoise3&quot;, &quot;HKCTMDSXX&quot; = &quot;tomato&quot; ) ) ## Lognorm counts of the gene across samples data &lt;- colData(rse_gene) data$gene_expr &lt;- assays(rse_gene)$logcounts[gene_id, ] ## Percentage of variance explained by the variable percentage &lt;- 100 * signif(varPart_data[gene_id, sample_var], digits = 3) ## Boxplots for discrete variables if (class(data[, sample_var]) == &quot;character&quot;) { plot &lt;- ggplot(data = as.data.frame(data), mapping = aes( x = !!rlang::sym(sample_var), y = gene_expr, color = !!rlang::sym(sample_var) )) + geom_boxplot(size = 0.25, width = 0.32, color = &quot;black&quot;, outlier.color = &quot;#FFFFFFFF&quot;) + geom_jitter(width = 0.15, alpha = 1, size = 1) + stat_smooth(geom = &quot;line&quot;, alpha = 0.6, size = 0.4, span = 0.3, method = lm, aes(group = 1), color = &quot;orangered3&quot;) + scale_color_manual(values = colors[[sample_var]]) + theme_bw() + guides(color = &quot;none&quot;) + labs( title = gene_id, subtitle = paste0(&quot;Variance explained: &quot;, percentage, &quot;%&quot;), y = &quot;lognorm counts&quot;, x = sample_var ) + theme( axis.title = element_text(size = (7)), axis.text = element_text(size = (6)), plot.title = element_text(hjust = 0.5, size = 7.5, face = &quot;bold&quot;), plot.subtitle = element_text(size = 7, color = &quot;gray40&quot;), legend.text = element_text(size = 6), legend.title = element_text(size = 7) ) } ## Scatterplots for continuous variables else { colors &lt;- c( &quot;mitoRate&quot; = &quot;khaki3&quot;, &quot;overallMapRate&quot; = &quot;turquoise&quot;, &quot;totalAssignedGene&quot; = &quot;plum2&quot;, &quot;rRNA_rate&quot; = &quot;orange3&quot;, &quot;sum&quot; = &quot;palegreen3&quot;, &quot;detected&quot; = &quot;skyblue2&quot;, &quot;ERCCsumLogErr&quot; = &quot;slateblue1&quot; ) plot &lt;- ggplot(as.data.frame(data), aes(x = eval(parse_expr(sample_var)), y = gene_expr)) + geom_point(color = colors[[sample_var]], size = 2) + stat_smooth(geom = &quot;line&quot;, alpha = 0.4, size = 0.4, span = 0.25, method = lm, color = &quot;orangered3&quot;) + theme_bw() + guides(color = &quot;none&quot;) + labs( title = gene_id, subtitle = paste0(&quot;Variance explained: &quot;, percentage, &quot;%&quot;), y = &quot;lognorm counts&quot;, x = gsub(&quot;_&quot;, &quot; &quot;, sample_var) ) + theme( plot.margin = unit(c(0.4, 0.1, 0.4, 0.1), &quot;cm&quot;), axis.title = element_text(size = (7)), axis.text = element_text(size = (6)), plot.title = element_text(hjust = 0.5, size = 7.5, face = &quot;bold&quot;), plot.subtitle = element_text(size = 7, color = &quot;gray40&quot;), legend.text = element_text(size = 6), legend.title = element_text(size = 7) ) } return(plot) } ## Function to plot gene expression vs sample variable data for top 3 most affected genes plot_gene_expr_sample &lt;- function(age, sample_var) { rse_gene &lt;- eval(parse_expr(paste(&quot;rse_gene&quot;, age, &quot;qc&quot;, sep = &quot;_&quot;))) varPart_data &lt;- eval(parse_expr(paste0(&quot;varPart_data_&quot;, age))) ## Top 3 genes most affected by sample variable affected_genes &lt;- rownames(varPart_data[order(varPart_data[, sample_var], decreasing = TRUE), ][1:3, ]) ## Plots plots &lt;- list() for (i in 1:length(affected_genes)) { plots[[i]] &lt;- plot_gene_expr(age, sample_var, affected_genes[i]) } plot_grid(plots[[1]], plots[[2]], plots[[3]], ncol = 3) } ## Adults ## Plots for top affected genes by &#39;totalAssignedGene&#39; # plots &lt;- plot_gene_expr_sample(&quot;adults&quot;, &quot;totalAssignedGene&quot;) # plots + theme(plot.margin = unit(c(3, 1, 2, 3), &quot;cm&quot;)) ## Plots for top affected genes by &#39;overallMapRate&#39; # plots &lt;- plot_gene_expr_sample(&quot;adults&quot;, &quot;overallMapRate&quot;) # plots + theme(plot.margin = unit(c(3, 1, 2, 3), &quot;cm&quot;)) ## Plots for top affected genes by &#39;Group&#39; # plots &lt;- plot_gene_expr_sample(&quot;adults&quot;, &quot;Group&quot;) # plots + theme(plot.margin = unit(c(3, 1, 2, 3), &quot;cm&quot;)) ## Pups # ## Plots for top affected genes by &#39;overallMapRate&#39; # plots &lt;- plot_gene_expr_sample(&quot;pups&quot;, &quot;overallMapRate&quot;) # plots + theme(plot.margin = unit(c(3, 1, 2, 3), &quot;cm&quot;)) # # ## Plots for top affected genes by &#39;totalAssignedGene&#39; # plots &lt;- plot_gene_expr_sample(&quot;pups&quot;, &quot;totalAssignedGene&quot;) # plots + theme(plot.margin = unit(c(3, 1, 2, 3), &quot;cm&quot;)) # # ## Plots for top affected genes by &#39;Group&#39; # plots &lt;- plot_gene_expr_sample(&quot;pups&quot;, &quot;Group&quot;) # plots + theme(plot.margin = unit(c(3, 1, 2, 3), &quot;cm&quot;)) p.exercise { background-color: #E4EDE2; padding: 10px; border: 1px solid black; border-radius: 5px; font-family: sans-serif; } 📑 Exercise 1: What % of variance does Group explain for gene ENSMUSG00000042348.10 in pups? Create the boxplots for its counts in control and experimental samples. Is it more likely that the gene is upregulated or downregulated? 📑 Exercise 2: Do the same for gene ENSMUSG00000064372.1. What do you observe in terms of variance percentage and sample differences? 12.4 Solutions 12.4.1 Exercise 1 # ## Solution # # ## Gene ID # gene_id &lt;- &quot;ENSMUSG00000042348.10&quot; # ## % of variance explained by Group # percentage &lt;- 100 * signif(varPart_data_pups[gene_id, &quot;Group&quot;], digits = 3) # ## Sample colors # colors &lt;- c(&quot;Control&quot; = &quot;brown2&quot;, &quot;Experimental&quot; = &quot;deepskyblue3&quot;) # ## Gene expression logcounts # rse_gene_pups_qc$gene_expr &lt;- assays(rse_gene_pups_qc)$logcounts[gene_id, ] # # ## Plot # plot &lt;- ggplot( # data = as.data.frame(colData(rse_gene_pups_qc)), # mapping = aes(x = Group, y = gene_expr, color = Group) # ) + # geom_boxplot(size = 0.25, width = 0.32, color = &quot;black&quot;, outlier.color = &quot;#FFFFFFFF&quot;) + # geom_jitter(width = 0.15, alpha = 1, size = 1) + # scale_color_manual(values = colors) + # theme_bw() + # guides(color = &quot;none&quot;) + # labs( # title = gene_id, # subtitle = paste0(&quot;Variance explained: &quot;, percentage, &quot;%&quot;), # y = &quot;lognorm counts&quot; # ) + # theme( # plot.margin = unit(c(2, 6, 2, 6), &quot;cm&quot;), # axis.title = element_text(size = (7)), # axis.text = element_text(size = (6)), # plot.title = element_text(hjust = 0.5, size = 7.5, face = &quot;bold&quot;), # plot.subtitle = element_text(size = 7, color = &quot;gray40&quot;), # legend.text = element_text(size = 6), # legend.title = element_text(size = 7) # ) # # plot 12.4.2 Exercise 2 # ## Solution # # ## Gene ID # gene_id &lt;- &quot;ENSMUSG00000064372.1&quot; # ## % of variance explained by Group # percentage &lt;- 100 * signif(varPart_data_pups[gene_id, &quot;Group&quot;], digits = 3) # ## Sample colors # colors &lt;- c(&quot;Control&quot; = &quot;brown2&quot;, &quot;Experimental&quot; = &quot;deepskyblue3&quot;) # ## Gene expression logcounts # rse_gene_pups_qc$gene_expr &lt;- assays(rse_gene_pups_qc)$logcounts[gene_id, ] # # ## Plot # plot &lt;- ggplot( # data = as.data.frame(colData(rse_gene_pups_qc)), # mapping = aes(x = Group, y = gene_expr, color = Group) # ) + # geom_boxplot(size = 0.25, width = 0.32, color = &quot;black&quot;, outlier.color = &quot;#FFFFFFFF&quot;) + # geom_jitter(width = 0.15, alpha = 1, size = 1) + # scale_color_manual(values = colors) + # theme_bw() + # guides(color = &quot;none&quot;) + # labs( # title = gene_id, # subtitle = paste0(&quot;Variance explained: &quot;, percentage, &quot;%&quot;), # y = &quot;lognorm counts&quot; # ) + # theme( # plot.margin = unit(c(2, 6, 2, 6), &quot;cm&quot;), # axis.title = element_text(size = (7)), # axis.text = element_text(size = (6)), # plot.title = element_text(hjust = 0.5, size = 7.5, face = &quot;bold&quot;), # plot.subtitle = element_text(size = 7, color = &quot;gray40&quot;), # legend.text = element_text(size = 6), # legend.title = element_text(size = 7) # ) # # plot References Hoffman, G. E., &amp; Schadt, E. E. (2016). variancePartition: interpreting drivers of variation in complex gene expression studies.BMC bioinformatics, 17(1), 1-13. Hoffman, G. (2022). variancePartition: Quantifying and interpreting drivers of variation in multilevel gene expression experiments. van den Berg, S. M. (2022). Analysing data using linear models. Web site: https://bookdown.org/pingapang9/linear_models_bookdown/ "],["expression-heatmaps-with-complexheatmap.html", "13 Expression heatmaps with ComplexHeatmap 13.1 Introduction 13.2 ComplexHeatmap 13.3 Heatmap with expression data", " 13 Expression heatmaps with ComplexHeatmap Instructor: Renee Congrats to @rodriguez_lion - final chapter of his PhD thesis - as well as co-1st author @mattntran, and @SubmarineGene who joined the project late, but was invaluable to getting it finished, and much thanks to @CerceoPage @lcolladotor for co-supervising! — Keri Martinowich (@martinowk) July 3, 2023 13.1 Introduction Heatmaps are efficient to visualize associations between different sources of data sets and reveal potential patterns (e.g. patterns of expression in your genes). There are multiple packages in R that allow you to create heatmaps, the most widely use include: ggplot2 heatmaps pheatmap ComplexHeatmap All of these are good and useful, but adding extra information to your heatmaps can get really messy depending on the package you are using. For example, in the next heatmap we are showing the expression of marker genes in multiple cell types. The columns are separated by the group from which they are markers. Then the rows (cell types), have two different classifications: group and Population, plus a barplot that shows the number of nuclei that cell type contains. 13.2 ComplexHeatmap The ComplexHeatmap package provides a highly flexible way to arrange multiple heatmaps and supports self-defined annotation graphics.The ComplexHeatmap package is implemented in an object-oriented way. To describe a heatmap list, there are following classes: Heatmap class: a single heatmap containing heatmap body, row/column names, titles, dendrograms and row/column annotations. HeatmapAnnotation class: defines a list of row annotations and column annotations. The heatmap annotations can be components of heatmap, also they can be independent as heatmaps. p.exercise { background-color: #E4EDE2; padding: 9px; border: 1px solid black; border-radius: 10px; font-family: sans-serif; } Exercise 1: Explore the Bioconductor page for this package, go to the vignette and find a function that would allow you to add the barplot on the right side of the heatmap previously shown. 13.3 Heatmap with expression data Now, we are gonna make our own heatmap with the SmokingMouse data. In this heatmap we want to see the difference of expression between both Control and Experimental for all the DEG in Pup, as well as the Sex of the samples and the FDR of the genes. Let’s download and prepare our data first. 13.3.1 Download data library(&quot;SummarizedExperiment&quot;) library(&quot;ComplexHeatmap&quot;) library(&quot;circlize&quot;) ## Download and cache the file library(&quot;BiocFileCache&quot;) bfc &lt;- BiocFileCache::BiocFileCache() cached_rse_gene &lt;- BiocFileCache::bfcrpath( x = bfc, &quot;https://github.com/LieberInstitute/SPEAQeasyWorkshop2023/raw/devel/provisional_data/rse_gene_mouse_RNAseq_nic-smo.Rdata&quot; ) ## Check the local path on our cache cached_rse_gene #&gt; BFC2 #&gt; &quot;/github/home/.cache/R/BiocFileCache/107d14e54709_rse_gene_mouse_RNAseq_nic-smo.Rdata&quot; ## Load the rse_gene object load(cached_rse_gene, verbose = TRUE) #&gt; Loading objects: #&gt; rse_gene ## General overview of the object rse_gene #&gt; class: RangedSummarizedExperiment #&gt; dim: 55401 208 #&gt; metadata(1): Obtained_from #&gt; assays(2): counts logcounts #&gt; rownames(55401): ENSMUSG00000102693.1 ENSMUSG00000064842.1 ... ENSMUSG00000064371.1 ENSMUSG00000064372.1 #&gt; rowData names(13): Length gencodeID ... DE_in_pup_brain_nicotine DE_in_pup_brain_smoking #&gt; colnames: NULL #&gt; colData names(71): SAMPLE_ID FQCbasicStats ... retained_after_QC_sample_filtering #&gt; retained_after_manual_sample_filtering 13.3.2 Prepare the data ## Extract genes and samples of interest rse_gene_pup_nic &lt;- rse_gene[ rowData(rse_gene)$DE_in_pup_brain_nicotine == TRUE, rse_gene$Age == &quot;Pup&quot; &amp; rse_gene$Expt == &quot;Nicotine&quot; ] ## Extract logcounts and add name columns logs_pup_nic &lt;- assay(rse_gene_pup_nic, 2) colnames(logs_pup_nic) &lt;- paste0(&quot;Pup_&quot;, 1:dim(rse_gene_pup_nic)[2]) ## Create function to remove technical variables&#39; contributions, ## this is from jaffelab package (https://github.com/LieberInstitute/jaffelab) cleaningY &lt;- function(y, mod, P) { stopifnot(P &lt;= ncol(mod)) stopifnot(`Input matrix is not full rank` = qr(mod)$rank == ncol(mod)) Hat &lt;- solve(t(mod) %*% mod) %*% t(mod) ty &lt;- t(y) ty[is.na(ty)] &lt;- 0 beta &lt;- (Hat %*% ty) cleany &lt;- y - t(as.matrix(mod[, -c(seq_len(P))]) %*% beta[-seq_len(P), ]) return(cleany) } ## Remove contribution of technical variables formula &lt;- ~ Group + Sex + plate + flowcell + rRNA_rate + totalAssignedGene + ERCCsumLogErr + overallMapRate + mitoRate model &lt;- model.matrix(formula, data = colData(rse_gene_pup_nic)) logs_pup_nic &lt;- cleaningY(logs_pup_nic, model, P = 2) ## Center the data to make differences more evident logs_pup_nic &lt;- (logs_pup_nic - rowMeans(logs_pup_nic)) / rowSds(logs_pup_nic) More for on centering and scaling, see this video: 13.3.3 Create annotations ## Prepare annotation for our heatmap ## For this heatmap I want to be able to see the Group to which each sample belongs ## as well as the Sex of the pup top_ans &lt;- HeatmapAnnotation( df = as.data.frame(colData(rse_gene_pup_nic)[, c(&quot;Sex&quot;, &quot;Group&quot;)]), col = list( &quot;Sex&quot; = c(&quot;F&quot; = &quot;hotpink1&quot;, &quot;M&quot; = &quot;dodgerblue&quot;), &quot;Group&quot; = c(&quot;Control&quot; = &quot;brown2&quot;, &quot;Experimental&quot; = &quot;deepskyblue3&quot;) ) ) ## Also, I want to add the FDR associated to each gene ## Even though we do have that data, for this particular exercise we are gonna simulate it rowData(rse_gene_pup_nic)$FDR &lt;- sample( x = 0:5000, size = dim(rse_gene_pup_nic)[1], prob = c(rep(0.0012, 1001), rep(0.00005, 4000)) ) / 10000 left_ans &lt;- rowAnnotation( FDR = rowData(rse_gene_pup_nic)$FDR, col = list(FDR = colorRamp2(c(0, 0.049), c(&quot;#ecf39e&quot;, &quot;#4f772d&quot;))), annotation_legend_param = list(FDR = list(at = c(0, 0.01, 0.02, 0.03, 0.04, 0.05))) ) 13.3.4 Plot our heatmap ## Finally, let&#39;s plot! Heatmap(logs_pup_nic, name = &quot;logcounts&quot;, show_row_names = FALSE, top_annotation = top_ans, left_annotation = left_ans, row_km = 2, column_km = 2, col = colorRamp2(c(-4, -0.0001, 00001, 4), c(&quot;darkblue&quot;, &quot;lightblue&quot;, &quot;lightsalmon&quot;, &quot;darkred&quot;)), row_title = NULL, column_title = NULL, column_names_gp = gpar(fontsize = 7) ) Exercise 2: a) Add a barplot as a topAnnotation with the library sizes (sum) of each sample. Fill the bars with the color of your choice b) Classify the genes according to whether they are proteing_coding or not (not_proteing_coding). "],["complexheatmap-exercise-solution.html", "14 ComplexHeatmap exercise solution", " 14 ComplexHeatmap exercise solution ## For a) we need to use he function anno_barplot() to generate the barplot and gpar() to fill the bars top_ans &lt;- HeatmapAnnotation( df = as.data.frame(colData(rse_gene_pup_nic)[, c(&quot;Sex&quot;, &quot;Group&quot;)]), library_size = anno_barplot(colData(rse_gene_pup_nic)$sum, gp = gpar(fill = &quot;#ffd500&quot;)), col = list( &quot;Sex&quot; = c(&quot;F&quot; = &quot;hotpink1&quot;, &quot;M&quot; = &quot;dodgerblue&quot;), &quot;Group&quot; = c(&quot;Control&quot; = &quot;brown2&quot;, &quot;Experimental&quot; = &quot;deepskyblue3&quot;) ) ) ## For b), I want to know if a gene is protein_coding or not_protein_coding. ## First, we can explore the rowData of our object to see if we have a column with ## that information names(rowData(rse_gene_pup_nic)) #&gt; [1] &quot;Length&quot; &quot;gencodeID&quot; &quot;ensemblID&quot; #&gt; [4] &quot;gene_type&quot; &quot;EntrezID&quot; &quot;Symbol&quot; #&gt; [7] &quot;meanExprs&quot; &quot;retained_after_feature_filtering&quot; &quot;DE_in_adult_blood_smoking&quot; #&gt; [10] &quot;DE_in_adult_brain_nicotine&quot; &quot;DE_in_adult_brain_smoking&quot; &quot;DE_in_pup_brain_nicotine&quot; #&gt; [13] &quot;DE_in_pup_brain_smoking&quot; &quot;FDR&quot; ## Maybe gene_type has what we need unique(rowData(rse_gene_pup_nic)$gene_type) #&gt; [1] &quot;sense_intronic&quot; &quot;protein_coding&quot; &quot;antisense&quot; #&gt; [4] &quot;processed_transcript&quot; &quot;unprocessed_pseudogene&quot; &quot;processed_pseudogene&quot; #&gt; [7] &quot;TEC&quot; &quot;transcribed_processed_pseudogene&quot; &quot;lincRNA&quot; #&gt; [10] &quot;transcribed_unitary_pseudogene&quot; &quot;snoRNA&quot; &quot;polymorphic_pseudogene&quot; #&gt; [13] &quot;transcribed_unprocessed_pseudogene&quot; &quot;bidirectional_promoter_lncRNA&quot; ## It does but not in the format we need it, so we need to create a new column to complete the task ## This columns is going to have protein_coding and not_protein_coding as elements rowData(rse_gene_pup_nic)$pc_status &lt;- &quot;protein_coding&quot; rowData(rse_gene_pup_nic)$pc_status[rowData(rse_gene_pup_nic)$gene_type != &quot;protein_coding&quot;] &lt;- &quot;not_protein_coding&quot; ## Now we can add the information and specify the color left_ans &lt;- rowAnnotation( FDR = sample(x = 0:5000, size = dim(rse_gene_pup_nic)[1], prob = c(rep(0.0012, 1001), rep(0.00005, 4000))) / 10000, pc_status = rowData(rse_gene_pup_nic)$pc_status, col = list(FDR = colorRamp2(c(0, 0.049), c(&quot;#ecf39e&quot;, &quot;#4f772d&quot;)), pc_status = c(&quot;not_protein_coding&quot; = &quot;#ffe5d9&quot;, &quot;protein_coding&quot; = &quot;#9d8189&quot;)), annotation_legend_param = list(FDR = list(at = c(0, 0.01, 0.02, 0.03, 0.04, 0.05))) ) Heatmap(logs_pup_nic, name = &quot; &quot;, show_row_names = FALSE, top_annotation = top_ans, left_annotation = left_ans, row_km = 2, column_km = 2, col = colorRamp2(c(-4, -0.0001, 00001, 4), c(&quot;darkblue&quot;, &quot;lightblue&quot;, &quot;lightsalmon&quot;, &quot;darkred&quot;)), row_title = NULL, column_title = NULL, column_names_gp = gpar(fontsize = 7) ) "],["exercise-with-variancepartition-and-complexheatmap.html", "15 Exercise with variancePartition and ComplexHeatmap 15.1 Steps:", " 15 Exercise with variancePartition and ComplexHeatmap Instructors: Daianna and Renee Now is your turn to work on variance partition analysis and to create heatmaps to visualize expression patterns of DEGs. With the same dataset that you have (rse_gene) perform the the variance partition analysis with smoking data for pups (i.e., taking pup samples from the smoking experiment) just as we did with nicotine data. 15.1 Steps: Subset the complete rse_gene object to smoking and pup data only. Assume that all smoking pup samples are high quality and use them all for the variance partition analysis. Use fitExtractVarPartModel() to fit a model for each gene and extract the variance explained by each variable; do it with normalized counts. Which variables contribute more to gene expression changes? Which ones should be included in the models for DEA? Why? Now select DEGs (for the smoking experiment) only. Create heatmaps to visualize the expression of these genes. Is it enough to use normalized counts directly from assays(rse_gene_smoking)$logcounts? Why? Is there any clustering of the samples by Group or any other sample variable? Separate upregulated and downregulated DEGs (by logFC) and create their individual heatmaps. What do you observe? "],["miscellaneous.html", "16 Miscellaneous 16.1 postcards 16.2 Organizing your work", " 16 Miscellaneous Instructor: Leo 16.1 postcards The above video is in Spanish. Similar to https://pages.github.com/ postcards has 5 templates https://github.com/seankross/postcards Your website should ideally say something about you, your interests, your projects, and how to contact you. Here are some examples with their source code: https://amy-peterson.github.io/ + https://github.com/amy-peterson/amy-peterson.github.com http://jtleek.com/ + https://github.com/jtleek/jtleek.github.io http://aejaffe.com/ + https://github.com/andrewejaffe/andrewejaffe.github.io https://hadley.nz/ + https://github.com/hadley/hadley.github.com https://emarquezz.github.io/ + https://github.com/emarquezz/emarquezz.github.io https://bpardo99.github.io/ + https://github.com/bpardo99/bpardo99.github.io https://daianna21.github.io/ + https://github.com/daianna21/daianna21.github.io https://reneegf.github.io/ + https://github.com/reneegf/reneegf.github.io ## Create an RStudio project first with this particular name usethis::create_project(&quot;~/Desktop/YourGitHubUsername.github.io&quot;) ## Configure Git and GitHub ## If you don&#39;t have git, check &quot;Happy Git and GitHub for the useR&quot; available ## at https://happygitwithr.com/ usethis::use_git() usethis::use_github() Create your website template using postcards by choosing one of the options below. This will create an index.Rmd file. ## Choose only one of these options, whichever you liked the most postcards::create_postcard(template = &quot;jolla&quot;) postcards::create_postcard(template = &quot;jolla-blue&quot;) postcards::create_postcard(template = &quot;trestles&quot;) postcards::create_postcard(template = &quot;onofre&quot;) postcards::create_postcard(template = &quot;solana&quot;) Fill out your information using Markdown syntax. For example: https://github.com/andrewejaffe/andrewejaffe.github.io/blob/819141c6dca6205d04eabb3d15f36cdd79742766/index.Rmd#L17-L33. Add links to your own profiles like at https://github.com/andrewejaffe/andrewejaffe.github.io/blob/819141c6dca6205d04eabb3d15f36cdd79742766/index.Rmd#L4-L12. Click the knit blue button on RStudio. This is the same as running rmarkdown::render(\"index.Rmd\") on the console. This will create the index.html file. Make a git commit to save your new files including index.html and then git push to upload your files to GitHub. You will soon have a publicly website available at https://YourGitHubUsername.github.io/ Feel free to keep editing your website. Remember to knit, then git add + git commit the new versions of your files, then git push to upload them to GitHub. If you want to, use fontawesome like at https://github.com/emarquezz/emarquezz.github.io/blob/c49eae75d53efa623e5d3bbbb29d77a3f1678a1c/index.Rmd#L7 or emojis like at https://github.com/emarquezz/emarquezz.github.io/blob/c49eae75d53efa623e5d3bbbb29d77a3f1678a1c/index.Rmd#L24. Share your website and source code through the random Slack channel. (optional) Announce your new website using the #rstats hasthag and/or the author of postcards https://twitter.com/seankross. 16.2 Organizing your work https://here.r-lib.org/ here is a great package for avoiding hard coded (full paths) to files. LIBD rstats club notes https://lcolladotor.github.io/bioc_team_ds/organizing-your-work.html My team’s documentation on how to organize our work. https://github.com/LieberInstitute/template_project Here’s our template for how to organize code in a new project. By using a uniform organization, we make it easier for all of us to understand where code lives. This in turn makes it easier to adapt and re-use code across projects. Along the way we figured out how to organize our code https://t.co/1KuhHGxLGCThis structure helped collaborators join the project within the last months, understand our code base, and make 🤩 contributionshttps://t.co/IbjHZUi92d — 🇲🇽 Leonardo Collado-Torres (@lcolladotor) February 17, 2023 https://lcolladotor.github.io/bioc_team_ds/how-to-ask-for-help.html Some of my team’s guidelines for how to ask for help "],["introduction-to-the-world-of-spatially-resolved-transcriptomics-with-visium-data.html", "17 Introduction to the world of spatially-resolved transcriptomics with Visium data 17.1 Community", " 17 Introduction to the world of spatially-resolved transcriptomics with Visium data Instructor: Leo Thank you #GBD23 @MinaRyten @LabGandhi John Hardy 🇬🇧 for hosting us!🙌🏽Hopefully our #deconvochallenge #spatialLIBD #spatialDLPFC #Visium_SPG_AD work + @Bioconductor 📦s + @10xGenomics @LieberInstitute data will be useful to you@eventsWCS @UCLchildhealth @TheCrick @UCLIoN @ucl pic.twitter.com/vJcpL4tcQK — 🇲🇽 Leonardo Collado-Torres (@lcolladotor) May 25, 2023 SummarizedExperiment –&gt; SingleCellExperiment –&gt; SpatialExperiment –&gt; spatialLIBD 17.1 Community Are you analyzing spatially-resolved transcriptomics data? Visium from @10xGenomics? You might want to use #SpatialExperiment which provides a common infrastructure fully compatible with @Bioconductor's ecosystem #rstatsMore details? Open access paper 📜https://t.co/4Y2RN4Wz2z https://t.co/49wE5Dv5HF pic.twitter.com/QpI4lvCF2r — 🇲🇽 Leonardo Collado-Torres (@lcolladotor) April 29, 2022 Our paper describing our package #spatialLIBD is finally out! 🎉🎉🎉spatialLIBD is an #rstats / @Bioconductor package to visualize spatial transcriptomics data.⁰This is especially exciting for me as it is my first paper as a first author 🦑.https://t.co/COW013x4GA1/9 pic.twitter.com/xevIUg3IsA — Brenda Pardo (@PardoBree) April 30, 2021 "],["downloading-public-visium-spatial-data-and-visualizing-it-with-spatiallibd.html", "18 Downloading public Visium spatial data and visualizing it with spatialLIBD 18.1 Download data from 10x Genomics 18.2 Add gene annotation information 18.3 Wrapper functions for reading the data 18.4 Visualize spatial plots 18.5 Exercise", " 18 Downloading public Visium spatial data and visualizing it with spatialLIBD Instructor: Leo 18.1 Download data from 10x Genomics We’ll run some code adapted from http://research.libd.org/spatialLIBD/articles/TenX_data_download.html (also available at https://bioconductor.org/packages/devel/data/experiment/vignettes/spatialLIBD/inst/doc/TenX_data_download.html). We’ll explore spatially resolved transcriptomics data from the Visium platform by 10x Genomics. We’ll use BiocFileCache to keep the data in a local cache in case we want to run this example again and don’t want to re-download the data from the web. ## Download and save a local cache of the data provided by 10x Genomics bfc &lt;- BiocFileCache::BiocFileCache() lymph.url &lt;- paste0( &quot;https://cf.10xgenomics.com/samples/spatial-exp/&quot;, &quot;1.1.0/V1_Human_Lymph_Node/&quot;, c( &quot;V1_Human_Lymph_Node_filtered_feature_bc_matrix.tar.gz&quot;, &quot;V1_Human_Lymph_Node_spatial.tar.gz&quot;, &quot;V1_Human_Lymph_Node_analysis.tar.gz&quot; ) ) lymph.data &lt;- sapply(lymph.url, BiocFileCache::bfcrpath, x = bfc) #&gt; adding rname &#39;https://cf.10xgenomics.com/samples/spatial-exp/1.1.0/V1_Human_Lymph_Node/V1_Human_Lymph_Node_filtered_feature_bc_matrix.tar.gz&#39; #&gt; adding rname &#39;https://cf.10xgenomics.com/samples/spatial-exp/1.1.0/V1_Human_Lymph_Node/V1_Human_Lymph_Node_spatial.tar.gz&#39; #&gt; adding rname &#39;https://cf.10xgenomics.com/samples/spatial-exp/1.1.0/V1_Human_Lymph_Node/V1_Human_Lymph_Node_analysis.tar.gz&#39; 10x Genomics provides the files in compressed tarballs (.tar.gz file extension). Which is why we’ll need to use utils::untar() to decompress the files. This will create new directories and we will use list.files() to see what files these directories contain. ## Extract the files to a temporary location ## (they&#39;ll be deleted once you close your R session) xx &lt;- sapply(lymph.data, utils::untar, exdir = file.path(tempdir(), &quot;outs&quot;)) ## The names are the URLs, which are long and thus too wide to be shown here, ## so we shorten them to only show the file name prior to displaying the ## utils::untar() output status names(xx) &lt;- basename(names(xx)) xx #&gt; V1_Human_Lymph_Node_filtered_feature_bc_matrix.tar.gz.BFC4 V1_Human_Lymph_Node_spatial.tar.gz.BFC5 #&gt; 0 0 #&gt; V1_Human_Lymph_Node_analysis.tar.gz.BFC6 #&gt; 0 ## List the files we downloaded and extracted ## These files are typically SpaceRanger outputs lymph.dirs &lt;- file.path( tempdir(), &quot;outs&quot;, c(&quot;filtered_feature_bc_matrix&quot;, &quot;spatial&quot;, &quot;raw_feature_bc_matrix&quot;, &quot;analysis&quot;) ) list.files(lymph.dirs) #&gt; [1] &quot;aligned_fiducials.jpg&quot; &quot;barcodes.tsv.gz&quot; &quot;clustering&quot; &quot;detected_tissue_image.jpg&quot; #&gt; [5] &quot;diffexp&quot; &quot;features.tsv.gz&quot; &quot;matrix.mtx.gz&quot; &quot;pca&quot; #&gt; [9] &quot;scalefactors_json.json&quot; &quot;tissue_hires_image.png&quot; &quot;tissue_lowres_image.png&quot; &quot;tissue_positions_list.csv&quot; #&gt; [13] &quot;tsne&quot; &quot;umap&quot; 18.2 Add gene annotation information These files do not include much information about the genes, such as their chromosomes, coordinates, and other gene annotation information. We thus recommend that you read in this information from a gene annotation file: typically a gtf file. For a real case scenario, you’ll mostly likely have access to the GTF file provided by 10x Genomics. However, we cannot download that file without downloading other files for this example. 18.2.1 From 10x Depending on the version of spaceranger you used, you might have used different GTF files 10x Genomics has made available at https://support.10xgenomics.com/single-cell-gene-expression/software/downloads/latest and described at https://support.10xgenomics.com/single-cell-gene-expression/software/release-notes/build. These files are too big though and we won’t download them in this example. For instance, References - 2020-A (July 7, 2020) for Human reference (GRCh38) is 11 GB in size and contains files we do not need here. If you did have the file locally, we would just need the path to this GTF file later. For example, in our computing cluster this GTF file is located at the following path and is 1.4 GB in size: $ cd /dcs04/lieber/lcolladotor/annotationFiles_LIBD001/10x/refdata-gex-GRCh38-2020-A $ du -sh --apparent-size genes/genes.gtf 1.4G genes/genes.gtf 18.2.2 From Gencode In the absence of the GTF file used by 10x Genomics, we’ll use the GTF file from Gencode v32 which we can download and that is much smaller. That’s because the build notes from References - 2020-A (July 7, 2020) and Human reference, GRCh38 (GENCODE v32/Ensembl 98) at https://support.10xgenomics.com/single-cell-gene-expression/software/release-notes/build#GRCh38_2020A show that 10x Genomics used Gencode v32. They also used Ensembl version 98 which is why a few genes we have in our object are going to be missing. Let’s download this GTF file. ## Download the Gencode v32 GTF file and cache it gtf_cache &lt;- BiocFileCache::bfcrpath( bfc, paste0( &quot;ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/&quot;, &quot;release_32/gencode.v32.annotation.gtf.gz&quot; ) ) #&gt; adding rname &#39;ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_32/gencode.v32.annotation.gtf.gz&#39; ## Show the GTF cache location gtf_cache #&gt; BFC7 #&gt; &quot;/github/home/.cache/R/BiocFileCache/107d72ef9761_gencode.v32.annotation.gtf.gz&quot; 18.3 Wrapper functions for reading the data To facilitate reading in the data and preparing it to visualize it interactively using spatialLIBD::run_app(), we implemented read10xVisiumWrapper() which expands SpatialExperiment::read10xVisium() and performs the steps described in more detail at http://research.libd.org/spatialLIBD/articles/TenX_data_download.html. In this example, we’ll load all four images created by SpaceRanger: lowres, hires, detected, and aligned. That way we can toggle between them on the web application. ## Import the data as a SpatialExperiment object using wrapper functions ## provided by spatialLIBD library(&quot;spatialLIBD&quot;) spe_wrapper &lt;- read10xVisiumWrapper( samples = file.path(tempdir(), &quot;outs&quot;), sample_id = &quot;lymph&quot;, type = &quot;sparse&quot;, data = &quot;filtered&quot;, images = c(&quot;lowres&quot;, &quot;hires&quot;, &quot;detected&quot;, &quot;aligned&quot;), load = TRUE, reference_gtf = gtf_cache ) #&gt; 2024-05-28 02:37:00.601612 SpatialExperiment::read10xVisium: reading basic data from SpaceRanger #&gt; 2024-05-28 02:37:13.836881 read10xVisiumAnalysis: reading analysis output from SpaceRanger #&gt; 2024-05-28 02:37:13.944755 add10xVisiumAnalysis: adding analysis output from SpaceRanger #&gt; 2024-05-28 02:37:14.240843 rtracklayer::import: reading the reference GTF file #&gt; 2024-05-28 02:37:41.590682 adding gene information to the SPE object #&gt; Warning: Gene IDs did not match. This typically happens when you are not using the same GTF file as the one that was #&gt; used by SpaceRanger. For example, one file uses GENCODE IDs and the other one ENSEMBL IDs. read10xVisiumWrapper() will #&gt; try to convert them to ENSEMBL IDs. #&gt; Warning: Dropping 29 out of 36601 genes for which we don&#39;t have information on the reference GTF file. This typically #&gt; happens when you are not using the same GTF file as the one that was used by SpaceRanger. #&gt; 2024-05-28 02:37:42.148009 adding information used by spatialLIBD ## Explore the resulting SpatialExperiment object spe_wrapper #&gt; class: SpatialExperiment #&gt; dim: 36572 4035 #&gt; metadata(0): #&gt; assays(1): counts #&gt; rownames(36572): ENSG00000243485.5 ENSG00000237613.2 ... ENSG00000198695.2 ENSG00000198727.2 #&gt; rowData names(6): source type ... gene_type gene_search #&gt; colnames(4035): AAACAAGTATCTCCCA-1 AAACAATCTACTAGCA-1 ... TTGTTTGTATTACACG-1 TTGTTTGTGTAAATTC-1 #&gt; colData names(20): sample_id in_tissue ... expr_chrM_ratio ManualAnnotation #&gt; reducedDimNames(3): 10x_pca 10x_tsne 10x_umap #&gt; mainExpName: NULL #&gt; altExpNames(0): #&gt; spatialCoords names(2) : pxl_col_in_fullres pxl_row_in_fullres #&gt; imgData names(4): sample_id image_id data scaleFactor ## Size of the data lobstr::obj_size(spe_wrapper) #&gt; 410.19 MB ## Run our shiny app if (interactive()) { vars &lt;- colnames(colData(spe_wrapper)) run_app( spe_wrapper, sce_layer = NULL, modeling_results = NULL, sig_genes = NULL, title = &quot;spatialLIBD: human lymph node by 10x Genomics (made with wrapper)&quot;, spe_discrete_vars = c(vars[grep(&quot;10x_&quot;, vars)], &quot;ManualAnnotation&quot;), spe_continuous_vars = c(&quot;sum_umi&quot;, &quot;sum_gene&quot;, &quot;expr_chrM&quot;, &quot;expr_chrM_ratio&quot;), default_cluster = &quot;10x_graphclust&quot; ) } The result should look pretty much like https://libd.shinyapps.io/spatialLIBD_Human_Lymph_Node_10x/. The apps showcased above are linked to and described at http://research.libd.org/spatialDLPFC/#interactive-websites. This video was part of Nicholas J. Eagles recent LIBD seminar presentation. Congrats Nick for successfully completing your 1st🥇 @LieberInstitute seminar 🙌🏽Nick presented #spatialDLPFC spot deconvolution results @10xGenomics #snRNAseq #Visium #VisiumSPG🛝 https://t.co/2wMLSkTLyWInteract with the data https://t.co/ya4oyiMVsNhttps://t.co/cTdGNswysy pic.twitter.com/Ggmnnmj2nA — 🇲🇽 Leonardo Collado-Torres (@lcolladotor) June 27, 2023 18.4 Visualize spatial plots Now that we have explored the spatially resolved transcriptomics data with the spatialLIBD::run_app() shiny website, lets make some plots ourselves. Check out the documentation for these two functions: spatialLIBD::vis_gene() http://research.libd.org/spatialLIBD/reference/vis_gene.html for continuous variables, including gene expression values spatialLIBD::vis_clus() http://research.libd.org/spatialLIBD/reference/vis_clus.html for discrete variables 18.5 Exercise p.exercise { background-color: #E4EDE2; padding: 9px; border: 1px solid black; border-radius: 10px; font-family: sans-serif; } Exercise 1: Plot a discrete variable of your choice with and without the histology image on the background. For example, visualize the k-means with \\(k = 10\\) clustering results computed by SpaceRanger. Use custom colors of your choice. See https://emilhvitfeldt.github.io/r-color-palettes/discrete.html to choose a color palette. For example, use the Polychrome::palette36() colors. p.solution { background-color: #C093D6; padding: 9px; border: 1px solid black; border-radius: 10px; font-family: sans-serif; } Solution 1: The function for plotting discrete variables is spatialLIBD::vis_clus() which is documented at http://research.libd.org/spatialLIBD/reference/vis_clus.html. After reading the documentation website for this function, we are ready to write the code to solve our exercise problem. ## Basic spatial graph visualizing a discrete variable that we provided to ## the argument &quot;clustervar&quot;. Here we chose to visualize ## &quot;10x_kmeans_10_clusters&quot; which contains the clustering results from the ## K-means algorithm when k = 10. ## We are plotting the one sample we have called &quot;lymph&quot;. This is the same ## name we chose earlier when we ran spatialLIBD::read10xVisiumWrapper(). vis_clus( spe = spe_wrapper, sampleid = &quot;lymph&quot;, clustervar = &quot;10x_kmeans_10_clusters&quot; ) ## Next we ignore the histology image and stop plotting it by setting ## &quot;spatial = FALSE&quot; vis_clus( spe = spe_wrapper, sampleid = &quot;lymph&quot;, clustervar = &quot;10x_kmeans_10_clusters&quot;, spatial = FALSE ) ## Finally, we use the &quot;colors&quot; argument to specify our own colors. We use ## the general setNames() R function to create a named vector that has as ## values the colors and as names the same names we have for our &quot;clustervar&quot;. vis_clus( spe = spe_wrapper, sampleid = &quot;lymph&quot;, clustervar = &quot;10x_kmeans_10_clusters&quot;, spatial = FALSE, colors = setNames(Polychrome::palette36.colors(10), 1:10) ) ## Here we can see the vector we provided as input to &quot;colors&quot;: setNames(Polychrome::palette36.colors(10), 1:10) #&gt; 1 2 3 4 5 6 7 8 9 10 #&gt; &quot;#5A5156&quot; &quot;#E4E1E3&quot; &quot;#F6222E&quot; &quot;#FE00FA&quot; &quot;#16FF32&quot; &quot;#3283FE&quot; &quot;#FEAF16&quot; &quot;#B00068&quot; &quot;#1CFFCE&quot; &quot;#90AD1C&quot; "],["re-use-of-bulk-rna-seq-methods-for-spatial-data-exercise.html", "19 Re-use of bulk RNA-seq methods for spatial data exercise 19.1 Spatial registration 19.2 Exercise", " 19 Re-use of bulk RNA-seq methods for spatial data exercise Instructor: Leo Hot of the pre-print press! 🔥 Our latest work #spatialDLPFC pairs #snRNAseq and #Visium spatial transcriptomic data in the human #DLPFC building a neuroanatomical atlas of this critical brain region 🧠@LieberInstitute @10xGenomics #scitwitter📰 https://t.co/NJWJ1mwB9J pic.twitter.com/l8W154XZ50 — Louise Huuki-Myers (@lahuuki) February 17, 2023 19.1 Spatial registration Louise A. Huuki-Myers recently contributed a new vignette to spatialLIBD as noted on the package news / changelog: http://research.libd.org/spatialLIBD/news/index.html#spatiallibd-1132. To follow it, you might want to have the latest version of spatialLIBD installed. You can install it with this command: BiocManager::install(&quot;LieberInstitute/spatialLIBD&quot;) Alternatively, you could have a Bioconductor devel setup, but that’s beyond the scope of this course. Using the devel docker image at http://bioconductor.org/help/docker/ is probably the easiest option. After installing this version of spatialLIBD, you should be able to run without any issues the code Louise explains at http://research.libd.org/spatialLIBD/articles/guide_to_spatial_registration.html. This same information is displayed at https://bioconductor.org/packages/devel/data/experiment/vignettes/spatialLIBD/inst/doc/guide_to_spatial_registration.html. 19.2 Exercise p.exercise { background-color: #E4EDE2; padding: 9px; border: 1px solid black; border-radius: 10px; font-family: sans-serif; } Exercise: Follow the vignette on spatial registration. Do the results change when you use cutoff_merge_ratio = 0.1? What is this argument controlling? "],["final-r-session.html", "Final R Session", " Final R Session This is the final R session after all the code in this book is run sequentially. #&gt; ─ Session info ─────────────────────────────────────────────────────────────────────────────────────────────────────── #&gt; setting value #&gt; version R version 4.3.3 (2024-02-29) #&gt; os Ubuntu 22.04.4 LTS #&gt; system x86_64, linux-gnu #&gt; ui X11 #&gt; language (EN) #&gt; collate en_US.UTF-8 #&gt; ctype en_US.UTF-8 #&gt; tz UTC #&gt; date 2024-05-28 #&gt; pandoc 3.1.1 @ /usr/local/bin/ (via rmarkdown) #&gt; #&gt; ─ Packages ─────────────────────────────────────────────────────────────────────────────────────────────────────────── #&gt; package * version date (UTC) lib source #&gt; abind 1.4-5 2016-07-21 [1] RSPM (R 4.3.0) #&gt; airway * 1.22.0 2023-10-26 [1] Bioconductor #&gt; AnnotationDbi 1.64.1 2023-11-03 [1] Bioconductor #&gt; AnnotationHub 3.10.1 2024-04-05 [1] Bioconductor 3.18 (R 4.3.2) #&gt; aod 1.3.3 2023-12-13 [1] RSPM (R 4.3.0) #&gt; attempt 0.3.1 2020-05-03 [1] RSPM (R 4.3.0) #&gt; backports 1.4.1 2021-12-13 [1] RSPM (R 4.3.0) #&gt; base64enc 0.1-3 2015-07-28 [2] RSPM (R 4.3.0) #&gt; beachmat 2.18.1 2024-02-14 [1] Bioconductor 3.18 (R 4.3.2) #&gt; beeswarm 0.4.0 2021-06-01 [1] RSPM (R 4.3.0) #&gt; benchmarkme 1.0.8 2022-06-12 [1] RSPM (R 4.3.0) #&gt; benchmarkmeData 1.0.4 2020-04-23 [1] RSPM (R 4.3.0) #&gt; bibtex 0.5.1 2023-01-26 [1] RSPM (R 4.3.0) #&gt; Biobase * 2.62.0 2023-10-24 [1] Bioconductor #&gt; BiocFileCache * 2.10.2 2024-03-27 [1] Bioconductor 3.18 (R 4.3.2) #&gt; BiocGenerics * 0.48.1 2023-11-01 [1] Bioconductor #&gt; BiocIO 1.12.0 2023-10-24 [1] Bioconductor #&gt; BiocManager 1.30.22 2023-08-08 [1] RSPM (R 4.3.0) #&gt; BiocNeighbors 1.20.2 2024-01-07 [1] Bioconductor 3.18 (R 4.3.2) #&gt; BiocParallel * 1.36.0 2023-10-24 [1] Bioconductor #&gt; BiocSingular 1.18.0 2023-10-24 [1] Bioconductor #&gt; BiocStyle * 2.30.0 2023-10-24 [1] Bioconductor #&gt; biocthis * 1.12.0 2023-10-24 [1] Bioconductor #&gt; BiocVersion 3.18.1 2023-11-15 [2] Bioconductor #&gt; Biostrings 2.70.3 2024-03-13 [1] Bioconductor 3.18 (R 4.3.2) #&gt; bit 4.0.5 2022-11-15 [1] RSPM (R 4.3.0) #&gt; bit64 4.0.5 2020-08-30 [1] RSPM (R 4.3.0) #&gt; bitops 1.0-7 2021-04-24 [1] RSPM (R 4.3.0) #&gt; blob 1.2.4 2023-03-17 [1] RSPM (R 4.3.0) #&gt; bookdown 0.39 2024-04-15 [1] RSPM (R 4.3.0) #&gt; boot 1.3-30 2024-02-26 [3] RSPM (R 4.3.0) #&gt; broom 1.0.5 2023-06-09 [1] RSPM (R 4.3.0) #&gt; bslib 0.7.0 2024-03-29 [2] RSPM (R 4.3.0) #&gt; cachem 1.0.8 2023-05-01 [2] RSPM (R 4.3.0) #&gt; Cairo 1.6-2 2023-11-28 [1] RSPM (R 4.3.0) #&gt; caTools 1.18.2 2021-03-28 [1] RSPM (R 4.3.0) #&gt; checkmate 2.3.1 2023-12-04 [1] RSPM (R 4.3.0) #&gt; circlize * 0.4.16 2024-02-20 [1] RSPM (R 4.3.0) #&gt; cli 3.6.2 2023-12-11 [2] RSPM (R 4.3.0) #&gt; clue 0.3-65 2023-09-23 [1] RSPM (R 4.3.0) #&gt; cluster 2.1.6 2023-12-01 [3] CRAN (R 4.3.3) #&gt; codetools 0.2-20 2024-03-31 [3] RSPM (R 4.3.0) #&gt; colorspace 2.1-0 2023-01-23 [1] RSPM (R 4.3.0) #&gt; colourpicker 1.3.0 2023-08-21 [1] RSPM (R 4.3.0) #&gt; ComplexHeatmap * 2.18.0 2023-10-24 [1] Bioconductor #&gt; config 0.3.2 2023-08-30 [1] RSPM (R 4.3.0) #&gt; corpcor 1.6.10 2021-09-16 [1] RSPM (R 4.3.0) #&gt; cowplot * 1.1.3 2024-01-22 [1] RSPM (R 4.3.0) #&gt; crayon 1.5.2 2022-09-29 [2] RSPM (R 4.3.0) #&gt; curl 5.2.1 2024-03-01 [2] RSPM (R 4.3.0) #&gt; data.table 1.15.4 2024-03-30 [1] RSPM (R 4.3.0) #&gt; DBI 1.2.2 2024-02-16 [1] RSPM (R 4.3.0) #&gt; dbplyr * 2.5.0 2024-03-19 [1] RSPM (R 4.3.0) #&gt; DelayedArray 0.28.0 2023-10-24 [1] Bioconductor #&gt; DelayedMatrixStats 1.24.0 2023-10-24 [1] Bioconductor #&gt; digest 0.6.35 2024-03-11 [2] RSPM (R 4.3.0) #&gt; doParallel 1.0.17 2022-02-07 [1] RSPM (R 4.3.0) #&gt; dotCall64 1.1-1 2023-11-28 [1] RSPM (R 4.3.0) #&gt; dplyr 1.1.4 2023-11-17 [1] RSPM (R 4.3.0) #&gt; dqrng 0.3.2 2023-11-29 [1] RSPM (R 4.3.0) #&gt; DropletUtils 1.22.0 2023-10-24 [1] Bioconductor #&gt; DT 0.33 2024-04-04 [1] RSPM (R 4.3.0) #&gt; edgeR * 4.0.16 2024-02-18 [1] Bioconductor 3.18 (R 4.3.2) #&gt; EnvStats 2.8.1 2023-08-22 [1] RSPM (R 4.3.0) #&gt; evaluate 0.23 2023-11-01 [2] RSPM (R 4.3.0) #&gt; ExperimentHub 2.10.0 2023-10-24 [1] Bioconductor #&gt; ExploreModelMatrix * 1.14.0 2023-10-24 [1] Bioconductor #&gt; fANCOVA 0.6-1 2020-11-13 [1] RSPM (R 4.3.0) #&gt; fansi 1.0.6 2023-12-08 [2] RSPM (R 4.3.0) #&gt; farver 2.1.1 2022-07-06 [1] RSPM (R 4.3.0) #&gt; fastmap 1.1.1 2023-02-24 [2] RSPM (R 4.3.0) #&gt; fields 15.2 2023-08-17 [1] RSPM (R 4.3.0) #&gt; filelock 1.0.3 2023-12-11 [1] RSPM (R 4.3.0) #&gt; foreach 1.5.2 2022-02-02 [1] RSPM (R 4.3.0) #&gt; foreign 0.8-86 2023-11-28 [3] CRAN (R 4.3.3) #&gt; Formula 1.2-5 2023-02-24 [1] RSPM (R 4.3.0) #&gt; fs 1.6.3 2023-07-20 [2] RSPM (R 4.3.0) #&gt; generics 0.1.3 2022-07-05 [1] RSPM (R 4.3.0) #&gt; GenomeInfoDb * 1.38.8 2024-03-15 [1] Bioconductor 3.18 (R 4.3.2) #&gt; GenomeInfoDbData 1.2.11 2024-04-06 [1] Bioconductor #&gt; GenomicAlignments 1.38.2 2024-01-16 [1] Bioconductor 3.18 (R 4.3.2) #&gt; GenomicRanges * 1.54.1 2023-10-29 [1] Bioconductor #&gt; GetoptLong 1.0.5 2020-12-15 [1] RSPM (R 4.3.0) #&gt; ggbeeswarm 0.7.2 2023-04-29 [1] RSPM (R 4.3.0) #&gt; ggplot2 * 3.5.0 2024-02-23 [1] RSPM (R 4.3.0) #&gt; ggrepel * 0.9.5 2024-01-10 [1] RSPM (R 4.3.0) #&gt; GlobalOptions 0.1.2 2020-06-10 [1] RSPM (R 4.3.0) #&gt; glue 1.7.0 2024-01-09 [2] RSPM (R 4.3.0) #&gt; golem 0.4.1 2023-06-05 [1] RSPM (R 4.3.0) #&gt; gplots 3.1.3.1 2024-02-02 [1] RSPM (R 4.3.0) #&gt; gridExtra 2.3 2017-09-09 [1] RSPM (R 4.3.0) #&gt; gtable 0.3.5 2024-04-22 [1] RSPM (R 4.3.0) #&gt; gtools 3.9.5 2023-11-20 [1] RSPM (R 4.3.0) #&gt; HDF5Array 1.30.1 2024-02-14 [1] Bioconductor 3.18 (R 4.3.2) #&gt; here * 1.0.1 2020-12-13 [1] RSPM (R 4.3.0) #&gt; highr 0.10 2022-12-22 [2] RSPM (R 4.3.0) #&gt; Hmisc * 5.1-2 2024-03-11 [1] RSPM (R 4.3.0) #&gt; htmlTable 2.4.2 2023-10-29 [1] RSPM (R 4.3.0) #&gt; htmltools 0.5.8.1 2024-04-04 [2] RSPM (R 4.3.0) #&gt; htmlwidgets 1.6.4 2023-12-06 [2] RSPM (R 4.3.0) #&gt; httpuv 1.6.15 2024-03-26 [2] RSPM (R 4.3.0) #&gt; httr 1.4.7 2023-08-15 [2] RSPM (R 4.3.0) #&gt; igraph 2.0.3 2024-03-13 [1] RSPM (R 4.3.0) #&gt; interactiveDisplayBase 1.40.0 2023-10-24 [1] Bioconductor #&gt; IRanges * 2.36.0 2023-10-24 [1] Bioconductor #&gt; irlba 2.3.5.1 2022-10-03 [1] RSPM (R 4.3.0) #&gt; iSEE * 2.14.0 2023-10-24 [1] Bioconductor #&gt; iterators 1.0.14 2022-02-05 [1] RSPM (R 4.3.0) #&gt; jquerylib 0.1.4 2021-04-26 [2] RSPM (R 4.3.0) #&gt; jsonlite 1.8.8 2023-12-04 [2] RSPM (R 4.3.0) #&gt; KEGGREST 1.42.0 2023-10-24 [1] Bioconductor #&gt; KernSmooth 2.23-22 2023-07-10 [3] CRAN (R 4.3.3) #&gt; knitr 1.46 2024-04-06 [2] RSPM (R 4.3.0) #&gt; labeling 0.4.3 2023-08-29 [1] RSPM (R 4.3.0) #&gt; later 1.3.2 2023-12-06 [2] RSPM (R 4.3.0) #&gt; lattice 0.22-6 2024-03-20 [3] RSPM (R 4.3.0) #&gt; lazyeval 0.2.2 2019-03-15 [1] RSPM (R 4.3.0) #&gt; lifecycle 1.0.4 2023-11-07 [2] RSPM (R 4.3.0) #&gt; limma * 3.58.1 2023-10-31 [1] Bioconductor #&gt; lme4 1.1-35.3 2024-04-16 [1] RSPM (R 4.3.0) #&gt; lmerTest 3.1-3 2020-10-23 [1] RSPM (R 4.3.0) #&gt; lobstr * 1.1.2 2022-06-22 [1] RSPM (R 4.3.0) #&gt; locfit 1.5-9.9 2024-03-01 [1] RSPM (R 4.3.0) #&gt; lubridate 1.9.3 2023-09-27 [1] RSPM (R 4.3.0) #&gt; magick 2.8.3 2024-02-18 [1] RSPM (R 4.3.0) #&gt; magrittr 2.0.3 2022-03-30 [2] RSPM (R 4.3.0) #&gt; maps 3.4.2 2023-12-15 [1] RSPM (R 4.3.0) #&gt; MASS 7.3-60.0.1 2024-01-13 [3] CRAN (R 4.3.3) #&gt; Matrix 1.6-5 2024-01-11 [3] CRAN (R 4.3.3) #&gt; MatrixGenerics * 1.14.0 2023-10-24 [1] Bioconductor #&gt; matrixStats * 1.3.0 2024-04-11 [1] RSPM (R 4.3.0) #&gt; memoise 2.0.1 2021-11-26 [2] RSPM (R 4.3.0) #&gt; mgcv 1.9-1 2023-12-21 [3] CRAN (R 4.3.3) #&gt; mime 0.12 2021-09-28 [2] RSPM (R 4.3.0) #&gt; miniUI 0.1.1.1 2018-05-18 [2] RSPM (R 4.3.0) #&gt; minqa 1.2.6 2023-09-11 [1] RSPM (R 4.3.0) #&gt; munsell 0.5.1 2024-04-01 [1] RSPM (R 4.3.0) #&gt; mvtnorm 1.2-4 2023-11-27 [1] RSPM (R 4.3.0) #&gt; nlme 3.1-164 2023-11-27 [3] CRAN (R 4.3.3) #&gt; nloptr 2.0.3 2022-05-26 [1] RSPM (R 4.3.0) #&gt; nnet 7.3-19 2023-05-03 [3] CRAN (R 4.3.3) #&gt; numDeriv 2016.8-1.1 2019-06-06 [1] RSPM (R 4.3.0) #&gt; paletteer 1.6.0 2024-01-21 [1] RSPM (R 4.3.0) #&gt; patchwork * 1.2.0 2024-01-08 [1] RSPM (R 4.3.0) #&gt; pbkrtest 0.5.2 2023-01-19 [1] RSPM (R 4.3.0) #&gt; pheatmap * 1.0.12 2019-01-04 [1] RSPM (R 4.3.0) #&gt; pillar 1.9.0 2023-03-22 [2] RSPM (R 4.3.0) #&gt; pkgconfig 2.0.3 2019-09-22 [2] RSPM (R 4.3.0) #&gt; plotly 4.10.4 2024-01-13 [1] RSPM (R 4.3.0) #&gt; plyr 1.8.9 2023-10-02 [1] RSPM (R 4.3.0) #&gt; png 0.1-8 2022-11-29 [1] RSPM (R 4.3.0) #&gt; Polychrome * 1.5.1 2022-05-03 [1] RSPM (R 4.3.0) #&gt; postcards * 0.2.3 2022-01-07 [1] RSPM (R 4.3.0) #&gt; prettyunits 1.2.0 2023-09-24 [2] RSPM (R 4.3.0) #&gt; promises 1.3.0 2024-04-05 [2] RSPM (R 4.3.0) #&gt; purrr 1.0.2 2023-08-10 [2] RSPM (R 4.3.0) #&gt; R.cache 0.16.0 2022-07-21 [1] RSPM (R 4.3.0) #&gt; R.methodsS3 1.8.2 2022-06-13 [1] RSPM (R 4.3.0) #&gt; R.oo 1.26.0 2024-01-24 [1] RSPM (R 4.3.0) #&gt; R.utils 2.12.3 2023-11-18 [1] RSPM (R 4.3.0) #&gt; R6 2.5.1 2021-08-19 [2] RSPM (R 4.3.0) #&gt; rappdirs 0.3.3 2021-01-31 [2] RSPM (R 4.3.0) #&gt; rbibutils 2.2.16 2023-10-25 [1] RSPM (R 4.3.0) #&gt; RColorBrewer * 1.1-3 2022-04-03 [1] RSPM (R 4.3.0) #&gt; Rcpp 1.0.12 2024-01-09 [2] RSPM (R 4.3.0) #&gt; RCurl 1.98-1.14 2024-01-09 [1] RSPM (R 4.3.0) #&gt; Rdpack 2.6 2023-11-08 [1] RSPM (R 4.3.0) #&gt; recount3 * 1.12.0 2023-10-24 [1] Bioconductor #&gt; RefManageR * 1.4.0 2022-09-30 [1] RSPM (R 4.3.0) #&gt; remaCor 0.0.18 2024-02-08 [1] RSPM (R 4.3.0) #&gt; rematch2 2.1.2 2020-05-01 [2] RSPM (R 4.3.0) #&gt; reshape2 1.4.4 2020-04-09 [1] RSPM (R 4.3.0) #&gt; restfulr 0.0.15 2022-06-16 [1] RSPM (R 4.3.2) #&gt; rhdf5 2.46.1 2023-11-29 [1] Bioconductor 3.18 (R 4.3.2) #&gt; rhdf5filters 1.14.1 2023-11-06 [1] Bioconductor #&gt; Rhdf5lib 1.24.2 2024-02-07 [1] Bioconductor 3.18 (R 4.3.2) #&gt; RhpcBLASctl 0.23-42 2023-02-11 [1] RSPM (R 4.3.0) #&gt; rintrojs 0.3.4 2024-01-11 [1] RSPM (R 4.3.0) #&gt; rjson 0.2.21 2022-01-09 [1] RSPM (R 4.3.0) #&gt; rlang * 1.1.3 2024-01-10 [2] RSPM (R 4.3.0) #&gt; rmarkdown 2.26 2024-03-05 [2] RSPM (R 4.3.0) #&gt; rpart 4.1.23 2023-12-05 [3] CRAN (R 4.3.3) #&gt; rprojroot 2.0.4 2023-11-05 [2] RSPM (R 4.3.0) #&gt; Rsamtools 2.18.0 2023-10-24 [1] Bioconductor #&gt; RSQLite 2.3.6 2024-03-31 [1] RSPM (R 4.3.0) #&gt; rstudioapi 0.16.0 2024-03-24 [2] RSPM (R 4.3.0) #&gt; rsvd 1.0.5 2021-04-16 [1] RSPM (R 4.3.0) #&gt; rtracklayer 1.62.0 2023-10-24 [1] Bioconductor #&gt; S4Arrays 1.2.1 2024-03-04 [1] Bioconductor 3.18 (R 4.3.2) #&gt; S4Vectors * 0.40.2 2023-11-23 [1] Bioconductor 3.18 (R 4.3.2) #&gt; sass 0.4.9 2024-03-15 [2] RSPM (R 4.3.0) #&gt; ScaledMatrix 1.10.0 2023-10-24 [1] Bioconductor #&gt; scales 1.3.0 2023-11-28 [1] RSPM (R 4.3.0) #&gt; scater * 1.30.1 2023-11-16 [1] Bioconductor #&gt; scatterplot3d 0.3-44 2023-05-05 [1] RSPM (R 4.3.0) #&gt; scuttle * 1.12.0 2023-10-24 [1] Bioconductor #&gt; sessioninfo * 1.2.2 2021-12-06 [2] RSPM (R 4.3.0) #&gt; shape 1.4.6.1 2024-02-23 [1] RSPM (R 4.3.0) #&gt; shiny 1.8.1.1 2024-04-02 [2] RSPM (R 4.3.0) #&gt; shinyAce 0.4.2 2022-05-06 [1] RSPM (R 4.3.0) #&gt; shinydashboard 0.7.2 2021-09-30 [1] RSPM (R 4.3.0) #&gt; shinyjs 2.1.0 2021-12-23 [1] RSPM (R 4.3.0) #&gt; shinyWidgets 0.8.5 2024-04-17 [1] RSPM (R 4.3.0) #&gt; SingleCellExperiment * 1.24.0 2023-10-24 [1] Bioconductor #&gt; smokingMouse * 0.99.91 2024-05-28 [1] Github (LieberInstitute/smokingMouse@96d8480) #&gt; spam 2.10-0 2023-10-23 [1] RSPM (R 4.3.0) #&gt; SparseArray 1.2.4 2024-02-11 [1] Bioconductor 3.18 (R 4.3.2) #&gt; sparseMatrixStats 1.14.0 2023-10-24 [1] Bioconductor #&gt; SpatialExperiment * 1.12.0 2023-10-24 [1] Bioconductor #&gt; spatialLIBD * 1.14.1 2023-11-30 [1] Bioconductor 3.18 (R 4.3.2) #&gt; statmod 1.5.0 2023-01-06 [1] RSPM (R 4.3.0) #&gt; stringi 1.8.3 2023-12-11 [2] RSPM (R 4.3.0) #&gt; stringr * 1.5.1 2023-11-14 [2] RSPM (R 4.3.0) #&gt; styler 1.10.3 2024-04-07 [1] RSPM (R 4.3.0) #&gt; SummarizedExperiment * 1.32.0 2023-10-24 [1] Bioconductor #&gt; tibble 3.2.1 2023-03-20 [2] RSPM (R 4.3.0) #&gt; tidyr 1.3.1 2024-01-24 [1] RSPM (R 4.3.0) #&gt; tidyselect 1.2.1 2024-03-11 [1] RSPM (R 4.3.0) #&gt; timechange 0.3.0 2024-01-18 [1] RSPM (R 4.3.0) #&gt; usethis * 2.2.3 2024-02-19 [2] RSPM (R 4.3.0) #&gt; utf8 1.2.4 2023-10-22 [2] RSPM (R 4.3.0) #&gt; variancePartition * 1.32.5 2024-02-16 [1] Bioconductor 3.18 (R 4.3.2) #&gt; vctrs 0.6.5 2023-12-01 [2] RSPM (R 4.3.0) #&gt; vipor 0.4.7 2023-12-18 [1] RSPM (R 4.3.0) #&gt; viridis 0.6.5 2024-01-29 [1] RSPM (R 4.3.0) #&gt; viridisLite 0.4.2 2023-05-02 [1] RSPM (R 4.3.0) #&gt; withr 3.0.0 2024-01-16 [2] RSPM (R 4.3.0) #&gt; xfun 0.43 2024-03-25 [2] RSPM (R 4.3.0) #&gt; XML 3.99-0.16.1 2024-01-22 [1] RSPM (R 4.3.0) #&gt; xml2 1.3.6 2023-12-04 [2] RSPM (R 4.3.0) #&gt; xtable 1.8-4 2019-04-21 [2] RSPM (R 4.3.0) #&gt; XVector 0.42.0 2023-10-24 [1] Bioconductor #&gt; yaml 2.3.8 2023-12-11 [2] RSPM (R 4.3.0) #&gt; zlibbioc 1.48.2 2024-03-13 [1] Bioconductor 3.18 (R 4.3.2) #&gt; #&gt; [1] /__w/_temp/Library #&gt; [2] /usr/local/lib/R/site-library #&gt; [3] /usr/local/lib/R/library #&gt; #&gt; ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── This interactive book was last updated at 2024-05-28 02:37:48.468596. "],["differential-gene-expression-analysis-overview.html", "20 Differential Gene Expression analysis overview 20.1 Preliminary steps 20.2 Differential Gene Expression 20.3 Downstream analyses 20.4 References", " 20 Differential Gene Expression analysis overview Instructor: Daianna Differential Gene Expression (DGE) analyses are common statistical analyses of gene expression data that aim to discover genes significantly altered in their expression levels between experimental groups, which can be given by a condition, treatment, experimental procedure/exposure, diagnostic, time points, by biological origins (e.g. differences in sex, tissue, age, species), and even by different technical methodologies. These genes are known as Differentially Expressed Genes (DEGs) and can be either up- or down-regulated if their expression is greater or less in one group with respect to the other(s), respectively. Diverse methods exist to perform DGE and multiple downstream analyses can be applied on DEGs, but a series of non-skippable preliminary steps exists which are necessary to correctly perform previous to any statistical testing. Below a classic workflow for DGE is depicted. It takes as input the gene expression matrix with raw read counts for genes (as rows) across all samples (as columns). Among the preliminary steps, there is an initial data processing step encompassing count normalization and filtering of lowly-expressed genes. Secondly, Exploratory Data Analysis (EDA) involves assessment of Quality Control (QC) metrics of the samples and filtering of poor-quality ones, as well as an examination of the gene expression profiles between sample groups, potential detection of additional atypical samples to remove, and the exploration of the correlations between sample-level variables and their contributions in the expression variance of each gene to guide the covariate selection for DGE models. Figure 1: Summary of the analyses for differential expression. 1. RNA-seq data processing: raw counts are normalized and log-scaled (lognorm-counts) and the lowly-expressed genes are filtered out. 2. Exploratory Data Analysis: quality metrics of the samples are compared across groups, the poor-quality samples are filtered and both sample-level and gene-level effects of sample variables are explored to identify those that are main drivers of gene expression variation to include in the models for DGE. 3. Differential Expression Analysis: under the limma-voom pipeline the expression of each gene is linearly modeled by the selected variables in the previous step; after fitting the model gene-wise log2-fold changes (log2FC) and p-values are obtained for the variable of interest and other statistics of differential expression are also computed and compared. Here DEGs are determined based on the significance threshold (controlling for the False Discovery Rate or FDR). 4. Functional Enrichment Analysis: an overrepresentation analysis (ORA) is performed to find statistically significant associations between our groups of DEGs and gene sets annotated in GO terms and KEGG pathways; here we identify biological processes, cellular functions and components, and pathways potentially affected or involved in the experimental condition under study. 5. DE visualization: heatmaps are created to visually contrast gene expression levels of DEGs in the experimental groups. Abbreviations: CPM: counts per million; QC: quality control; PC: principal component; DEG(s): differentially expressed gene(s); Ctrl: control; Expt: experimental; GO: Gene Ontology; KEGG: Kyoto Encyclopedia of Genes and Genomes. 20.1 Preliminary steps Evident computational steps right after sequencing involve raw sequencing reads Quality Control (QC) analysis and read alignment to a reference genome for the subsequent gene expression quantification, generating the input for DGE. Comprehensive pipelines have been developed for these purposes, such as the RNA-seq processing pipeline SPEAQeasy (Eagles, N.J. et al. 2021) that provides a flexible, user-friendly, and reproducible pipeline to perform all such analyses through the implementation of a single workflow, liberating from the need of performing each step individually. p.link{ background-color: #FFFFFF; padding: 10px; border: 0px solid black; margin-left: 0px; border-radius: 1px; font-size: 15px; font-family: sans-serif; } 👉🏼 More details of this pipeline are provided in the original manuscript, the documentation website, and other in created resources. 20.1.1 RNA-seq data processing Once the gene expression matrix has been generated we can proceed to process the read counts. Raw counts are typically zero-enriched and not normally-distributed, which is required for the application of several statistical methods. Furthermore, raw gene expression values may reflect protocol-specific biases and biological factors other than the one of interest. Therefore raw counts must be normalized and lowly-expressed genes filtered out. 20.1.1.1 Data normalization Differences between samples such as library sizes (sequencing depths), and RNA composition, as well as different gene lengths and GC contents make raw gene expression data not comparable between samples. Several normalization strategies can be applied to surpass such differences; commonly counts-per-million (cpm) are used. In addition to count normalization, a log-transformation is required to make cpm follow an approximately normal distribution. 20.1.1.2 Gene filtering Often the expression profiling platform (microarray or RNA-seq) includes genes that do not appear to be expressed to a worthwhile degree in any or most of the samples. This might occur, for instance, in cases where genes are not expressed in any of the cell types being experimentally profiled [1]. We want to remove those genes prior to posterior analyses, which is justified on both biological and statistical grounds [2]: Biologically, it is considered that a gene must have a minimal expression level to be translated into a protein or to be of biological importance. Statistically, lowly-expressed genes are unlikely to be detected as DE because low counts don’t provide the required statistical evidence to assess differential expression. Different approaches exist for this step, ranging from the simple definition of a gene expression cutoff to those taking into account not only global gene expression but also the number of samples in which they have a minimum expression level. 👉🏼 More details about normalization and filtering can be consulted in the course material of 2023 (Statistical Analysis of Genome Scale Data 2023: Data preparation). Figure 2: RNA-seq data processing steps. 1. Count log-normalization: distribution of read counts before and after normalization and log-transformation into \\(log_2(cpm+0.5)\\) using calcNormFactors() and cpm() of edgeR. 2. Gene filtering: distribution of \\(log_2(cpm+0.5)\\) before and after filtering lowly-expressed genes; note the elimination of originally zero-expressed genes. 20.1.2 Exploratory Data Analysis The Exploratory Data Analysis (EDA) is a primordial step in which, as the name refers, we explore relevant aspects of the RNA-seq data. In this process we basically create tons of plots, charts and graphs to visualize the data, assess their quality and inspect their variability. This clearly exposes low-quality samples and relationships and contributions in gene expression variance of sample-level variables. This allows to draw valuable information from our data that could impact posterior analyses, including DGE. Thus EDA guides filtering steps, the execution of additional analyses, the selection of covariates for DGE models and of statistical tests based on data features, and could also aid in more accurate interpretations of the results. Although here we describe EDA as being comprised by QCA, dimensionality reduction to explore sample-level effects, and variance partition analysis to explore gene-level effects, EDA is not a well defined process that can be followed by concrete instructions or steps. The analyses you run and what you plot depends on the particular questions you’re trying to answer, what you would like to know about your data and of course, it completely depends on the specific characteristics of your own dataset. 20.1.2.1 Quality Control Analysis (QCA) First, the quality metrics of the samples regarding read and RNA contents, and read mapping rates have to be compared to (Figure 3: step 1): Identify punctual samples or groups of samples of poor quality that may have arisen by technical causes during experimental steps. Evaluate if samples from the groups of interest for DGE (diagnostic, treatment, etc.) differ in their quality metrics as these can represent confounding factors for differential expression. Detect high biological variability to subsequently support data partition to perform subanalyses of the data. Further, we are also interested in investigating trends and relationships between sample variables to unveil underlying technical and biological aspects of the observed data (Figure 3: step 2). After having identified poor-quality samples, we have to remove them to not include the unreliable expression data they provide in downstream analyses. Cutoffs can be defined for specific QC metrics to decide which samples to keep; this however, is not strongly recommended as no consolidated references exist to define them and therefore rather represent arbitrary values. Other approaches include identifying outlier QC metrics (Figure 3: step 3), but again, caution must be taken as outlier definition is also arbitrary and we could be discarding good-quality samples. Figure 3: Quality Control Analysis steps. 1. Evaluate QC metrics for groups of samples: sample QC metrics such as the fraction of reads that mapped to the mitochondrial chromosome (mitoRate) and to the reference genome (overallMapRate) are compared between sample groups given by the variable of interest (Group in this example), technical variables (e.g. plate for sample library preparation), and biological variables (e.g. Age). 2. Examine relationships between sample variables: pairs of QC metrics are compared; here mitoRate and the fraction of reads assigned to rRNA genes (rRNA_rate), as well as the library size (sum) and the number of expressed genes (detected) are plotted to explore the relationships they present with each other and with other sample metadata variables. (Group and Age). 3. QC-based sample filtering: outlier QC metrics (red) are detected based on +/- 3 median-absolute-deviations (MADs) away (dotted lines) from the median (solid line). 👉🏼 See more details about QCA in Statistical Analysis of Genome Scale Data 2023: Quality Control Analysis. 20.1.2.2 Exploration of sample-level effects Sample gene expression profiles can be analyzed and compared after dimensionality reduction procedures such as Principal Component Analysis (PCA) and Multidimensional-Scaling (MDS). These analyses are useful to potentially detect samples with outlier transcriptomic profiles to further remove and to identify sample variables driving gene expression variations (Figure 4). Figure 4: Exploration of sample-level effects through PCA 1. Detection of atypical samples (manual PCA-based sample filtering): PCx vs PCy plots can expose outlier samples that appear segregated from the rest (purple-squared sample) or samples of a particular group (Sex: F or M) closer to samples from the other group (blue-squared sample). These should be further examined to evalute if they can be kept or must be discarded. In this case, after removing them, PC2 that explains a higher % of variance in gene expression, separates samples by sex. 2. Identification of drivers of sample gene expression variation: reducing the dimensionality of our data enables to recognize sample variables explaining differences in the gene expression of the samples (Age), ascertain technical variables and batch effects are not impacting on the transcriptome (plate), and inquire to what extent our variable of interest is contributing to changes in gene expression (Group). 20.1.2.3 Model building: covariate selection for limma-voom DGE methods fitting linear models to gene expression data to assess if a covariate impacts significantly on the expression of a gene, require the selection of sample-level variables to model transcriptomic data. If very few variables are present, normally they are all included in the model but that’s not often the case with RNA-seq and it doesn’t represent a well founded strategy. Usually, multiple technical and biological variables are implicated in the experiments and sample QC metrics can affect the gene expression levels, even after count normalization, whereas other variables are redundant and/or minimally informative. Therefore, we’d like to identify an optimal set of variables to adjust gene expression for, in addition to the covariate of interest. We have already introduced one first approximation to that with PCA as this analysis allows us to identify variables explaining high percentages of gene expression variance between samples. In Chapter XX we will review how correlation and variance partition analyses at the gene level can help us determine a suitable set of highly explanatory variables. 20.2 Differential Gene Expression Different mathematical and statistical approaches exist to compare gene expression between two or more conditions. In Chapter XX we’ll briefly introduce methods based on the negative binomial distribution and address how to perform DGE under the empirical Bayes limma-voom framework, distinguishing how it operates, its main specifications, inputs, and outputs. 20.3 Downstream analyses After finding DEGs, volcano plots and heat maps are commonly used to graphically represent them, plotting relevant information about them and their expression levels, respectively. In Chapter XX we’ll also check how to create and interpret these plots. 20.4 References Smyth, G. K., Ritchie, M., Thorne, N., Wettenhall, J., Shi, W., &amp; Hu, Y. (2002). limma: linear models for microarray and RNA-Seq data user’s guide. Bioinformatics Division, The Walter and Eliza Hall Institute of Medical Research, Melbourne, Australia. Chen, Y., Lun, A. T., &amp; Smyth, G. K. (2016). From reads to genes to pathways: differential expression analysis of RNA-Seq experiments using Rsubread and the edgeR quasi-likelihood pipeline. F1000Research, 5. "],["differential-gene-expression-analysis-with-limma-voom.html", "21 Differential Gene Expression analysis with limma-voom 21.1 NB-based DGE methods? 21.2 limma-voom pipeline 21.3 DE visualization 21.4 References", " 21 Differential Gene Expression analysis with limma-voom Instructor: Daianna In this chapter you’ll learn how DGE analysis is performed under the empirical Bayes framework of the popular limma-voom pipeline, highlighting key assumptions and concepts, and main differences with other methodologies. 21.1 NB-based DGE methods? An initial central point of discussion around DGE method development is how to model the distribution of the reads. Many methods model the read counts (\\(y_{k,ij}\\), non-negative integers) of a gene \\(i\\) in the \\(j\\) samples of condition \\(k\\) through the Poisson or the Negative Binomial (NB) distribution. Of these, NB is often preferred as it allows the mean (\\(\\mu\\)) and the variance (\\(\\sigma\\)) of the reads to be different, compared to the Poisson distribution where \\(\\mu\\)=\\(\\sigma\\). This is of particular importance as controlling the variance allows to account for variability in the gene expression levels across biological samples [1]. Figure 1: NB-distributed read counts. Modeling of read counts for gene \\(i\\) in the samples of the first and second conditions based on the NB model. Modified from Li, W. V., &amp; Li, J. J. (2018). Estimating the NB distribution parameters is necessary to assess DE of each gene \\(i\\) between any two conditions \\(k=1,2\\) (Figure 1). Bayesian models are used defining prior distributions and relationships of such parameters. Briefly, after 1) estimating gene-wise NB parameters, 2) the mean-variance relationship across all genes can be used to shrink the gene variance estimations borrowing information from all genes or incorporating prior knowledge, something advantageous when sample sizes are small. 3) A statistical test is used to assess for each gene \\(i\\) if its true expression in the first and second condition (\\(\\theta_{1i}\\) and \\(\\theta_{2i}\\)) is the same (null hypothesis) or differs (alternative hypothesis): \\(H_0: \\theta_{1i}=\\theta_{2i}\\) \\(H_1: \\theta_{1i}≠\\theta_{2i}\\), where the \\(\\theta_{i}\\)’s are parameters included in the mean of the NB distributions (\\(\\mu\\)). 4) The test statistic is computed for each gene and 5) its associated p-value is calculated based on the null distribution. 6) Finally, p-values are corrected for multiple-testing and DEGs are determined based on an adjusted p-values cutoff [1]. Examples of popular methods based on the NB distribution are edgeR and DESeq2. Nevertheless, one limitation NB-based methods face is that they set dispersion of the data as a known and global parameter, ignoring observation-specific variation and importantly, there’s a reduced number of statistical methods for count distributions compared to the normal distribution [1,2]. Here, we’ll focus on limma that does not rely on a certain distribution but rather works on \\(log_2(cpm)\\) and fits linear models for DGE enabling the incorporation of additional predictors to model gene expression, a feature specially valuable for complex experimental settings. 21.2 limma-voom pipeline limma is a package for the analysis of gene expression data arising from microarray or RNA-seq technologies. It has features that make the analyses stable even for experiments with small number of arrays or samples —this is achieved by borrowing information across genes. It is specially designed for analyzing complex experiments with a variety of experimental conditions and predictors [3]. Usually, limma DGE analysis is carried out in five main steps, the last four of them completed by limma R functions, as described below. We’ll use bulk RNA-seq data from the smokingMouse package to exemplify the steps. ## Load the container package for this type of data library(&quot;SummarizedExperiment&quot;) ## Connect to ExperimentHub library(&quot;ExperimentHub&quot;) eh &lt;- ExperimentHub::ExperimentHub() ## Load the datasets of the package myfiles &lt;- query(eh, &quot;smokingMouse&quot;) ## Download the mouse gene data rse_gene &lt;- myfiles[[&quot;EH8313&quot;]] ## Keep samples from nicotine experiment and pups only rse_gene_nic &lt;- rse_gene[, which(rse_gene$Expt == &quot;Nicotine&quot; &amp; rse_gene$Age==&#39;Pup&#39;)] ## Only expressed genes (passed the filtering step) rse_gene_filt &lt;- rse_gene_nic[rowData(rse_gene_nic)$retained_after_feature_filtering == TRUE, ] Let’s explore a little the data. ## Data dimensions: number of genes and samples dim(rse_gene_filt) #&gt; [1] 19974 42 ## Raw counts for first 3 genes in the first 5 samples assays(rse_gene_filt)$counts[1:3, 1:5] #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; ENSMUSG00000051951.5 2652 2107 1978 2691 1833 #&gt; ENSMUSG00000102331.1 15 15 9 15 13 #&gt; ENSMUSG00000025900.13 10 7 28 11 8 ## Log-normalized counts for first 3 genes in the first 5 samples assays(rse_gene_filt)$logcounts[1:3, 1:5] #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; ENSMUSG00000051951.5 5.639967 5.953457 5.4923034 5.903313 5.800879 #&gt; ENSMUSG00000102331.1 -1.747878 -1.130265 -2.1809593 -1.517393 -1.282590 #&gt; ENSMUSG00000025900.13 -2.295096 -2.173926 -0.6153596 -1.941338 -1.948814 ## Data for the first 2 samples head(colData(rse_gene_filt), 2) #&gt; DataFrame with 2 rows and 71 columns #&gt; SAMPLE_ID FQCbasicStats perBaseQual perTileQual perSeqQual perBaseContent GCcontent Ncontent #&gt; SeqLengthDist SeqDuplication OverrepSeqs AdapterContent KmerContent SeqLength_R1 percentGC_R1 phred15-19_R1 #&gt; phred65-69_R1 phred115-119_R1 phred150-151_R1 phredGT30_R1 phredGT35_R1 Adapter65-69_R1 Adapter100-104_R1 #&gt; Adapter140_R1 SeqLength_R2 percentGC_R2 phred15-19_R2 phred65-69_R2 phred115-119_R2 phred150-151_R2 phredGT30_R2 #&gt; phredGT35_R2 Adapter65-69_R2 Adapter100-104_R2 Adapter140_R2 ERCCsumLogErr bamFile trimmed numReads #&gt; numMapped numUnmapped overallMapRate concordMapRate totalMapped mitoMapped mitoRate totalAssignedGene rRNA_rate #&gt; Tissue Age Sex Expt Group Pregnant plate location concentration #&gt; medium date Pregnancy flowcell sum detected subsets_Mito_sum subsets_Mito_detected #&gt; subsets_Mito_percent subsets_Ribo_sum subsets_Ribo_detected subsets_Ribo_percent retained_after_QC_sample_filtering #&gt; retained_after_manual_sample_filtering #&gt; [ reached getOption(&quot;max.print&quot;) -- omitted 3 rows ] 📝 Exercise 1: in order for you to perform a DGE analysis, locate your own RNA-seq datasets if you have any, or download expression data from a study of your interest and build a RSE object using recount3 (see chapter XX: recount3 introduction). A third option you have is to download data from the smokingMouse package used here. 21.2.1 model.matrix() limma fits a linear model to the expression data of each gene (response variable), modeling the systematic part of the data by sample-level covariates (predictors). p.exercise { background-color: #FFFAFA; padding: 15px; border: 2px solid black; margin-left: 0px; border-radius: 1px; font-family: sans-serif; } p.info { background-color: #FFFFF0; padding: 20px; border: 1px solid black; margin-left: 0px; border-radius: 1px; font-family: sans-serif; } p.conclusion { background-color: #EEE9E9; padding: 20px; border: 1px solid black; margin-left: 0px; border-radius: 1px; font-family: sans-serif; } p.question{ background-color: #E3E3E3; padding: 20px; border: 1px solid black; margin-left: 0px; border-radius: 1px; font-family: sans-serif; } p.link{ background-color: #FFFFFF; padding: 10px; border: 0px solid black; margin-left: 0px; border-radius: 1px; font-size: 13px; font-family: sans-serif; } p.comment { background-color: #F0F0F0; padding: 20px; border: 0px solid black; margin-left: 0px; border-radius: 1px; font-family: sans-serif; } p.alert { background-color: #FFE4E1; padding: 14px; border: 0px solid black; margin-left: 0px; border-radius: 1px; font-family: sans-serif; } p.success { background-color: #E0EEE0; padding: 14px; border: 0px solid black; margin-left: 0px; border-radius: 1px; font-family: sans-serif; } 💡 A model is a specification of how a set of variables relate to each other. In the case of a linear model, it is a linear equation that describes how the dependent or response variable is explained by the independent variables, also called predictors. A regression analysis with more than one independent variable is called multiple regression. Regression with only one independent variable is called simple regression [4]. The limma model is specified with a design matrix, also known as model matrix or regressor matrix, often denoted by \\(X\\). This is a matrix of values for explanatory variables of the samples: rows correspond to samples and columns to sample variables. Say that the values the \\(i\\)th sample take in the \\(h\\) covariates are \\(X_{ih}\\)’s and their coefficients are \\(\\beta_{h}\\)’s. The predicted expression of a gene in the \\(i\\)th sample is given by \\(\\hat y_i =\\beta_0 + \\sum_{1}^h\\beta_{h}X_{ih}\\). \\[ \\hat y = X\\beta=\\displaystyle {\\begin{bmatrix} \\hat y_{1}\\\\ \\hat y _{2}\\\\ \\hat y_{3}\\\\...\\\\ \\hat y_{n-1}\\\\ \\hat y_{n}\\end{bmatrix}}={\\begin{bmatrix}1&amp;X_{11}&amp;X_{12}&amp;X_{13}&amp;\\cdots&amp;X_{1,h-1}&amp;X_{1h}\\\\1&amp;X_{21}&amp;X_{22}&amp;X_{23}&amp;\\cdots&amp;X_{2,h-1}&amp;X_{2h}\\\\1&amp;X_{31}&amp;X_{32}&amp;X_{33}&amp;\\cdots&amp;X_{3,h-1}&amp;X_{3h} \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots \\\\1&amp;X_{n-1,1}&amp;X_{n-1,2}&amp;X_{n-1,3}&amp;\\cdots&amp;X_{n-1,h-1}&amp;X_{n-1,h} \\\\1&amp;X_{n,1}&amp;X_{n,2}&amp;X_{n,3}&amp;\\cdots&amp;X_{n,h-1}&amp;X_{n,h} \\end{bmatrix}}{\\begin{bmatrix}\\beta _{0}\\\\\\beta _{1}\\\\\\beta _{2}\\\\\\beta_{3}\\\\...\\\\\\beta_{h-1}\\\\\\beta_{h}\\end{bmatrix}} \\] where \\(n\\) is the number of samples. In the first step we create this matrix using model.matrix() that receives a formula with the variables to include in the models and the sample data. ## Define formula formula &lt;- ~ Group + Sex + flowcell + mitoRate + overallMapRate + totalAssignedGene + detected + ERCCsumLogErr ## Model matrix model &lt;- model.matrix(formula, data = colData(rse_gene_filt)) head(model) #&gt; (Intercept) GroupExperimental SexM flowcellHKCMHDSXX flowcellHKCNKDSXX flowcellHKCTMDSXX mitoRate overallMapRate #&gt; 1 1 0 0 0 1 0 0.03876995 0.9811 #&gt; 2 1 1 0 0 1 0 0.03337699 0.9791 #&gt; 3 1 0 1 0 1 0 0.03606147 0.9825 #&gt; 4 1 1 1 1 0 0 0.03962591 0.9855 #&gt; totalAssignedGene detected ERCCsumLogErr #&gt; 1 0.7715862 26545 -67.33211 #&gt; 2 0.7778447 24545 -66.38868 #&gt; 3 0.7870034 25640 -58.89350 #&gt; 4 0.7786461 25905 -84.91929 #&gt; [ reached getOption(&quot;max.print&quot;) -- omitted 2 rows ] ❓ Which variables to include as covariates in the models? A straightforward strategy is to keep the model as simple as possible and after fitting the model evaluate the comparisons of interest [3]. In Chapter XX we have discussed how correlation and variance partition analyses can help us to set up the best models. ⚠️ Very important: always check which condition group is set as the reference in you model for the coefficient/contrast of interest (column named as [Coefficient_name][Reference_Group]) as this determines if a DEG is up or downregulated in the given condition compared to the other. ## Comparison of interest: Group coef &lt;- &quot;GroupExperimental&quot; 📝 Exercise 2: perform a variance partition analysis (see Chapter XX:DGE model building with variancePartition) to select the sample variables to include in your models for DGE based on your data and create the respective design matrix. 21.2.2 voom() Compared to NB-based methods, limma works with \\(log(cpm)\\) which are approximately normally distributed (as we have seen) and thus, opens the possibility to leverage a wide range of normal-based statistical tools not available for count distributions, including methods developed for microarray data. However, limma doesn’t assume nor require data to follow a normal distribution, but it does apply normal-based microarray-like statistical methods to RNA-seq read counts [2]. “… limma does not make any assumption that the data appears normal in a histogram.” - Gordon Smyth, author of limma, in the Bioconductor support website 2021. The benefit of using \\(log(cpm)\\), however, is not immediate. One limitation for the direct application of normal-based methods to log-counts is that reads counts have unequal variabilities even after a log-transformation depending on the count sizes: probability distributions for counts are naturally heteroscedastic, with log-cpm not having constant variances (larger variances for larger counts) [2]. It has been proposed that to design powerful statistical analysis for RNA-seq, it is more important to model the relationship between the mean and the variance in the data than to specify which probabilistic distribution to use for the counts [2]. And importantly, converting count data taking such relationship into account does open up access to their analysis with normal-based methods. That’s why we use voom(). What voom() does is: First, to compute log-cpm. Log-normalized expression for gene \\(g\\) in sample \\(i\\) (\\(y_{gi}\\)) is given by \\[ y_{gi}=log_2(\\frac{r_{gi} + 0.5}{R_i + 1.0} \\times 10^6) \\] where \\(r_{gi}\\) is the raw count for the gene in the sample and \\(R_i\\) the library size of the sample. We add +0.5 to the counts to avoid log of zero and +1 to the library size to ensure that \\(\\frac{r_{gi}+0.5}{R_i+1}\\) is strictly less than 1 (if \\(r_{gi} = R_i\\)). A linear model is fitted to gene log-cpm values by ordinary least squares as: \\[ E(y_{gi})=\\mu_{gi}=X_i\\beta_g \\] where \\(E(y_{gi})\\) is the expected expression of gene \\(g\\) in sample \\(i\\), \\(X_i\\) is the vector with the sample values for the covariates and \\(\\beta_g\\) the vector of covariate coefficients for the gene. As a result, we have the estimated \\(\\hat\\beta_g\\), the fitted log-cpm’s \\(\\hat\\mu_{gi}=X_i\\hat\\beta_g\\) and the residual standard deviations \\(s_g\\). Then it estimates the mean-variance trend of the data by fitting a smooth curve to the \\(\\sqrt s_g\\) of the genes presented as a function of the average gene expression (in log-counts, not log-cpm). The \\(\\sqrt s_g\\)’s are used because they are symmetrically distributed. Log-counts typically show a decreasing mean-variance trend. voom() then predicts the standard deviation of each individual normalized observation \\(y_{gi}\\) (limma-trend does that at the gene level) using this trend curve: the fitted log-count of each observation is mapped to the curve and its \\(\\sqrt s_{gi}\\)value is obtained. The observation weights are \\(w_{gi}=\\frac{1}{s_{gi}^2}\\). Figure 2: voom() procedure to estimate observation-level variance weights for limma. Extracted from the original voom publication ( Law, C. W. et al. 2018). Log-cpm (\\(y_{gi}\\)) and associated weights (\\(w_{gi}\\)) can then be entered into the limma framework for linear modeling. These weights are used in the linear modeling to adjust for count heteroscedasticity [2]. library(&quot;limma&quot;) ## voom(): # 1. Transform counts to log2(cpm) # ---------------------------------------------------------------------------- #. | Note we passed voom() raw counts as input, not the lognorm counts!!! | # ---------------------------------------------------------------------------- # 2. Estimate mean-variance relationship for each gene # 3. Compute observation weights for limma (next step) vGene &lt;- voom(assay(rse_gene_filt), design = model, plot = TRUE) Let’s explore the outpus of this function. ## Returned data names(vGene) #&gt; [1] &quot;E&quot; &quot;weights&quot; &quot;design&quot; &quot;targets&quot; ## E: contains the computed log(cpm) dim(vGene$E) #&gt; [1] 19974 42 vGene$E[1:5, 1:5] #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; ENSMUSG00000051951.5 5.906572 6.1425731 5.7434780 6.133741 6.061250 #&gt; ENSMUSG00000102331.1 -1.512368 -0.9445475 -1.9587859 -1.306258 -1.024247 #&gt; ENSMUSG00000025900.13 -2.074247 -1.9918532 -0.3738234 -1.736892 -1.691672 #&gt; ENSMUSG00000025902.13 1.446325 1.2611275 1.3707154 1.419026 1.688471 #&gt; ENSMUSG00000098104.1 1.572354 1.2408075 1.4727667 1.404882 1.533748 ## weights: contains the computed variance weight for each observation dim(vGene$weights) #&gt; [1] 19974 42 vGene$weights[1:5, 1:5] #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] 143.326885 117.323375 139.214140 141.247546 128.818305 #&gt; [2,] 4.255525 4.277395 2.698902 5.113520 3.377285 #&gt; [3,] 4.009671 3.341317 5.555186 4.020098 2.546810 #&gt; [4,] 20.584769 15.108579 15.521441 19.219652 16.893714 #&gt; [5,] 22.473314 16.369739 18.359068 17.691839 14.325510 ## design: is the provided design matrix head(vGene$design) #&gt; (Intercept) GroupExperimental SexM flowcellHKCMHDSXX flowcellHKCNKDSXX flowcellHKCTMDSXX mitoRate overallMapRate #&gt; 1 1 0 0 0 1 0 0.03876995 0.9811 #&gt; 2 1 1 0 0 1 0 0.03337699 0.9791 #&gt; 3 1 0 1 0 1 0 0.03606147 0.9825 #&gt; 4 1 1 1 1 0 0 0.03962591 0.9855 #&gt; totalAssignedGene detected ERCCsumLogErr #&gt; 1 0.7715862 26545 -67.33211 #&gt; 2 0.7778447 24545 -66.38868 #&gt; 3 0.7870034 25640 -58.89350 #&gt; 4 0.7786461 25905 -84.91929 #&gt; [ reached getOption(&quot;max.print&quot;) -- omitted 2 rows ] ## targets: the sample library sizes used to compute log(cpm) in the first step dim(vGene$targets) #&gt; [1] 42 1 head(vGene$targets) #&gt; lib.size #&gt; 1 44218086 #&gt; 2 29831069 #&gt; 3 36929795 #&gt; 4 38331383 #&gt; 5 27457620 #&gt; 6 27113922 identical(vGene$targets$lib.size, colSums(assay(rse_gene_filt))) #&gt; [1] TRUE ➡️ In summary, voom() estimates non-parametrically the global mean-variance trend of the count data based on the expression of the genes and uses that to predict the variance of each individual expression observation (each log-cpm value) based on their predicted count sizes. The predicted variances are then associated as inverse weights to each observation that when used in linear modeling eliminate the log-cpm mean-variance trend [2]. 👉🏼 Advantages: ✅ voom() estimates the mean-variance relationship in a non-parametric way. “The parametric advantages of the Poisson or NB distributions are mitigated by the fact that the observed mean-variance relationship of RNA-seq data does not perfectly match the theoretical mean-variance relationships inherent in these distributions. While the quadratic mean-variance relationship of the NB distribution captures most of the mean-variance trend, the NB dispersion still shows a non-ignorable trend with gene abundance.” [2] ✅ Since voom() is a method to adapt count data to normal models, these give access to tractable empirical Bayes distribution theory. ✅ The use of normal distribution approaches and variance modeling is supported by generalized linear model theory. 📝 Exercise 3: compute the \\(log(cpm)\\) and the residual variance weights for each observation in your data using voom(). 21.2.3 lmFit() This limma function fits a multiple linear model to the expression of each gene by weighted or generalized least squares to estimate the coefficients of the sample covariates which correspond to the logFC’s comparing gene expression between sample groups. Ordinary least squares (OLS) This is used to estimate the coefficients of a linear regression by minimizing the residual sum of squares [5]. Figure 3: Graphical representation of the OLS method for simple regression analysis . Source: Gulve, A. (2020). Ordinary Least Square (OLS) Method for Linear Regression. For simplicity, let’s work with one gene and say we have \\(n\\) samples. The fitted expression of the gene in the \\(j\\)th sample is \\(\\hat y_j =\\beta_{0} + \\sum_{1}^h\\beta_{h}X_{jh}\\) , where \\(\\beta_h\\) is the coefficient for the \\(h\\)th covariate and \\(X_{jh}\\) the value the \\(j\\)th sample takes for the \\(h\\)th covariate. It can also be written as \\(\\hat y_j =\\sum_{0}^h\\beta_{h}X_{jh}\\) if \\(X_{j0}=1\\). So we have an overdetermined system of \\(n\\) linear equations and \\(h\\) unknown parameters with \\(n&gt;h\\): \\(\\hat y_j =\\sum_{0}^h\\beta_{h}X_{jh}\\) with \\(j=(1,2, ..., n)\\). Such system usually has no exact solution, so we need to estimate the coefficients that better fit the data in a linear regression. The problem is reduced to solving a quadratic minimization problem: \\(\\hat \\beta=arg \\ _\\beta\\ min \\ \\ S(\\beta)\\) where \\(S(\\beta)=\\sum_j(y_j -\\hat y_j)^2=RSS\\) (residual sum of squares). 💡 We can think of these \\(\\beta\\)’s as differences in the fitted (expected) expression of a gene. Say we have two binary categorical variables in the model (\\(X_1\\) and \\(X_2\\)), then the expected gene expression in a sample is \\(E(y|X_1, X_2) =\\hat y =\\beta_{0} + \\beta_1X_1+\\beta_2X_2\\), where \\(X_1\\) and \\(X_2\\) equal to 1 or 0. Then we have the following 4 combinations: \\(E(y|X_1=1, X_2=1) = \\mu_{12}=\\beta_{0} + \\beta_1+\\beta_2\\) \\(E(y|X_1=1, X_2=0) =\\mu_{1}=\\beta_{0} + \\beta_1\\) \\(E(y|X_1=0, X_2=1) =\\mu_{2}=\\beta_{0} + \\beta_2\\) \\(E(y|X_1=0, X_2=0) =\\mu_{0}=\\beta_{0}\\) So \\(\\beta_1=\\) \\(\\mu_1-\\mu_0\\) \\(=\\) \\(\\mu_{12}-\\mu_2\\) and \\(\\beta_2=\\) \\(\\mu_2\\)\\(-\\) \\(\\mu_0\\). Say our variable of interest is \\(\\beta_1\\). Then what we are testing is if the expected expression of a gene is different when \\(X_1=1\\) (in the first sample group) and \\(X_1=0\\) (in the second sample group), fixing \\(X_2\\) in either 1 or 0. Generalized least squares (GLS) Is a generalization of OLS that allows for heteroskedasticity and correlation between the residuals [6]. Weighted least squares (WLS) In this case the function to be minimized becomes the weighted sum of the squared residuals: squared residuals are weighted by the reciprocal of their variance so that more noisy observations have less weight. That’s what we used voom() for. lmFit() returns a fitted model object with the estimated coefficients, standard errors (\\(SE=sd/\\sqrt n\\)) and residual standard errors/deviations (\\(RSE=s_g=\\sqrt {RSS/ n-2}\\)) for each gene. Depending on the arguments and correlations in the data, this function calls one of the following functions to fit a linear model for each gene [7]: mrlm: for a robust regression if method=\"robust”. gls.series: GLS estimator if method=\"ls” and a correlation structure has been specified. lm.series: OLS method if method=\"ls” and there is no correlation structure. For the weights argument of lmFit(), the precision weights for the observations previously computed are extracted from the voom() output. ## lmFit(): # 1. Fit linear model for each gene to estimate logFCs fitGene &lt;- lmFit(vGene) ## Corroborate &quot;ls&quot; method was applied fitGene$method #&gt; [1] &quot;ls&quot; ## Explore outputs: estimated coefficients (logFCs) head(fitGene$coefficients) #&gt; (Intercept) GroupExperimental SexM flowcellHKCMHDSXX flowcellHKCNKDSXX flowcellHKCTMDSXX #&gt; ENSMUSG00000051951.5 -35.637900 -0.05125195 0.05690091 -0.47469588 -0.38545404 -0.66545820 #&gt; ENSMUSG00000102331.1 37.943310 0.72450620 0.19887963 -0.20803712 -0.40926270 -0.10900553 #&gt; ENSMUSG00000025900.13 -43.586603 0.17256694 0.28895786 -0.04476551 0.15257245 -0.06949759 #&gt; ENSMUSG00000025902.13 5.657837 -0.05025788 -0.04808144 -0.18732331 -0.26041436 0.07364071 #&gt; mitoRate overallMapRate totalAssignedGene detected ERCCsumLogErr #&gt; ENSMUSG00000051951.5 -11.487040 37.443647 4.753830 6.442499e-05 -0.0043851842 #&gt; ENSMUSG00000102331.1 -21.871815 27.323603 -79.223111 -1.026687e-04 0.0166190950 #&gt; ENSMUSG00000025900.13 16.727251 7.179484 42.367908 8.535604e-05 0.0133260060 #&gt; ENSMUSG00000025902.13 -24.538883 11.174017 -18.548282 -1.231546e-05 -0.0092194951 #&gt; [ reached getOption(&quot;max.print&quot;) -- omitted 2 rows ] 💡 Interaction terms in linear models There may be cases where we want to assess gene expression differences between 2 conditions within more than one specific group; for example if we were interested in knowing what are the effects of a treatment (\\(X_1=1\\) for treatment and 0 for controls) in females and males separately (\\(X_2=1\\) for females and 0 for males). In such cases we can fit an interaction model in which we include the product of \\(X_1\\) and \\(X_2\\) so that \\(X_1X_2=1\\) if a sample comes from a female that was treated and 0 otherwise: \\[E(y|X_1, X_2) =\\beta_{0} + \\beta_1X_1+\\beta_2X_2 + \\beta_3X_1X_2\\] \\(E(y|X_1=1, X_2=1) =\\mu_{12} =\\beta_{0} + \\beta_1+\\beta_2+\\beta_3\\) \\(E(y|X_1=1, X_2=0) =\\mu_{1} =\\beta_{0} + \\beta_1\\) \\(E(y|X_1=0, X_2=1) =\\mu_{2} =\\beta_{0} + \\beta_2\\) \\(E(y|X_1=0, X_2=0) =\\mu_{0} =\\beta_{0}\\) \\(\\beta_1 + \\beta_3=\\) \\(\\mu_{12}-\\mu_2\\) which is the expression difference between treated and control female samples (\\(X_2=1\\)) and \\(\\beta_1 =\\) \\(\\mu_{1}-\\mu_0\\) for male samples (\\(X_2=0\\)). Finally \\(\\beta_3\\), called the interaction term, is (\\(\\mu_{12}-\\mu_2\\))\\(-\\)(\\(\\mu_1-\\mu_0\\)), described as the difference in gene expression changes driven by the treatment in females compared to males [8]. 📝 Exercise 4: fit a linear regression model to the expression data of your genes and extract the coefficients for the included covariates. 21.2.4 eBayes() Next, we want to assess if the differences in gene expression between the sample groups are statistically significant. Initially, we can think of comparing the mean expression of a gene in the sample groups (e.g. cases and controls) which can be handled applying a two-sample t-test assuming that the values in both groups have an approximately normal distribution. Here we use the t-score (t-stats) to define if the difference in the means is statistically significant based on a t-distribution. The t-stats is given by: \\[ t=\\frac{\\bar x_1 - \\bar x_2}{\\sqrt{\\frac{s_1^2}{n_1}+\\frac{s_2^2}{n_2}}} \\] where \\(\\bar x_1\\) and \\(\\bar x_2\\) are the means of the expression values of a gene in the first and second sample groups, \\(s_1\\) and \\(s_2\\) are the sample standard deviations of gene expression in the same groups, and \\(n_1\\), \\(n_2\\) the corresponding sample group sizes: \\(s_1 = \\sqrt{\\frac{\\sum_{i=1}^ {n_1} (x_i-\\bar x_1)^2}{n_1-1}}\\) and \\(s_2 = \\sqrt{\\frac{\\sum_{j=1}^ {n_2} (x_j-\\bar x_2)^2}{n_2-1}}\\), with \\(x_i\\) and \\(x_j\\) the gene expression values in the samples of group 1 and 2, respectively. ➡️ Note that we say sample means and sample standard deviations because they are estimators of the population parameters, computed based on the data that we have. We can think of this t-stats as a ratio of signal and noise. The numerator contains the difference between the two means, taken as the signal for DE. The denominator corresponds to the standard error and represents the noise in terms of gene expression variance within the sample groups. This represents how spread out the signal is [9]. In that way, the t-stats is a measure of how strong is the DE signal. Once computed, the t-stats have an associated p-value based on a Student t-distribution under the null hypothesis (\\(H_o\\): \\(\\bar x_1 - \\bar x_2=0\\)). This is exactly what we can get using lm(): ## Lognorm expression of first gene rse_gene_one_gene &lt;- rse_gene_filt[1,] colData(rse_gene_one_gene) &lt;- cbind(colData(rse_gene_one_gene), &quot;lognorm_expr&quot;= assays(rse_gene_one_gene)$logcounts[1,]) ## Fit simple linear model formula &lt;- lognorm_expr ~ Group lm &lt;- lm(formula, data = colData(rse_gene_one_gene)) summary(lm) #&gt; #&gt; Call: #&gt; lm(formula = formula, data = colData(rse_gene_one_gene)) #&gt; #&gt; Residuals: #&gt; Min 1Q Median 3Q Max #&gt; -1.05368 -0.06304 0.03012 0.10254 0.24844 #&gt; #&gt; Coefficients: #&gt; Estimate Std. Error t value Pr(&gt;|t|) #&gt; (Intercept) 5.75377 0.04502 127.800 &lt;2e-16 *** #&gt; GroupExperimental -0.04292 0.06694 -0.641 0.525 #&gt; --- #&gt; Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 #&gt; #&gt; Residual standard error: 0.2159 on 40 degrees of freedom #&gt; Multiple R-squared: 0.01017, Adjusted R-squared: -0.01457 #&gt; F-statistic: 0.4111 on 1 and 40 DF, p-value: 0.525 ## Two sample t-test t.test(formula, data = colData(rse_gene_one_gene), var.equal=TRUE) #&gt; #&gt; Two Sample t-test #&gt; #&gt; data: lognorm_expr by Group #&gt; t = 0.64121, df = 40, p-value = 0.525 #&gt; alternative hypothesis: true difference in means between group Control and group Experimental is not equal to 0 #&gt; 95 percent confidence interval: #&gt; -0.09236465 0.17820636 #&gt; sample estimates: #&gt; mean in group Control mean in group Experimental #&gt; 5.753765 5.710845 💡 Sample sizes are critical! Larger sample sizes increase the power of the tests and reduce the false discovery rate (FDR) as they decrease the denominator of the t-stats (increasing their values) and slight differences can then be detected. ⚠️ Now consider that for genes with small variances in their expression the t-stats will be greater and we could be detecting non-DEGs as DE (false positives). But two things must be considered at least when working with gene expression data: The first is that expression values are usually not normally distributed. Second, the distributions and variances of expression values vary across genes and conditions. ➡️ With that in mind, inference at the individual gene level can be addressed borrowing information from all the genes in the experiment through a Bayes or empirical Bayes method that produces more powerful tests. The idea of Bayesian statistics is to give unknown quantities a prior distribution, considering each feature as a member of a population of features such as genes. More specifically, empirical Bayes methods are procedures for statistical inference in which the (empirical) prior distribution is estimated from the population of all features (from the data) [8]; in standard Bayesian methods this prior distribution is fixed before observing any data [10]. Inspired by the work of Lönnstedt and Speed (2002) in which a simple expression for the posterior odds of differential expression for each gene was computed using a parametric empirical Bayes approach, Smyth, G. K. (2004) generalized this model for its application to experiments with any numbers of samples and conditions and reformulated the posterior odds statistic in terms of a moderated t-statistic in which the posterior residual standard deviations are used instead of the ordinary ones, eliminating the requirement of knowing the non-null prior guess for the proportion of differentially expressed genes required in the log-odds [11]. Let’s see how it proceeds. First, for each gene \\(g\\) we have a vector with the expression values in the \\(n\\) samples: \\[ y_{g}= (y_{g1}, y_{g2}, ..., y_{gn}) \\] We already know that the expected (predicted) gene expression in the samples is \\(E(y_{g})=X\\alpha_g\\) with \\(X\\) the design matrix and \\(\\alpha_g\\) the vector of the coefficients for the \\(h\\) covariates in the model; of these the ones of biological interest are the \\(\\beta_g\\)’s (contrasts of interest). Then, as previously described, a linear model is fitted to the expression data for each gene to obtain the coefficient estimators (\\(\\hat \\alpha_g\\)) (as well as \\(\\hat \\beta_g\\)), the residual sample variances (\\(s_g^2\\)) as estimators of the (true but unknown) residual variances (\\(\\sigma_g^2\\)), and the estimated covariance matrices. Two relevant considerations here: The expression values are not necessarily assumed to be normally distributed. The linear model is not assumed to be necessarily by least squares. However, there are two assumptions: The contrast estimators \\(\\hat \\beta_g\\) are assumed to be approximately normally distributed with mean \\(\\beta_g\\). The residual sample variances (\\(s_g^2\\)) are assumed to follow approximately a scaled chisquare distribution. Under such assumptions the ordinary t-stats for the covariate \\(j\\) in the gene \\(g\\) is defined by: \\[ t_{gj}=\\frac{\\hat \\beta_{gj}}{s_g u_{gj}}=\\frac{\\hat \\beta_{gj}}{SE(\\hat \\beta_{gj})} \\] with \\(s_g\\) the residual sample standard deviation of the gene and \\(u_{gj}\\) the unscaled standard deviation. \\(SE\\) stands for standard error. The key step in the empirical Bayes approach of limma is to leverage the information across all genes by defining prior distributions for the unknown coefficients \\(\\beta_{gj}\\) and residual variance \\(\\sigma_g^2\\) of the genes. For \\(\\beta_{gj}\\) it models the prior distribution of the coefficients that are not zero, i.e. is the expected distribution of the logFC of the genes that are DE, is given by: \\[\\beta_{gj}|\\sigma_{g}^2, \\beta_{gj}≠0 \\sim N(0, v_{0j}\\sigma_g^2)\\] “Saying that the betas have prior information centered around zero implies that we are ignorant of the sign (+/-) of the beta.” – Vincent Carey (personal communication) For the residual variances what limma does is to take the residual sample variances of all genes (\\(s_g^2\\)’s) and estimate the empirical parameters of the gamma distribution it is assumed that they follow. Specifically, \\(\\frac{1}{\\sigma_g^2}\\) is modeled by a scaled chisquare (gamma) prior distribution with mean \\(\\frac{1}{s_0^2}\\) and \\(d_0\\) degrees of freedom, describing how the residual variances are expected to vary across genes: \\[\\frac{1}{\\sigma_g^2} \\sim \\frac{1}{d_0s_0^2}\\chi_{d_0}^2\\] What we want to do next is not only to take the mean of the residual variances in the distribution (prior mean\\(\\frac{1}{s_0^2}\\)) but to estimate each gene residual variance as a Bayes predictor: as a weighted average of the prior mean (\\(\\frac{1}{s_0^2}\\)) and the observed sample variance (\\(s_g^2\\)) of each gene. This is called the moderated variance and what is graphically happening is that we are pulling the observed gene variances towards the prior mean variance: large variances are reduced and the |t-stats| increases (more powerful t-test for those genes) and small variances are increased, decreasing the |t-stats| and the power of the t-test. Under this model the posterior residual sample variance or posterior residual variance estimator (\\(\\tilde s_g^2\\)) is: \\[ \\tilde s_g^2=E(\\sigma_g^2|s_g^2)=\\frac{d_0s_0^2 + d_gs_g^2}{d_0+d_g} \\] Moderation is somehow like having larger sample sizes for the estimation of variance given that the moderated variances are (on average) closer to the population variance than the original sample variances. The moderated t-statistic can be now defined in terms of this posterior residual sample standard deviations instead of the usual ones: \\[ \\tilde t_{gj}=\\frac{\\hat \\beta_{gj}}{\\tilde s_g u_{gj}} \\] These moderated t-stats follow a t-distribution under the null hypothesis (\\(H_o:B_{gj}=0\\)) with degrees of freedom \\(d_g+d_0\\) and the associated p-values can be computed based on such distribution. As previously stated, with this redefined formula, large t-stats merely from very small \\(s_g\\)’s are avoided. This results in increased power and reduced false non-discovery rate (FNR) (non detected DEGs) and the number of DEGs obtained increases [8]. In the end we say we have moderated the residual sample standard deviations of each gene in the t-stats denominator by using the distribution of all of them across the population of genes. ✅ The approach of using the posterior values results in shrinking the gene-wise residual sample variances (\\(s_g^2\\)) towards the prior mean, making a more stable inference when a small number of samples is available. eBayes() will implement this empirical Bayes model to compute for each gene and for each contrast these moderated t-statistic and their unadjusted p-values. Additionally, it returns moderated F-statistic and log-odds of differential expression. The moderated F-statistic tests whether any of the contrasts for a gene is non-zero (\\(H_0:B_{g}=0\\)), i.e., whether that gene is differentially expressed for any contrast; it is similar to the ordinary F-statistic from analysis of variance (ANOVAR). The t-test does that for each individual contrast \\(j\\) (\\(H_0:B_{gj}=0\\)). 👉🏼 Check more about F-stats and other statistics computed by eBayes() here: https://support.bioconductor.org/p/6124/. ## eBayes() ## 1. Compute the empirical Bayes statistics for DE eBGene &lt;- eBayes(fitGene) ## Outputs of interest: ## s2.prior -&gt; prior residual variance (prior mean 1/s0^2) ## in prior distribution of residual variances eBGene$s2.prior #&gt; [1] 0.78987 ## df.prior -&gt; degrees of freedom d0 in prior distribution ## of residual variances eBGene$df.prior #&gt; [1] 4.913248 ## s2.post -&gt; posterior residual sample variances of the genes (~sg^2) length(eBGene$s2.post) #&gt; [1] 19974 head(eBGene$s2.post) #&gt; [1] 2.3397702 0.7092520 1.1613995 0.9579389 0.7390718 0.4996251 ## t -&gt; moderated t-stats of the genes for each contrast dim(eBGene$t) #&gt; [1] 19974 11 eBGene$t[1:5, 1:5] #&gt; (Intercept) GroupExperimental SexM flowcellHKCMHDSXX flowcellHKCNKDSXX #&gt; ENSMUSG00000051951.5 -4.4458336 -1.0615386 1.2467597 -4.8896590 -4.2555598 #&gt; ENSMUSG00000102331.1 1.5930925 4.5298885 1.3144392 -0.6934431 -1.3930231 #&gt; ENSMUSG00000025900.13 -1.2896585 0.8392518 1.4887297 -0.1047634 0.3829694 #&gt; ENSMUSG00000025902.13 0.4035855 -0.5885950 -0.5891347 -1.0922124 -1.6131630 #&gt; ENSMUSG00000098104.1 0.7120536 -0.3614893 -1.0031002 0.6473100 1.0165548 ## p.value: corresponding unadjusted p-values of moderated t-stats dim(eBGene$p.value) #&gt; [1] 19974 11 eBGene$p.value[1:5, 1:5] #&gt; (Intercept) GroupExperimental SexM flowcellHKCMHDSXX flowcellHKCNKDSXX #&gt; ENSMUSG00000051951.5 8.086618e-05 2.955320e-01 0.2205562 2.114989e-05 0.0001425797 #&gt; ENSMUSG00000102331.1 1.199041e-01 6.283899e-05 0.1970317 4.924924e-01 0.1721763827 #&gt; ENSMUSG00000025900.13 2.054130e-01 4.068800e-01 0.1452882 9.171465e-01 0.7039999597 #&gt; ENSMUSG00000025902.13 6.889106e-01 5.598170e-01 0.5594589 2.820128e-01 0.1154631942 #&gt; ENSMUSG00000098104.1 4.810321e-01 7.198519e-01 0.3225237 5.215478e-01 0.3161651149 📝 Exercise 5: obtain the moderated t-stats and associated p-values of all genes in you data for all covariates included in your model. 21.2.5 topTable() This function is also provided by limma and summarizes the results of the linear model, performs hypothesis tests and adjusts the p-values for multiple testing [12]. Among the summary statistics presented, it returns the log2FCs, moderated t-statistics, p-values, and FDR-adjusted p-values of the genes for a given contrast of interest. The default form of p-value adjustment is the Benjamini and Hochberg’s method to control the false discovery rate (FDR) which assumes independence between genes. Relevant concepts: q-value → is the FDR-adjusted p-value used to control the False Discovery Rate (FDR) that is the expected proportion of false discoveries among the discoveries (DEGs). Selecting discoveries as those being below \\(\\alpha\\) in q-value, we control FDR ≤ \\(\\alpha\\). Now we have the final statistics to determine wich genes are DE. ## topTable() ## 1. Obtain gene-wise DE stats for Group (Nicotine vs Ctrl) top_genes &lt;- topTable(eBGene, coef = coef, p.value = 1, number = nrow(rse_gene_filt), sort.by = &quot;none&quot;) ## Outputs for each gene and for the coeff selected (Group): ## logFC: log2-fold-changes head(top_genes$logFC) #&gt; [1] -0.05125195 0.72450620 0.17256694 -0.05025788 -0.02726320 -0.02684710 In limma the \\(\\beta_{gj}\\)’s are the logFC’s: setdiff(top_genes$logFC, eBGene$coefficients[,&#39;GroupExperimental&#39;]) #&gt; numeric(0) ## t: moderated t-stats head(top_genes$t) #&gt; [1] -1.0615386 4.5298885 0.8392518 -0.5885950 -0.3614893 -1.0959528 ##. P.value: unadjusted p-values of t-stats head(top_genes$P.Value) #&gt; [1] 2.955320e-01 6.283899e-05 4.068800e-01 5.598170e-01 7.198519e-01 2.803946e-01 ## adj.P.Val: p-values adjusted to control the FDR head(top_genes$adj.P.Val) #&gt; [1] 0.53854173 0.00412576 0.63704026 0.75340755 0.85943342 0.52324928 After running all these 5 steps, one main initial plot we have to look at is the histogram of the p-values of the moderated t-stats of the genes. If there were DEGs, we’d expect to see a flat distribution of p-values corresponding to non-DEGs and a peak near p=0 for DEGs (for which we reject the null hypothesis). If this peak is absent but a uniform distribution still appears, DEGs might be detected after correcting for multiple testing. ## Histogram of unadjusted p-values hist(top_genes$P.Value, xlab = &quot;p-values&quot;, main = &quot;&quot;) If very different p-value distributions are obtained from the uniform one, the best we can do is trying to explore if there are specific groups of genes (e.g. lowly-expressed genes) presenting such variable p-values and revisiting the assumptions and considerations of the statistical tests implemented [13]. 📝 Exercise 6: obtain the DE logFCs, t-stats, p-values, and adjusted p-values of the genes for a given constrast/covariate under study. 21.3 DE visualization DEGs are identified defining a significance threshold (on the adjusted p-values). Let’s quantify the number of DEGs for nicotine exposure in pup brain and visualize their expression and DE statistics. ## DEGs for FDR&lt;0.05 de_genes &lt;- top_genes[which(top_genes$adj.P.Val&lt;0.05), ] ## Number of DEGs dim(de_genes) #&gt; [1] 1895 6 21.3.1 Volcano plots A very practical and useful plot to graphically represent DEGs and visualize their expression differences between conditions is a volcano plot. This is a scatter plot of the logFC’s of the genes in the x-axis vs their adjusted p-values in a -log scale in the y-axis. library(&quot;ggplot2&quot;) ## Define up- and down-regulated DEGs, and non-DEGs FDR = 0.05 DE&lt;-vector() for (i in 1:dim(top_genes)[1]) { if (top_genes$adj.P.Val[i]&gt;FDR) { DE&lt;-append(DE, &quot;n.s.&quot;) } else { if (top_genes$logFC[i]&gt;0) { DE&lt;-append(DE, &quot;Up&quot;) } else { DE&lt;-append(DE, &quot;Down&quot;) } } } top_genes$DE&lt;- DE ## Colors, sizes and transparencies for up &amp; down DEGs and non-DEGs cols &lt;- c(&quot;Up&quot; = &quot;indianred2&quot;, &quot;Down&quot; = &quot;steelblue2&quot;, &quot;n.s.&quot; = &quot;grey&quot;) sizes &lt;- c(&quot;Up&quot; = 1.3, &quot;Down&quot; = 1.3, &quot;n.s.&quot; = 0.8) alphas &lt;- c(&quot;Up&quot; = 0.4, &quot;Down&quot; = 0.6, &quot;n.s.&quot; = 0.5) ## Plot volcano plot ggplot(data = top_genes, aes(x = logFC,y = -log10(adj.P.Val), color = DE, fill = DE, size = DE, alpha = DE)) + geom_point(shape = 21) + geom_hline(yintercept = -log10(FDR), linetype = &quot;dashed&quot;, color = &#39;gray35&#39;, linewidth=0.5) + geom_vline(xintercept = c(-1,1), linetype = &quot;dashed&quot;, color = &#39;gray35&#39;, linewidth=0.5) + labs(y=&quot;-log10(FDR)&quot;, x=&quot;logFC(Nicotine vs Control)&quot;)+ theme_bw() + scale_color_manual(values = cols, name=&quot;Differential expression&quot;) + scale_fill_manual(values = cols, name=&quot;Differential expression&quot;) + scale_size_manual(values = sizes, name=&quot;Differential expression&quot;) + scale_alpha_manual(values = alphas, name=&quot;Differential expression&quot;) + theme(plot.margin = unit(c(1,1,1,1), &quot;cm&quot;), legend.key.height = unit(0.15,&quot;cm&quot;), axis.title = element_text(size = (13)), legend.title = element_text(size=13), legend.text = element_text(size=12)) 21.3.2 Heat maps Another common way to represent differential expression results is through a heat map. The package ComplexHeatmap offers a flexible toolkit to easily create heat maps with row and column annotations, a feature of particular value to plot expression data of genes across samples with multiple biological and technical differences. Although initially all genes in your data can be plotted, frequently only DEGs are included as they tend to show clearer gene expression patterns. library(&quot;ComplexHeatmap&quot;) ## We plot lognorm counts lognorm_data&lt;- assays(rse_gene_filt)$logcounts ## Subset to DEGs only lognorm_data &lt;- lognorm_data[rownames(de_genes),] ## Define column (sample) names to display colnames(lognorm_data) &lt;- paste0(&quot;Pup_&quot;, 1:dim(lognorm_data)[2]) 🗒️ Notes: It is sometimes convenient to regress out the technical variables’ contributions on gene expression to see more clearly the effects of interest. This can happen, for instance, when the logFCs are too small to see any significant differences in the plots or when there are other strong confounding factors. Functions such as cleaningY() of jaffelab can be used for this purpose. The lognorm counts have to be correctly scaled and centered (around zero) to make the differences in the expression of the genes more notorious in the heat map. A simple way to do that is substracting from each lognorm count \\(y_{gi}\\) (from the gene \\(g\\) and sample \\(i\\)) the mean expression of the gene* and dividing by the standard deviation (\\(\\sigma\\)) of the same gene expression values. This is formally called the z-score: the number of standard deviations away from the mean. \\[ z=\\frac{y_{gi} - \\frac{\\sum_{k=1}^{n}{y_{gk}}}{n}}{\\sigma}, \\] \\(n\\) is the number of samples. * This can also be done by columns (samples), not only by rows (genes). 👉🏼 For more on centering and scaling, see this video: ## Center and scale the data to make differences more evident lognorm_data &lt;- (lognorm_data - rowMeans(lognorm_data)) / rowSds(lognorm_data) ## Sample annotation: Sex, Group, and library size col_anno &lt;- HeatmapAnnotation( df = as.data.frame(colData(rse_gene_filt)[, c(&quot;Sex&quot;, &quot;Group&quot;)]), library_size = anno_barplot(colData(rse_gene_filt)$sum, gp = gpar(fill = &quot;lightyellow2&quot;)), col = list(&quot;Sex&quot; = c(&quot;F&quot; = &quot;hotpink1&quot;, &quot;M&quot; = &quot;dodgerblue&quot;), &quot;Group&quot; = c(&quot;Control&quot; = &quot;gray68&quot;, &quot;Experimental&quot; = &quot;gold2&quot;)) ) ## Gene annotation: logFC and biotype de_genes$logFC_binary &lt;- sapply(de_genes$logFC, function(x){if(x&gt;0){&quot;&gt;0&quot;} else{&quot;&lt;0&quot;}}) de_genes$protein_coding_gene &lt;- sapply(rowData(rse_gene_filt[rownames(de_genes), ])$gene_type, function(x){ if(x==&quot;protein_coding&quot;){&quot;TRUE&quot;} else{&quot;FALSE&quot;}}) gene_anno &lt;- rowAnnotation( df = as.data.frame(cbind(&quot;logFC&quot; = de_genes$logFC_binary, &quot;protein_coding_gene&quot;= de_genes$protein_coding_gene)), col = list(&quot;logFC&quot; = c(&quot;&lt;0&quot;=&quot;deepskyblue3&quot;, &quot;&gt;0&quot;=&quot;brown2&quot;), &quot;protein_coding_gene&quot; = c(&quot;TRUE&quot;=&quot;darkseagreen3&quot;, &quot;FALSE&quot;=&quot;magenta&quot;)) ) library(&quot;circlize&quot;) ## Plot Heatmap(lognorm_data, name = &quot;lognorm counts&quot;, show_row_names = FALSE, top_annotation = col_anno, left_annotation = gene_anno, row_km = 2, column_km = 2, col = colorRamp2(c(-4, -0.0001, 00001, 4), c(&quot;darkblue&quot;, &quot;lightblue&quot;, &quot;lightsalmon&quot;, &quot;darkred&quot;)), row_title = &quot;DEGs&quot;, column_title = &quot;Samples&quot;, column_names_gp = gpar(fontsize = 7), heatmap_width = unit(12.5, &quot;cm&quot;), heatmap_height = unit(12.5, &quot;cm&quot;) ) 📝 Exercise 7: obtain the number of DEGs you got and represent them in a volcano plot and a heat map. Include all the sample and gene information you consider relevant in the latter. 21.4 References Li, W. V., &amp; Li, J. J. (2018). Modeling and analysis of RNA‐seq data: a review from a statistical perspective. Quantitative Biology, 6(3), 195-209. Law, C. W., Chen, Y., Shi, W., &amp; Smyth, G. K. (2014). voom: Precision weights unlock linear model analysis tools for RNA-seq read counts. Genome biology, 15(2), 1-17. Smyth, G. K., Ritchie, M., Thorne, N., Wettenhall, J., Shi, W., &amp; Hu, Y. (2002). limma: linear models for microarray and RNA-Seq data user’s guide. Bioinformatics Division, The Walter and Eliza Hall Institute of Medical Research, Melbourne, Australia. van den Berg, S. M. (2022). Analysing data using linear models. Web site: https://bookdown.org/pingapang9/linear_models_bookdown/ Wikipedia. (n.d.). Ordinary least squares. Web site: https://en.wikipedia.org/wiki/Ordinary_least_squares Taboga, Marco (2021). “Generalized least squares”, Lectures on probability theory and mathematical statistics. Kindle Direct Publishing. Online appendix. https://www.statlect.com/fundamentals-of-statistics/generalized-least-squares. Documentation for lmFit: https://rdrr.io/bioc/limma/man/lmFit.html The Pennsylvania State University. (2018). Statistical Analysis of Genomics Data. Web site: https://online.stat.psu.edu/stat555/node/36/ Tushe, M. (2021). A Simple Trick to Understand the t-test. Web site: https://miroslavtushev.medium.com/a-simple-trick-to-understand-the-t-test-2c2a9e7f1dc5 Wikipedia. (n.d.). Empirical Bayes method. Web site: https://en.wikipedia.org/wiki/Empirical_Bayes_method#:~:text=Empirical Bayes methods are procedures,before any data are observed. Smyth, G. K. (2004). Linear models and empirical bayes methods for assessing differential expression in microarray experiments. Statistical applications in genetics and molecular biology, 3(1). Documentation for topTable: https://www.rdocumentation.org/packages/limma/versions/3.28.14/topics/toptable Robinson, D. (2014). How to interpret a p-value histogram. Web site: http://varianceexplained.org/statistics/interpreting-pvalue-histogram/ "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
