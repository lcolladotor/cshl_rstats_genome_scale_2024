[["index.html", "Statistical Analysis of Genome Scale Data 2024 Overview Download course materials Code of Conduct Course Schedule External links Course Prerequisites R session information License", " Statistical Analysis of Genome Scale Data 2024 Leonardo Collado-Torres Overview Here you can find the files for the June 2024 Statistical Analysis of Genome Scale Data course at CSHL portion taught by Leo and his team (June 9-11). Instructor: Leonardo Collado-Torres, Twitter Teach assistants: Daianna González Padilla, Twitter Melissa Mayén Quiroz, Twitter Happy to welcome @lcolladotor, @SubmarineGene, and @daianna_glez to @cshlcourses on Statistical Analysis of Genome Scale Data. Materials here:https://t.co/0JGzEEf3Yx — Sean Davis (@seandavis12) July 3, 2023 Interested in learning R/@Bioconductor for #RNAseq data analysis?Check https://t.co/jcNWOq7VWD that @daianna_glez @SubmarineGene and I built for a CSHL course organized by @seandavis12 &amp; Vincent Carey#rstats @LieberInstitute @cshlcourses Source at https://t.co/aQ8kLMadSl ⭐️ — 🇲🇽 Leonardo Collado-Torres (@lcolladotor) July 10, 2023 Download course materials Download the materials for this course with usethis::use_course('lcolladotor/cshl_rstats_genome_scale_2024') or view online at lcolladotor.github.io/cshl_rstats_genome_scale_2024. This command downloads a static version of the course materials. If you want to be able to easily download updates, we recommend using Git. Happy Git and GitHub for the useR is great for getting your computer ready to use Git and GitHub. If you already have a GitHub account, you can instead use this command to download the course: ## Download it the first time git clone https://github.com/lcolladotor/cshl_rstats_genome_scale_2024.git ## To update the contents, use: cd cshl_rstats_genome_scale_2024 git pull Or you could use the GitHub Desktop application. Code of Conduct We’ll follow the CSHL code of conduct as well as version 1.2.0 of the Bioconductor code of conduct bioconductor.github.io/bioc_coc_multilingual/. For reporting any violations of the code of conduct, report them to the Instructor and/or Course Coordinators. Course Schedule Local times in US Eastern See CSHLData2023 for the detailed schedule. Below is a list of the key packages we will use each day: Monday July 3rd: SummarizedExperiment, iSEE, smokingMouse, biocthis Tuesday July 4th: recount3, ExploreModelMatrix, limma Wednesday July 5th: variancePartition, ComplexHeatmap Thursday July 6th: spatialLIBD External links CSHL course GitHub source code Slack Example real project (by Daianna): LieberInstitute/smokingMouse_Indirects SPEAQeasyWorkshop2023 for BioC2023 (by Daianna and Renee): LieberInstitute/SPEAQeasyWorkshop2023 LieberInstitute/template_project LIBD rstats club: check the public schedule Course Prerequisites Install R 4.3.x from CRAN then install the following R packages: ## For installing Bioconductor packages if (!requireNamespace(&quot;BiocManager&quot;, quietly = TRUE)) { install.packages(&quot;BiocManager&quot;) } ## Install required packages BiocManager::install( c( &quot;usethis&quot;, ## Utilities &quot;BiocFileCache&quot;, &quot;RefManageR&quot;, &quot;gitcreds&quot;, &quot;gert&quot;, &quot;gh&quot;, &quot;here&quot;, &quot;Hmisc&quot;, &quot;biocthis&quot;, &quot;lobstr&quot;, &quot;postcards&quot;, &quot;scater&quot;, &quot;sessioninfo&quot;, &quot;smokingMouse&quot;, &quot;stringr&quot;, &quot;SummarizedExperiment&quot;, ## Main containers / vis &quot;iSEE&quot;, &quot;edgeR&quot;, ## RNA-seq &quot;ExploreModelMatrix&quot;, &quot;limma&quot;, &quot;recount3&quot;, &quot;rlang&quot;, &quot;scRNAseq&quot;, &quot;pheatmap&quot;, ## Visualization &quot;ggplot2&quot;, &quot;ggrepel&quot;, &quot;patchwork&quot;, &quot;RColorBrewer&quot;, &quot;ComplexHeatmap&quot;, &quot;cowplot&quot;, &quot;Polychrome&quot;, &quot;spatialLIBD&quot;, ## Advanced &quot;variancePartition&quot; ) ) ## Install smokingMouse, which is currently under review at Bioconductor ## at https://github.com/Bioconductor/Contributions/issues/3024. BiocManager::install(&quot;LieberInstitute/smokingMouse&quot;) ## Required to access some recent bug fixes on biocthis BiocManager::install(&quot;lcolladotor/biocthis&quot;) You will also need to install RStudio version 2023.06.0+421 or newer. R session information Details on the R version used for making this book. The source code is available at lcolladotor/cshl_rstats_genome_scale_2024. ## Load the package at the top of your script library(&quot;sessioninfo&quot;) ## Utilities library(&quot;BiocFileCache&quot;) library(&quot;BiocStyle&quot;) library(&quot;biocthis&quot;) library(&quot;gitcreds&quot;) library(&quot;gert&quot;) library(&quot;gh&quot;) library(&quot;here&quot;) library(&quot;lobstr&quot;) library(&quot;postcards&quot;) library(&quot;usethis&quot;) library(&quot;sessioninfo&quot;) ## Data library(&quot;smokingMouse&quot;) library(&quot;scRNAseq&quot;) ## Main containers / vis library(&quot;SummarizedExperiment&quot;) library(&quot;iSEE&quot;) ## RNA-seq library(&quot;edgeR&quot;) library(&quot;ExploreModelMatrix&quot;) library(&quot;limma&quot;) library(&quot;recount3&quot;) ## QCA library(&quot;scater&quot;) ## Variance Partition library(&quot;variancePartition&quot;) ## Visualization: plots &amp; text library(&quot;ComplexHeatmap&quot;) library(&quot;ggplot2&quot;) library(&quot;patchwork&quot;) library(&quot;pheatmap&quot;) library(&quot;RColorBrewer&quot;) library(&quot;Hmisc&quot;) library(&quot;stringr&quot;) library(&quot;cowplot&quot;) library(&quot;rlang&quot;) library(&quot;ggrepel&quot;) library(&quot;Polychrome&quot;) ## Spatial transcriptomics library(&quot;spatialLIBD&quot;) ## Reproducibility information options(width = 120) session_info() ## ─ Session info ─────────────────────────────────────────────────────────────────────────────────────────────────────── ## setting value ## version R version 4.4.0 (2024-04-24) ## os Ubuntu 22.04.4 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz UTC ## date 2024-06-06 ## pandoc 3.1.13 @ /usr/bin/ (via rmarkdown) ## ## ─ Packages ─────────────────────────────────────────────────────────────────────────────────────────────────────────── ## package * version date (UTC) lib source ## abind 1.4-5 2016-07-21 [1] RSPM (R 4.4.0) ## alabaster.base 1.4.1 2024-05-03 [1] Bioconductor 3.19 (R 4.4.0) ## alabaster.matrix 1.4.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) ## alabaster.ranges 1.4.1 2024-05-21 [1] Bioconductor 3.19 (R 4.4.0) ## alabaster.sce 1.4.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) ## alabaster.schemas 1.4.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) ## alabaster.se 1.4.1 2024-05-21 [1] Bioconductor 3.19 (R 4.4.0) ## AnnotationDbi 1.66.0 2024-05-01 [1] Bioconductor 3.19 (R 4.4.0) ## AnnotationFilter 1.28.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) ## AnnotationHub 3.12.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) ## aod 1.3.3 2023-12-13 [1] RSPM (R 4.4.0) ## askpass 1.2.0 2023-09-03 [2] RSPM (R 4.4.0) ## attempt 0.3.1 2020-05-03 [1] RSPM (R 4.4.0) ## backports 1.5.0 2024-05-23 [1] RSPM (R 4.4.0) ## base64enc 0.1-3 2015-07-28 [2] RSPM (R 4.4.0) ## beachmat 2.20.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) ## beeswarm 0.4.0 2021-06-01 [1] RSPM (R 4.4.0) ## benchmarkme 1.0.8 2022-06-12 [1] RSPM (R 4.4.0) ## benchmarkmeData 1.0.4 2020-04-23 [1] RSPM (R 4.4.0) ## Biobase * 2.64.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) ## BiocFileCache * 2.12.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) ## BiocGenerics * 0.50.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) ## BiocIO 1.14.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) ## BiocManager 1.30.23 2024-05-04 [2] CRAN (R 4.4.0) ## BiocNeighbors 1.22.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) ## BiocParallel * 1.38.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) ## BiocSingular 1.20.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) ## BiocStyle * 2.32.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) ## biocthis * 1.14.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) ## BiocVersion 3.19.1 2024-04-17 [2] Bioconductor 3.19 (R 4.4.0) ## Biostrings 2.72.1 2024-06-02 [1] Bioconductor 3.19 (R 4.4.0) ## bit 4.0.5 2022-11-15 [1] RSPM (R 4.4.0) ## bit64 4.0.5 2020-08-30 [1] RSPM (R 4.4.0) ## bitops 1.0-7 2021-04-24 [1] RSPM (R 4.4.0) ## blob 1.2.4 2023-03-17 [1] RSPM (R 4.4.0) ## bookdown 0.39 2024-04-15 [1] RSPM (R 4.4.0) ## boot 1.3-30 2024-02-26 [3] CRAN (R 4.4.0) ## broom 1.0.6 2024-05-17 [1] RSPM (R 4.4.0) ## bslib 0.7.0 2024-03-29 [2] RSPM (R 4.4.0) ## cachem 1.1.0 2024-05-16 [2] RSPM (R 4.4.0) ## caTools 1.18.2 2021-03-28 [1] RSPM (R 4.4.0) ## checkmate 2.3.1 2023-12-04 [1] RSPM (R 4.4.0) ## circlize 0.4.16 2024-02-20 [1] RSPM (R 4.4.0) ## cli 3.6.2 2023-12-11 [2] RSPM (R 4.4.0) ## clue 0.3-65 2023-09-23 [1] RSPM (R 4.4.0) ## cluster 2.1.6 2023-12-01 [3] CRAN (R 4.4.0) ## codetools 0.2-20 2024-03-31 [3] CRAN (R 4.4.0) ## colorspace 2.1-0 2023-01-23 [1] RSPM (R 4.4.0) ## colourpicker 1.3.0 2023-08-21 [1] RSPM (R 4.4.0) ## ComplexHeatmap * 2.20.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) ## config 0.3.2 2023-08-30 [1] RSPM (R 4.4.0) ## corpcor 1.6.10 2021-09-16 [1] RSPM (R 4.4.0) ## cowplot * 1.1.3 2024-01-22 [1] RSPM (R 4.4.0) ## crayon 1.5.2 2022-09-29 [2] RSPM (R 4.4.0) ## credentials 2.0.1 2023-09-06 [2] RSPM (R 4.4.0) ## curl 5.2.1 2024-03-01 [2] RSPM (R 4.4.0) ## data.table 1.15.4 2024-03-30 [1] RSPM (R 4.4.0) ## DBI 1.2.3 2024-06-02 [1] RSPM (R 4.4.0) ## dbplyr * 2.5.0 2024-03-19 [1] RSPM (R 4.4.0) ## DelayedArray 0.30.1 2024-05-07 [1] Bioconductor 3.19 (R 4.4.0) ## DelayedMatrixStats 1.26.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) ## digest 0.6.35 2024-03-11 [2] RSPM (R 4.4.0) ## doParallel 1.0.17 2022-02-07 [1] RSPM (R 4.4.0) ## dotCall64 1.1-1 2023-11-28 [1] RSPM (R 4.4.0) ## dplyr 1.1.4 2023-11-17 [1] RSPM (R 4.4.0) ## DT 0.33 2024-04-04 [1] RSPM (R 4.4.0) ## edgeR * 4.2.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) ## ensembldb 2.28.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) ## EnvStats 2.8.1 2023-08-22 [1] RSPM (R 4.4.0) ## evaluate 0.23 2023-11-01 [2] RSPM (R 4.4.0) ## ExperimentHub 2.12.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) ## ExploreModelMatrix * 1.16.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) ## fANCOVA 0.6-1 2020-11-13 [1] RSPM (R 4.4.0) ## fansi 1.0.6 2023-12-08 [2] RSPM (R 4.4.0) ## fastmap 1.2.0 2024-05-15 [2] RSPM (R 4.4.0) ## fields 15.2 2023-08-17 [1] RSPM (R 4.4.0) ## filelock 1.0.3 2023-12-11 [1] RSPM (R 4.4.0) ## foreach 1.5.2 2022-02-02 [1] RSPM (R 4.4.0) ## foreign 0.8-86 2023-11-28 [3] CRAN (R 4.4.0) ## Formula 1.2-5 2023-02-24 [1] RSPM (R 4.4.0) ## fs 1.6.4 2024-04-25 [2] RSPM (R 4.4.0) ## generics 0.1.3 2022-07-05 [1] RSPM (R 4.4.0) ## GenomeInfoDb * 1.40.1 2024-05-24 [1] Bioconductor 3.19 (R 4.4.0) ## GenomeInfoDbData 1.2.12 2024-05-26 [1] Bioconductor ## GenomicAlignments 1.40.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) ## GenomicFeatures 1.56.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) ## GenomicRanges * 1.56.0 2024-05-01 [1] Bioconductor 3.19 (R 4.4.0) ## gert * 2.0.1 2023-12-04 [2] RSPM (R 4.4.0) ## GetoptLong 1.0.5 2020-12-15 [1] RSPM (R 4.4.0) ## ggbeeswarm 0.7.2 2023-04-29 [1] RSPM (R 4.4.0) ## ggplot2 * 3.5.1 2024-04-23 [1] RSPM (R 4.4.0) ## ggrepel * 0.9.5 2024-01-10 [1] RSPM (R 4.4.0) ## gh * 1.4.1 2024-03-28 [2] RSPM (R 4.4.0) ## gitcreds * 0.1.2 2022-09-08 [2] RSPM (R 4.4.0) ## GlobalOptions 0.1.2 2020-06-10 [1] RSPM (R 4.4.0) ## glue 1.7.0 2024-01-09 [2] RSPM (R 4.4.0) ## golem 0.4.1 2023-06-05 [1] RSPM (R 4.4.0) ## gplots 3.1.3.1 2024-02-02 [1] RSPM (R 4.4.0) ## gridExtra 2.3 2017-09-09 [1] RSPM (R 4.4.0) ## gtable 0.3.5 2024-04-22 [1] RSPM (R 4.4.0) ## gtools 3.9.5 2023-11-20 [1] RSPM (R 4.4.0) ## gypsum 1.0.1 2024-05-08 [1] Bioconductor 3.19 (R 4.4.0) ## HDF5Array 1.32.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) ## here * 1.0.1 2020-12-13 [1] RSPM (R 4.4.0) ## Hmisc * 5.1-3 2024-05-28 [1] RSPM (R 4.4.0) ## htmlTable 2.4.2 2023-10-29 [1] RSPM (R 4.4.0) ## htmltools 0.5.8.1 2024-04-04 [2] RSPM (R 4.4.0) ## htmlwidgets 1.6.4 2023-12-06 [2] RSPM (R 4.4.0) ## httpuv 1.6.15 2024-03-26 [2] RSPM (R 4.4.0) ## httr 1.4.7 2023-08-15 [2] RSPM (R 4.4.0) ## httr2 1.0.1 2024-04-01 [2] RSPM (R 4.4.0) ## igraph 2.0.3 2024-03-13 [1] RSPM (R 4.4.0) ## IRanges * 2.38.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) ## irlba 2.3.5.1 2022-10-03 [1] RSPM (R 4.4.0) ## iSEE * 2.16.0 2024-05-01 [1] Bioconductor 3.19 (R 4.4.0) ## iterators 1.0.14 2022-02-05 [1] RSPM (R 4.4.0) ## jquerylib 0.1.4 2021-04-26 [2] RSPM (R 4.4.0) ## jsonlite 1.8.8 2023-12-04 [2] RSPM (R 4.4.0) ## KEGGREST 1.44.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) ## KernSmooth 2.23-24 2024-05-17 [3] RSPM (R 4.4.0) ## knitr 1.47 2024-05-29 [2] RSPM (R 4.4.0) ## later 1.3.2 2023-12-06 [2] RSPM (R 4.4.0) ## lattice 0.22-6 2024-03-20 [3] CRAN (R 4.4.0) ## lazyeval 0.2.2 2019-03-15 [1] RSPM (R 4.4.0) ## lifecycle 1.0.4 2023-11-07 [2] RSPM (R 4.4.0) ## limma * 3.60.2 2024-05-19 [1] Bioconductor 3.19 (R 4.4.0) ## listviewer 4.0.0 2023-09-30 [1] RSPM (R 4.4.0) ## lme4 1.1-35.3 2024-04-16 [1] RSPM (R 4.4.0) ## lmerTest 3.1-3 2020-10-23 [1] RSPM (R 4.4.0) ## lobstr * 1.1.2 2022-06-22 [1] RSPM (R 4.4.0) ## locfit 1.5-9.9 2024-03-01 [1] RSPM (R 4.4.0) ## magick 2.8.3 2024-02-18 [1] RSPM (R 4.4.0) ## magrittr 2.0.3 2022-03-30 [2] RSPM (R 4.4.0) ## maps 3.4.2 2023-12-15 [1] RSPM (R 4.4.0) ## MASS 7.3-60.2 2024-05-06 [3] local ## Matrix 1.7-0 2024-03-22 [3] CRAN (R 4.4.0) ## MatrixGenerics * 1.16.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) ## matrixStats * 1.3.0 2024-04-11 [1] RSPM (R 4.4.0) ## memoise 2.0.1 2021-11-26 [2] RSPM (R 4.4.0) ## mgcv 1.9-1 2023-12-21 [3] CRAN (R 4.4.0) ## mime 0.12 2021-09-28 [2] RSPM (R 4.4.0) ## miniUI 0.1.1.1 2018-05-18 [2] RSPM (R 4.4.0) ## minqa 1.2.7 2024-05-20 [1] RSPM (R 4.4.0) ## munsell 0.5.1 2024-04-01 [1] RSPM (R 4.4.0) ## mvtnorm 1.2-5 2024-05-21 [1] RSPM (R 4.4.0) ## nlme 3.1-164 2023-11-27 [3] CRAN (R 4.4.0) ## nloptr 2.0.3 2022-05-26 [1] RSPM (R 4.4.0) ## nnet 7.3-19 2023-05-03 [3] CRAN (R 4.4.0) ## numDeriv 2016.8-1.1 2019-06-06 [1] RSPM (R 4.4.0) ## openssl 2.2.0 2024-05-16 [2] RSPM (R 4.4.0) ## paletteer 1.6.0 2024-01-21 [1] RSPM (R 4.4.0) ## patchwork * 1.2.0 2024-01-08 [1] RSPM (R 4.4.0) ## pbkrtest 0.5.2 2023-01-19 [1] RSPM (R 4.4.0) ## pheatmap * 1.0.12 2019-01-04 [1] RSPM (R 4.4.0) ## pillar 1.9.0 2023-03-22 [2] RSPM (R 4.4.0) ## pkgconfig 2.0.3 2019-09-22 [2] RSPM (R 4.4.0) ## plotly 4.10.4 2024-01-13 [1] RSPM (R 4.4.0) ## plyr 1.8.9 2023-10-02 [1] RSPM (R 4.4.0) ## png 0.1-8 2022-11-29 [1] RSPM (R 4.4.0) ## Polychrome * 1.5.1 2022-05-03 [1] RSPM (R 4.4.0) ## postcards * 0.2.3 2022-01-07 [1] RSPM (R 4.4.0) ## promises 1.3.0 2024-04-05 [2] RSPM (R 4.4.0) ## ProtGenerics 1.36.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) ## purrr 1.0.2 2023-08-10 [2] RSPM (R 4.4.0) ## R.cache 0.16.0 2022-07-21 [1] RSPM (R 4.4.0) ## R.methodsS3 1.8.2 2022-06-13 [1] RSPM (R 4.4.0) ## R.oo 1.26.0 2024-01-24 [1] RSPM (R 4.4.0) ## R.utils 2.12.3 2023-11-18 [1] RSPM (R 4.4.0) ## R6 2.5.1 2021-08-19 [2] RSPM (R 4.4.0) ## rappdirs 0.3.3 2021-01-31 [2] RSPM (R 4.4.0) ## rbibutils 2.2.16 2023-10-25 [1] RSPM (R 4.4.0) ## RColorBrewer * 1.1-3 2022-04-03 [1] RSPM (R 4.4.0) ## Rcpp 1.0.12 2024-01-09 [2] RSPM (R 4.4.0) ## RCurl 1.98-1.14 2024-01-09 [1] RSPM (R 4.4.0) ## Rdpack 2.6 2023-11-08 [1] RSPM (R 4.4.0) ## recount3 * 1.14.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) ## remaCor 0.0.18 2024-02-08 [1] RSPM (R 4.4.0) ## rematch2 2.1.2 2020-05-01 [2] RSPM (R 4.4.0) ## reshape2 1.4.4 2020-04-09 [1] RSPM (R 4.4.0) ## restfulr 0.0.15 2022-06-16 [1] RSPM (R 4.4.0) ## rhdf5 2.48.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) ## rhdf5filters 1.16.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) ## Rhdf5lib 1.26.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) ## RhpcBLASctl 0.23-42 2023-02-11 [1] RSPM (R 4.4.0) ## rintrojs 0.3.4 2024-01-11 [1] RSPM (R 4.4.0) ## rjson 0.2.21 2022-01-09 [1] RSPM (R 4.4.0) ## rlang * 1.1.4 2024-06-04 [2] RSPM (R 4.4.0) ## rmarkdown 2.27 2024-05-17 [2] RSPM (R 4.4.0) ## rpart 4.1.23 2023-12-05 [3] CRAN (R 4.4.0) ## rprojroot 2.0.4 2023-11-05 [2] RSPM (R 4.4.0) ## Rsamtools 2.20.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) ## RSQLite 2.3.7 2024-05-27 [1] RSPM (R 4.4.0) ## rstudioapi 0.16.0 2024-03-24 [2] RSPM (R 4.4.0) ## rsvd 1.0.5 2021-04-16 [1] RSPM (R 4.4.0) ## rtracklayer 1.64.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) ## S4Arrays 1.4.1 2024-05-20 [1] Bioconductor 3.19 (R 4.4.0) ## S4Vectors * 0.42.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) ## sass 0.4.9 2024-03-15 [2] RSPM (R 4.4.0) ## ScaledMatrix 1.12.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) ## scales 1.3.0 2023-11-28 [1] RSPM (R 4.4.0) ## scater * 1.32.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) ## scatterplot3d 0.3-44 2023-05-05 [1] RSPM (R 4.4.0) ## scRNAseq * 2.18.0 2024-05-02 [1] Bioconductor 3.19 (R 4.4.0) ## scuttle * 1.14.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) ## sessioninfo * 1.2.2 2021-12-06 [2] RSPM (R 4.4.0) ## shape 1.4.6.1 2024-02-23 [1] RSPM (R 4.4.0) ## shiny 1.8.1.1 2024-04-02 [2] RSPM (R 4.4.0) ## shinyAce 0.4.2 2022-05-06 [1] RSPM (R 4.4.0) ## shinydashboard 0.7.2 2021-09-30 [1] RSPM (R 4.4.0) ## shinyjs 2.1.0 2021-12-23 [1] RSPM (R 4.4.0) ## shinyWidgets 0.8.6 2024-04-24 [1] RSPM (R 4.4.0) ## SingleCellExperiment * 1.26.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) ## smokingMouse * 0.99.91 2024-06-06 [1] Github (LieberInstitute/smokingMouse@96d8480) ## spam 2.10-0 2023-10-23 [1] RSPM (R 4.4.0) ## SparseArray 1.4.8 2024-05-24 [1] Bioconductor 3.19 (R 4.4.0) ## sparseMatrixStats 1.16.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) ## SpatialExperiment * 1.14.0 2024-05-01 [1] Bioconductor 3.19 (R 4.4.0) ## spatialLIBD * 1.16.2 2024-05-28 [1] Bioconductor 3.19 (R 4.4.0) ## statmod 1.5.0 2023-01-06 [1] RSPM (R 4.4.0) ## stringi 1.8.4 2024-05-06 [2] RSPM (R 4.4.0) ## stringr * 1.5.1 2023-11-14 [2] RSPM (R 4.4.0) ## styler 1.10.3 2024-04-07 [1] RSPM (R 4.4.0) ## SummarizedExperiment * 1.34.0 2024-05-01 [1] Bioconductor 3.19 (R 4.4.0) ## sys 3.4.2 2023-05-23 [2] RSPM (R 4.4.0) ## tibble 3.2.1 2023-03-20 [2] RSPM (R 4.4.0) ## tidyr 1.3.1 2024-01-24 [1] RSPM (R 4.4.0) ## tidyselect 1.2.1 2024-03-11 [1] RSPM (R 4.4.0) ## UCSC.utils 1.0.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) ## usethis * 2.2.3 2024-02-19 [2] RSPM (R 4.4.0) ## utf8 1.2.4 2023-10-22 [2] RSPM (R 4.4.0) ## variancePartition * 1.34.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) ## vctrs 0.6.5 2023-12-01 [2] RSPM (R 4.4.0) ## vipor 0.4.7 2023-12-18 [1] RSPM (R 4.4.0) ## viridis 0.6.5 2024-01-29 [1] RSPM (R 4.4.0) ## viridisLite 0.4.2 2023-05-02 [1] RSPM (R 4.4.0) ## withr 3.0.0 2024-01-16 [2] RSPM (R 4.4.0) ## xfun 0.44 2024-05-15 [2] RSPM (R 4.4.0) ## XML 3.99-0.16.1 2024-01-22 [1] RSPM (R 4.4.0) ## xtable 1.8-4 2019-04-21 [2] RSPM (R 4.4.0) ## XVector 0.44.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) ## yaml 2.3.8 2023-12-11 [2] RSPM (R 4.4.0) ## zlibbioc 1.50.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) ## ## [1] /__w/_temp/Library ## [2] /usr/local/lib/R/site-library ## [3] /usr/local/lib/R/library ## ## ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── proc.time() ## user system elapsed ## 13.727 0.999 14.585 This interactive book was last updated at 2024-06-06 18:34:14.473049. License This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. "],["summarizedexperiment-overview.html", "1 SummarizedExperiment overview 1.1 Overview 1.2 Quiz 1.3 Exercises 1.4 Solutions", " 1 SummarizedExperiment overview Instructor: Leo LIBD rstats club notes 1.1 Overview The SummarizedExperiment class is used to store experimental results in the form of matrixes. Objects of this class include observations (features) of the samples, as well as additional metadata. Usually, this type of object is automatically generated as the output of other software (ie. SPEAQeasy), but you can also build them. One of the main characteristics of SummarizedExperiment is that it allows you to handle you data in a “coordinated” way. For example, if you want to subset your data, with SummarizedExperiment you can do so without worrying your assays and metadata unsync. 1.2 Quiz How many classes does the SummarizedExperiment class has? What does features stand for? Which is the structure of the SummarizedExperiment class? What type of data can we store on an assay? What information does colData has? 1.3 Exercises We are gonna use the same sample data set as yesterday from the airway library library(SummarizedExperiment) library(airway) data(airway, package = &quot;airway&quot;) se &lt;- airway p.exercise { background-color: #E4EDE2; padding: 9px; border: 1px solid black; border-radius: 10px; font-family: sans-serif; } Exercise 1: a) How many genes do we have in this object? And samples? b) How many samples come from donors treated (trt) with dexamethasone (dex)? ## For a) you could only print the summary of the object but since the idea is to understand ## how to explore the object find other function that gives you the answer. se #&gt; class: RangedSummarizedExperiment #&gt; dim: 63677 8 #&gt; metadata(1): &#39;&#39; #&gt; assays(1): counts #&gt; rownames(63677): ENSG00000000003 ENSG00000000005 ... ENSG00000273492 ENSG00000273493 #&gt; rowData names(10): gene_id gene_name ... seq_coord_system symbol #&gt; colnames(8): SRR1039508 SRR1039509 ... SRR1039520 SRR1039521 #&gt; colData names(9): SampleName cell ... Sample BioSample ## Same thing for b, you could just print the colData and count the samples, but this is not ## efficient when our data consists in hundreds of samples. Find the answer using other tools. colData(se) #&gt; DataFrame with 8 rows and 9 columns #&gt; SampleName cell dex albut Run avgLength Experiment Sample BioSample #&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;integer&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; #&gt; SRR1039508 GSM1275862 N61311 untrt untrt SRR1039508 126 SRX384345 SRS508568 SAMN02422669 #&gt; SRR1039509 GSM1275863 N61311 trt untrt SRR1039509 126 SRX384346 SRS508567 SAMN02422675 #&gt; SRR1039512 GSM1275866 N052611 untrt untrt SRR1039512 126 SRX384349 SRS508571 SAMN02422678 #&gt; SRR1039513 GSM1275867 N052611 trt untrt SRR1039513 87 SRX384350 SRS508572 SAMN02422670 #&gt; [ reached getOption(&quot;max.print&quot;) -- omitted 4 rows ] Exercise 2: Add another assay that has the log10 of your original counts ## In our object, if you look at the part that says assays, we can see that at the moment ## we only have one with the name &quot;counts&quot; se #&gt; class: RangedSummarizedExperiment #&gt; dim: 63677 8 #&gt; metadata(1): &#39;&#39; #&gt; assays(1): counts #&gt; rownames(63677): ENSG00000000003 ENSG00000000005 ... ENSG00000273492 ENSG00000273493 #&gt; rowData names(10): gene_id gene_name ... seq_coord_system symbol #&gt; colnames(8): SRR1039508 SRR1039509 ... SRR1039520 SRR1039521 #&gt; colData names(9): SampleName cell ... Sample BioSample ## To see the data that&#39;s stored in that assay you can do either one of the next commands assay(se) #&gt; SRR1039508 SRR1039509 SRR1039512 SRR1039513 SRR1039516 SRR1039517 SRR1039520 SRR1039521 #&gt; ENSG00000000003 679 448 873 408 1138 1047 770 572 #&gt; ENSG00000000005 0 0 0 0 0 0 0 0 #&gt; ENSG00000000419 467 515 621 365 587 799 417 508 #&gt; ENSG00000000457 260 211 263 164 245 331 233 229 #&gt; ENSG00000000460 60 55 40 35 78 63 76 60 #&gt; ENSG00000000938 0 0 2 0 1 0 0 0 #&gt; [ reached getOption(&quot;max.print&quot;) -- omitted 63671 rows ] assays(se)$counts #&gt; SRR1039508 SRR1039509 SRR1039512 SRR1039513 SRR1039516 SRR1039517 SRR1039520 SRR1039521 #&gt; ENSG00000000003 679 448 873 408 1138 1047 770 572 #&gt; ENSG00000000005 0 0 0 0 0 0 0 0 #&gt; ENSG00000000419 467 515 621 365 587 799 417 508 #&gt; ENSG00000000457 260 211 263 164 245 331 233 229 #&gt; ENSG00000000460 60 55 40 35 78 63 76 60 #&gt; ENSG00000000938 0 0 2 0 1 0 0 0 #&gt; [ reached getOption(&quot;max.print&quot;) -- omitted 63671 rows ] ## Note that assay() does not support $ operator # assay(se)$counts ## We would have to do: assay(se, 1) #&gt; SRR1039508 SRR1039509 SRR1039512 SRR1039513 SRR1039516 SRR1039517 SRR1039520 SRR1039521 #&gt; ENSG00000000003 679 448 873 408 1138 1047 770 572 #&gt; ENSG00000000005 0 0 0 0 0 0 0 0 #&gt; ENSG00000000419 467 515 621 365 587 799 417 508 #&gt; ENSG00000000457 260 211 263 164 245 331 233 229 #&gt; ENSG00000000460 60 55 40 35 78 63 76 60 #&gt; ENSG00000000938 0 0 2 0 1 0 0 0 #&gt; [ reached getOption(&quot;max.print&quot;) -- omitted 63671 rows ] assay(se, &quot;counts&quot;) #&gt; SRR1039508 SRR1039509 SRR1039512 SRR1039513 SRR1039516 SRR1039517 SRR1039520 SRR1039521 #&gt; ENSG00000000003 679 448 873 408 1138 1047 770 572 #&gt; ENSG00000000005 0 0 0 0 0 0 0 0 #&gt; ENSG00000000419 467 515 621 365 587 799 417 508 #&gt; ENSG00000000457 260 211 263 164 245 331 233 229 #&gt; ENSG00000000460 60 55 40 35 78 63 76 60 #&gt; ENSG00000000938 0 0 2 0 1 0 0 0 #&gt; [ reached getOption(&quot;max.print&quot;) -- omitted 63671 rows ] ## If you use assays() without specifying the element you want to see it shows you the length ## of the list and the name of each element assays(se) #&gt; List of length 1 #&gt; names(1): counts ## To obtain a list of names as a vector you can do: assayNames(se) #&gt; [1] &quot;counts&quot; ## Which can also be use to change the name of the assays assayNames(se)[1] &lt;- &quot;foo&quot; assayNames(se) #&gt; [1] &quot;foo&quot; assayNames(se)[1] &lt;- &quot;counts&quot; Exercise 3: Explore the metadata and add a new column that has the library size of each sample. ## To calculate the library size use apply(assay(se), 2, sum) #&gt; SRR1039508 SRR1039509 SRR1039512 SRR1039513 SRR1039516 SRR1039517 SRR1039520 SRR1039521 #&gt; 20637971 18809481 25348649 15163415 24448408 30818215 19126151 21164133 1.4 Solutions p.solution { background-color: #C093D6; padding: 9px; border: 1px solid black; border-radius: 10px; font-family: sans-serif; } Solution 1: ## For a), dim() gives the desired answer dim(se) #&gt; [1] 63677 8 ## For b), colData(se)[colData(se)$dex == &quot;trt&quot;, ] #&gt; DataFrame with 4 rows and 9 columns #&gt; SampleName cell dex albut Run avgLength Experiment Sample BioSample #&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;integer&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; #&gt; SRR1039509 GSM1275863 N61311 trt untrt SRR1039509 126 SRX384346 SRS508567 SAMN02422675 #&gt; SRR1039513 GSM1275867 N052611 trt untrt SRR1039513 87 SRX384350 SRS508572 SAMN02422670 #&gt; SRR1039517 GSM1275871 N080611 trt untrt SRR1039517 126 SRX384354 SRS508576 SAMN02422673 #&gt; SRR1039521 GSM1275875 N061011 trt untrt SRR1039521 98 SRX384358 SRS508580 SAMN02422677 Solution 2: ## There are multiple ways to do it assay(se, &quot;logcounts&quot;) &lt;- log10(assay(se, &quot;counts&quot;)) assays(se)$logcounts_v2 &lt;- log10(assays(se)$counts) Solution 3: ## To add the library size we an use.. colData(se)$library_size &lt;- apply(assay(se), 2, sum) names(colData(se)) #&gt; [1] &quot;SampleName&quot; &quot;cell&quot; &quot;dex&quot; &quot;albut&quot; &quot;Run&quot; &quot;avgLength&quot; &quot;Experiment&quot; #&gt; [8] &quot;Sample&quot; &quot;BioSample&quot; &quot;library_size&quot; "],["interactive-summarizedexperiment-visualizations.html", "2 Interactive SummarizedExperiment visualizations 2.1 Classes for iSEE 2.2 Getting Started with iSEE 2.3 Description of the user interface 2.4 Let’s practice! 2.5 References", " 2 Interactive SummarizedExperiment visualizations Instructor: Melissa Mayén Quiroz How can you make plots from “SummarizedExperiment” objects without having to write any code? The answer is with “iSEE” http://bioconductor.org/packages/iSEE http://bioconductor.org/packages/release/bioc/vignettes/iSEE/inst/doc/basic.html iSEE is a Bioconductor package that provides an interactive Shiny-based graphical user interface for exploring data stored in SummarizedExperiment objects (Rue-Albrecht et al. 2018). 2.1 Classes for iSEE SummarizedExperiment (SE) and SingleCellExperiment (SCE) are classes in R. Classes serve as templates for creating objects that contain data and methods for manipulating those data. 2.1.1 SummarizedExperiment class Assay Data: The primary data matrix containing quantitative measurements, such as gene expression values or read counts. Rows represent features (e.g., genes, transcripts) and columns represent samples (e.g., experimental conditions, individuals). Row Metadata (rowData): Additional information about the features in the assay data. This can include annotations, identifiers, genomic coordinates, and other relevant information. Column Metadata (colData): Additional information about the samples in the assay data. This can include sample annotations, experimental conditions, treatment groups, and other relevant information. Metadata: Additional information about the experiment. 2.1.2 SingleCellExperiment This object is specifically designed to store and analyze single-cell RNA sequencing (scRNA-seq) data. It extends the SummarizedExperiment class to include specialized features for single-cell data, such as cell identifiers, dimensionality reduction results, and methods for quality control and normalization. Assay Data: The primary data matrix containing gene expression values or other measurements. Rows represent genes and columns represent cells. ColData (Column Metadata): Additional information about each cell, such as cell type, experimental condition, or any other relevant metadata. RowData (Row Metadata): Additional information about each gene, such as gene symbols, genomic coordinates, or functional annotations. ReducedDims: Dimensionality reduction results, such as “principal component analysis” (PCA), “t-distributed stochastic neighbor embedding” (t-SNE), and “Uniform Manifold Approximation and Projection” (UMAP), used for visualizing and clustering cells. SpikeNames and pikeMatrix: Names of spike-in control genes used for normalization and Spike-in counts matrix, if spike-in controls are used Metadata: Additional metadata about the experiment. 2.2 Getting Started with iSEE Reference manual Adapted from The iSEE User’s Guide Installation (version “4.4”). In this case, the package is already installed so we just need to load it. # if (!require(&quot;BiocManager&quot;, quietly = TRUE)) # install.packages(&quot;BiocManager&quot;) # # BiocManager::install(&quot;iSEE&quot;) library(iSEE) Documentation browseVignettes(&quot;iSEE&quot;) Use (simple launch): If you have a “SummarizedExperiment” object (se) or an instance of a subclass, like a “SingleCellExperiment” object (sce), you can launch an iSEE app by running: ## Launch iSEE for the se (&quot;SummarizedExperiment&quot; object) iSEE(se) ## Launch iSEE for the sce (&quot;SingleCellExperiment&quot; object) iSEE(sce) 2.3 Description of the user interface ** Insertat imángen !!! ** By default, the app starts with a dashboard that contains one panel or table of each type. By opening the collapsible panels named “Data parameters”, “Visual parameters”, and “Selection parameters” under each plot, we can control the content and appearance of each panel. ** introductory tour: In the upper right corner there is a question mark icon. Clicking it and then on the hand button you can have an introductory tour. During this tour, you will be taken through the different components of the iSEE user interface and learn the basic usage mechanisms by doing small actions guided by the tutorial: the highlighted elements will be responding to your actions, while the rest of the UI will be shaded. ** 2.3.1 Header The layout of the iSEE user interface uses the “shinydashboard” package. The dashboard header contains four dropdown menus. The “Organization” menu, which is identified by an icon displaying multiple windows “Export” dropdown menu, which is identified by a download icon The “Documentation” dropdown menu which is identified by aquestion mark icon The “Additional Information” dropdown menu which is identified by the information icon (i) 2.3.1.1 Organization menu The “Organization” dropdown menu, dentified by an icon displaying multiple windows, includes: “Organize panels” button opens a modal window that contains: A selectize input to add, remove, and reorder panels in the main interface. Two inputs to control the width and height, respectively, of each panel selected above. The “Examine panel chart” feature, identified by a chain icon, allows you to visualize the relationships and point selections among your visible plot and table panels. Each panel is represented by a node, color-coded to match the app. (This functionality is particularly useful in sessions with many panels, helping you to see the structure of how panels send and receive data point selections). ** #### Export dropdown menu The “Export” dropdown menu, identified by a download icon, includes: The “Download panel output” feature that allows you to download a zip folder containing the currently displayed panel content, including high-resolution figures and table contents as CSV files. The “Extract the R code” feature which provides a way to record the exact code that reproduces the current state of each plot. Clicking on this button opens a popup window with a text editor displaying the formatted code with syntax highlighting. You can copy this code, including initial lines and sessionInfo() commands, to your clipboard for inclusion in your analysis report or script. This code can then be further edited for publication. “Display panel settings” lets you export the code defining the current state of the panels in the interface. This is useful for pre-configuring an iSEE instance to start in the current state rather than with the default set of panels. ** 2.3.1.2 Documentation Menu The “Documentation” dropdown, accessible through the question mark icon, includes: Interactive Tour: Launches a guided tour of iSEE, teaching basic usage interactively. Open Vignette: Displays the iSEE vignette, either locally or from the Bioconductor project site. 2.3.1.3 Additional Information Menu The “Additional Information” dropdown, accessible through the information icon (i), includes: About this Session: Shows the output of the sessionInfo() function in a popup. About iSEE: Provides information on the development team, licensing, citation, and links to the GitHub repository for following development and contributing suggestions. 2.3.2 Panel types The main element in the body of iSEE is the combination of panels, generated (and optionally linked to one another) according to your actions. There are currently eight standard panel types that can be generated with iSEE: Reduced dimension plot Column data table Column data plot Feature assay plot Row data table Row data plot Sample assay plot Complex heatmap In addition, custom panel types can be defined. 2.3.3 Parameter sets For each standard plot panel, three different sets of parameters will be available in collapsible boxes: “Data parameters”, to control parameters specific to each type of plot. “Visual parameters”, to specify parameter s that will determine the aspect of the plot, in terms of coloring, point features, and more (e.g., legend placement, font size). “Selection parameters” to control the incoming point selection and link relationships to other plots. 2.3.4 Reduced dimension plots If a “SingleCellExperiment” object is supplied to the iSEE function, reduced dimension results are extracted from the reducedDim slot. Examples include low-dimensional embeddings from principal components analysis (PCA) or t-distributed stochastic neighbour embedding (t-SNE). These results are used to construct a two-dimensional Reduced dimension plot where each point is a sample, to facilitate efficient exploration of high-dimensional datasets. The “Data parameters” control the reducedDim slot to be displayed, as well as the two dimensions to plot against each other. ** Note that this builtin panel does not compute reduced dimension embeddings; they must be precomputed and available in the object provided to the iSEE function. Nevertheless, custom panels - such as the iSEEu DynamicReducedDimensionPlot can be developed and used to enable such features. ** 2.3.5 Column data plots A Column data plot visualizes sample metadata contained in column metadata. Different fields can be used for the x- and y-axes by selecting appropriate values in the “Data parameters” box. This plot can assume various forms, depending on the nature of the data on the x- and y-axes: If the y-axis is continuous and the x-axis is categorical, violin plots are generated (grouped by the x-axis factor). If the y-axis is categorical and the x-axis is continuous, horizontal violin plots are generated (grouped by the y-axis factor). If both axes are continuous, a scatter plot is generated. This enables the use of contours that are overlaid on top of the plot, check the “Other” box to see the available options. If both axes are categorical, a plot of squares (Hinton plot) is generated where the area of each square is proportional to the number of samples within each combination of factor levels. 2.3.6 Feature assay plots A Feature assay plot visualizes the assayed values (e.g., gene expression) for a particular feature (e.g., gene) across the samples on the y-axis. This usually results in a (grouped) violin plot, if the x-axis is set to “None” or a categorical variable; or a scatter plot, if the x-axis is another continuous variable. ** Gene selection for the y-axis can be achieved by using a linked row data table in another panel. Clicking on a row in the table automatically changes the assayed values plotted on the y-axis. Alternatively, the row name can be directly entered as text that corresponds to an entry of rownames(se). (This is not effective if se does not contain row names.) ** 2.3.7 Row data plots A Row data plot allows the visualization of information stored in the rowData slot of a “SummarizedExperiment” object. Its behavior mirrors the implementation for the Column data plot, and correspondingly this plot can assume various forms depending on whether the data are categorical or continuous. 2.3.8 Sample assay plots A Sample assay plot visualizes the assayed values (e.g., gene expression) for a particular sample (e.g., cell) across the features on the y-axis. This usually results in a (grouped) violin plot, if the x-axis is set to “None” or a categorical variable (e.g., gene biotype); or a scatter plot, if the x-axis is another continuous variable. Notably, the x-axis covariate can also be set to: A discrete row data covariates (e.g., gene biotype), to stratify the distribution of assayed values A continuous row data covariate (e.g., count of cells expressing each gene) Another sample, to visualize and compare the assayed values in any two samples. 2.3.9 Row data tables A Row data table contains the values of the rowData slot. If none are available, a column named Present is added and set to TRUE for all features, to avoid issues with ‘DT::datatable’ and an ‘empty DataFrame’. ** Typically, these tables are used to link to other plots to determine the features to use for plotting or coloring. ** 2.3.10 Column data tables A Column data table contains the values of the colData slot. Its behavior mirrors the implementation for the Row data table. Correspondingly, if none are available, a column named Present is added and set to TRUE for all samples. ** Typically, these tables are used to link to other plots to determine the samples to use for plotting or coloring. ** 2.3.11 Heat maps Heat map panels provide a compact overview of the data for multiple features in the form of color-coded matrices. These correspond to the assays stored in the SCE/SE object, where features (e.g., genes) are the rows and samples are the columns. User can select features (rows) to display from the selectize widget (which supports autocompletion), or also via other panels, like row data plots or row data tables. In addition, users can rapidly import custom lists of feature names using a modal popup that provides an Ace editor where they can directly type of paste feature names, and a file upload button that accepts text files containing one feature name per line. Users should remember to click the “Apply” button before closing the modal, to update the heat map with the new list of features. The “Suggest feature order” button clusters the rows, and also rearranges the elements in the selectize according to the clustering. It is also possible to choose which assay type is displayed (“logcounts” being the default choice, if available). Samples in the heat map can also be annotated, simply by selecting relevant column metadata. A zooming functionality is also available, restricted to the y-axis (i.e., allowing closer inspection on the individual features included). 2.3.12 Description of iSEE functionality 2.3.12.1 Coloring plots by sample attributes 2.3.12.1.1 Column-based plots Column-based plots are: reduced dimension feature assay column data plots Where each data point represents a sample. Here, data points can be colored in different ways: The default is no color scheme (“None” in the radio button). Any column of colData(se) can be used. The plot automatically adjusts the scale to use based on whether the chosen column is continuous or categorical. The assay values of a particular feature in each sample can be used. The feature can be chosen either via a linked row table or selectize input (as described for the Feature assay plot panel). Users can also specify the assays from which values are extracted. The identity of a particular sample can be used, which will be highlighted on the plot in a user-specified color. The sample can be chosen either via a linked column table or via a selectize input. 2.3.12.1.2 Row-based plots For row-based plots (i.e., the sample assay and row data plots), each data point represents a feature. Like the column-based plots, data points can be colored by: “None”, yielding data points of fixed color. Any column of rowData(se). The identity of a particular feature, which is highlighted in the user-specified color. Assay values for a particular sample. 2.3.12.2 Controlling point aesthetics Data points can be set to different shapes according to categorical factors in colData(se) (for column-based plots) or rowData(se) (for row-based plots). This is achieved by checking the “Shape” box to reveal the shape-setting options. The size and opacity of the data points can be modified via the options available by checking the “Point” box. This may be useful for aesthetically pleasing visualizations when the number of points is very large or small. 2.3.12.3 Faceting Each point-based plot can be split into multiple facets using the options in the “Facet” checkbox. Users can facet by row and/or column, using categorical factors in colData(se) (for column-based plots) or rowData(se) (for row-based plots). This provides a convenient way to stratify points in a single plot by multiple factors of interest. Note that point selection can only occur within a single facet at a time; points cannot be selected across facets. 2.3.12.4 Zooming in and out Zooming in is possible by first selecting a region of interest in a plot using the brush (drag and select); double-clicking on the brushed area then zooms into the selected area. To zoom out to the original plot, simply double-click at any location in the plot. 2.4 Let’s practice! 2.4.1 Setting up the data We’ll download a SingleCellExperiment object, which is similar to SummarizedExperiment as it extends it. http://bioconductor.org/packages/SingleCellExperiment http://bioconductor.org/packages/spatialLIBD https://doi.org/10.1038/s41593-020-00787-0 https://osca.bioconductor.org/ https://www.nature.com/articles/s41592-019-0654-x Figures 2 and 3 ## Lets get some data using spatialLIBD sce_layer &lt;- spatialLIBD::fetch_data(&quot;sce_layer&quot;) sce_layer # class: SingleCellExperiment # dim: 22331 76 # metadata(0): # assays(2): counts logcounts # rownames(22331): ENSG00000243485 ENSG00000238009 ... ENSG00000278384 ENSG00000271254 # rowData names(10): source type ... is_top_hvg is_top_hvg_sce_layer # colnames(76): 151507_Layer1 151507_Layer2 ... 151676_Layer6 151676_WM # colData names(13): sample_name layer_guess ... layer_guess_reordered_short spatialLIBD # reducedDimNames(6): PCA TSNE_perplexity5 ... UMAP_neighbors15 PCAsub # mainExpName: NULL # altExpNames(0): # 33.99 MB ## We can check how big the object is with lobstr lobstr::obj_size(sce_layer) # 33.99 MB Now we can deploy iSEE() to explore the data. ## Load library library(&quot;iSEE&quot;) ## Deploy iSEE(sce_layer) p.exercise { background-color: #E4EDE2; padding: 9px; border: 1px solid black; border-radius: 10px; font-family: sans-serif; } Question 1: Which panel Type is displaying the following plot? Exercise 1: Recreate the following plot Question 2: What is different between this 2 plots? Exercise 2: Recreate the following plot 2.5 References "],["recount3-introduction.html", "3 recount3 introduction 3.1 recount projects 3.2 Using recount3 3.3 Exercise 3.4 Community", " 3 recount3 introduction Instructor: Leo Don’t let useful data go to waste by Franziska Denk https://doi.org/10.1038/543007a 3.1 recount projects ReCount: data from 20 studies http://bowtie-bio.sourceforge.net/recount/index.shtml Paper from 2011 https://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-12-449 recount: over 70k human bulk RNA-seq samples uniformly processed https://jhubiostatistics.shinyapps.io/recount/ pkgdown documentation website: http://leekgroup.github.io/recount/ Bioconductor documentation website: http://bioconductor.org/packages/recount Main paper (2017) http://www.nature.com/nbt/journal/v35/n4/full/nbt.3838.html Paper that explains why the counts are different from the usual ones https://f1000research.com/articles/6-1558/v1 Example analyses we did and provided as a companion website for the 2017 paper http://leekgroup.github.io/recount-analyses/ recount3: over 700k bulk RNA-seq samples from human and mouse http://rna.recount.bio/ pkgdown documentation website: http://research.libd.org/recount3/ Bioconductor documentation website: http://bioconductor.org/packages/recount3 Pre-print: May 2021 https://doi.org/10.1101/2021.05.21.445138 Paper: November 2021 https://doi.org/10.1186/s13059-021-02533-6 These projects help such that anyone, particularly those without access to a high performance computing (HPC) system (aka a compute cluster), can access these datasets. It’s like democratizing access to the gene expression data ^^. 3.2 Using recount3 Check the original documentation here and here. Let’s first load recount3 which will load all the required dependencies including SummarizedExperiment. ## Load recount3 R package library(&quot;recount3&quot;) Next we need to identify a study of interest as well as choose whether we want the data at the gene, exon, or some other feature level. Once we have identified our study of interest, we can download the files and build a SummarizedExperiment object using recount3::create_rse() as we’ll show next. create_rse() has arguments through which we can control what annotation we want to use (they are organism-dependent). ## Lets download all the available projects human_projects &lt;- available_projects() #&gt; 2024-06-06 18:34:19.937351 caching file sra.recount_project.MD.gz. #&gt; adding rname &#39;http://duffel.rail.bio/recount3/human/data_sources/sra/metadata/sra.recount_project.MD.gz&#39; #&gt; 2024-06-06 18:34:20.802487 caching file gtex.recount_project.MD.gz. #&gt; adding rname &#39;http://duffel.rail.bio/recount3/human/data_sources/gtex/metadata/gtex.recount_project.MD.gz&#39; #&gt; 2024-06-06 18:34:21.626165 caching file tcga.recount_project.MD.gz. #&gt; adding rname &#39;http://duffel.rail.bio/recount3/human/data_sources/tcga/metadata/tcga.recount_project.MD.gz&#39; ## Find your project of interest. Here we&#39;ll use ## SRP009615 as an example proj_info &lt;- subset( human_projects, project == &quot;SRP009615&quot; &amp; project_type == &quot;data_sources&quot; ) ## Build a RangedSummarizedExperiment (RSE) object ## with the information at the gene level rse_gene_SRP009615 &lt;- create_rse(proj_info) #&gt; 2024-06-06 18:34:25.424311 downloading and reading the metadata. #&gt; 2024-06-06 18:34:25.661174 caching file sra.sra.SRP009615.MD.gz. #&gt; adding rname &#39;http://duffel.rail.bio/recount3/human/data_sources/sra/metadata/15/SRP009615/sra.sra.SRP009615.MD.gz&#39; #&gt; 2024-06-06 18:34:26.462834 caching file sra.recount_project.SRP009615.MD.gz. #&gt; adding rname &#39;http://duffel.rail.bio/recount3/human/data_sources/sra/metadata/15/SRP009615/sra.recount_project.SRP009615.MD.gz&#39; #&gt; 2024-06-06 18:34:27.276588 caching file sra.recount_qc.SRP009615.MD.gz. #&gt; adding rname &#39;http://duffel.rail.bio/recount3/human/data_sources/sra/metadata/15/SRP009615/sra.recount_qc.SRP009615.MD.gz&#39; #&gt; 2024-06-06 18:34:28.18066 caching file sra.recount_seq_qc.SRP009615.MD.gz. #&gt; adding rname &#39;http://duffel.rail.bio/recount3/human/data_sources/sra/metadata/15/SRP009615/sra.recount_seq_qc.SRP009615.MD.gz&#39; #&gt; 2024-06-06 18:34:29.015894 caching file sra.recount_pred.SRP009615.MD.gz. #&gt; adding rname &#39;http://duffel.rail.bio/recount3/human/data_sources/sra/metadata/15/SRP009615/sra.recount_pred.SRP009615.MD.gz&#39; #&gt; 2024-06-06 18:34:29.628335 downloading and reading the feature information. #&gt; 2024-06-06 18:34:29.871094 caching file human.gene_sums.G026.gtf.gz. #&gt; adding rname &#39;http://duffel.rail.bio/recount3/human/annotations/gene_sums/human.gene_sums.G026.gtf.gz&#39; #&gt; 2024-06-06 18:34:30.993718 downloading and reading the counts: 12 samples across 63856 features. #&gt; 2024-06-06 18:34:31.212208 caching file sra.gene_sums.SRP009615.G026.gz. #&gt; adding rname &#39;http://duffel.rail.bio/recount3/human/data_sources/sra/gene_sums/15/SRP009615/sra.gene_sums.SRP009615.G026.gz&#39; #&gt; 2024-06-06 18:34:32.033652 constructing the RangedSummarizedExperiment (rse) object. ## Explore the resulting object rse_gene_SRP009615 #&gt; class: RangedSummarizedExperiment #&gt; dim: 63856 12 #&gt; metadata(8): time_created recount3_version ... annotation recount3_url #&gt; assays(1): raw_counts #&gt; rownames(63856): ENSG00000278704.1 ENSG00000277400.1 ... ENSG00000182484.15_PAR_Y ENSG00000227159.8_PAR_Y #&gt; rowData names(10): source type ... havana_gene tag #&gt; colnames(12): SRR387777 SRR387778 ... SRR389077 SRR389078 #&gt; colData names(175): rail_id external_id ... recount_pred.curated.cell_line BigWigURL ## How large is it? lobstr::obj_size(rse_gene_SRP009615) #&gt; 24.81 MB We can also interactively choose our study of interest using the following code or through the recount3 study explorer. ## Explore available human projects interactively proj_info_interactive &lt;- interactiveDisplayBase::display(human_projects) ## Choose only 1 row in the table, then click on &quot;send&quot;. ## Lets double check that you indeed selected only 1 row in the table stopifnot(nrow(proj_info_interactive) == 1) ## Now we can build the RSE object rse_gene_interactive &lt;- create_rse(proj_info_interactive) Now that we have the data, we can use recount3::transform_counts() or recount3::compute_read_counts() to convert the raw counts into a format expected by downstream tools. For more details, check the recountWorkflow paper. ## We&#39;ll compute read counts, which is what most downstream software ## uses. ## For other types of transformations such as RPKM and TPM, use ## transform_counts(). assay(rse_gene_SRP009615, &quot;counts&quot;) &lt;- compute_read_counts(rse_gene_SRP009615) ## Lets make it easier to use the information available for this study ## that was provided by the original authors of the study. rse_gene_SRP009615 &lt;- expand_sra_attributes(rse_gene_SRP009615) colData(rse_gene_SRP009615)[ , grepl(&quot;^sra_attribute&quot;, colnames(colData(rse_gene_SRP009615))) ] #&gt; DataFrame with 12 rows and 4 columns #&gt; sra_attribute.cells sra_attribute.shRNA_expression sra_attribute.source_name sra_attribute.treatment #&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; #&gt; SRR387777 K562 no SL2933 Puromycin #&gt; SRR387778 K562 yes, targeting SRF SL2934 Puromycin, doxycycline #&gt; SRR387779 K562 no SL5265 Puromycin #&gt; SRR387780 K562 yes targeting SRF SL3141 Puromycin, doxycycline #&gt; SRR389079 K562 no shRNA expression SL6485 Puromycin #&gt; ... ... ... ... ... #&gt; SRR389082 K562 expressing shRNA tar.. SL2592 Puromycin, doxycycline #&gt; SRR389083 K562 no shRNA expression SL4337 Puromycin #&gt; SRR389084 K562 expressing shRNA tar.. SL4326 Puromycin, doxycycline #&gt; SRR389077 K562 no shRNA expression SL1584 Puromycin #&gt; SRR389078 K562 expressing shRNA tar.. SL1583 Puromycin, doxycycline We are now ready to use other bulk RNA-seq data analysis software tools. 3.3 Exercise p.exercise { background-color: #E4EDE2; padding: 9px; border: 1px solid black; border-radius: 10px; font-family: sans-serif; } Exercise 1: Use iSEE to reproduce the following image Hints: Use dynamic feature selection Use information from columns (samples) for the X axis Use information from columns (samples) for the colors (optional) Create your free account at https://www.shinyapps.io/ and share your iSEE app with the world. Real examples used on a paper: https://github.com/LieberInstitute/10xPilot_snRNAseq-human#explore-the-data-interactively. Example from another course: https://libd.shinyapps.io/SRP009615/. It was created with https://github.com/lcolladotor/rnaseq_2023_notas_en_vivo/blob/main/app.R. 3.4 Community recount2 and 3 authors on Twitter: https://twitter.com/chrisnwilks https://twitter.com/BenLangmead https://twitter.com/KasperDHansen https://twitter.com/AbhiNellore https://twitter.com/Shannon_E_Ellis https://twitter.com/jtleek More about the different types of counts: If I'm using recount2 data for a differential analysis in DEseq2, should I be using the original counts, or the scaled counts?@mikelove @lcolladotor #rstats #Bioconductor — Dr. Robert M Flight, PhD (@rmflight) January 29, 2021 Tweets from the community From a student in the LCG-UNAM 2021 course: @lcolladotor Earlier I was looking for some data to analyze in recount, they have so much, I seriously can't decide what to use! https://t.co/fIJwXq46TzThanks for such an useful package!@chrisnwilks @BenLangmead @KasperDHansen @AbhiNellore @Shannon_E_Ellis @jtleek — Axel Zagal Norman (@NormanZagal) February 25, 2021 Exploring the possibility of using recount3 data for an analysis (January 2022): I have found a novel exon expressed in a cancer sample. I would like to search TCGA/SRA to identify other samples with the same/similar exon. It will be rare. Can I use Recount3, megadepth for this? @jtleek @lcolladotor @BenLangmead — Alicia Oshlack (@AliciaOshlack) January 5, 2022 Others discussing meta analyses publicly on Twitter: Thinking on this a bit it is strange how few people are doing “medium-sized” meta analyses of transcriptiomics. One on end you have @BenLangmead @lcolladotor reprocessing (with a touch of analysis) most of SRA. And you see papers pulling an dataset or two to corroborate. — David McGaughey (@David_McGaughey) February 1, 2022 "],["differential-gene-expression-analysis-overview.html", "4 Differential Gene Expression analysis overview 4.1 Preliminary steps 4.2 Differential Gene Expression 4.3 Downstream analyses References", " 4 Differential Gene Expression analysis overview Instructor: Daianna Differential Gene Expression (DGE) analyses are common statistical analyses of gene expression data that aim to discover genes significantly altered in their expression levels between experimental groups, which can be given by a condition, treatment, experimental procedure/exposure, diagnostic, time points, by biological origins (e.g. differences in sex, tissue, age, species), and even by different technical methodologies. These genes are known as Differentially Expressed Genes (DEGs) and can be either up- or down-regulated if their expression is greater or less in one group with respect to the other(s), respectively. Diverse methods exist to perform DGE and multiple downstream analyses can be applied on DEGs, but a series of non-skippable preliminary steps exists which are necessary to correctly perform previous to any statistical testing. Below a classic workflow for DGE is depicted. It takes as input the gene expression matrix with raw read counts for genes (as rows) across all samples (as columns). Among the preliminary steps, there is an initial data processing step encompassing count normalization and filtering of lowly-expressed genes. Secondly, Exploratory Data Analysis (EDA) involves assessment of Quality Control (QC) metrics of the samples and filtering of poor-quality ones, as well as an examination of the gene expression profiles between sample groups, potential detection of additional atypical samples to remove, and the exploration of the correlations between sample-level variables and their contributions in the expression variance of each gene to guide the covariate selection for DGE models. Figure 1: Summary of the analyses for differential expression. 1. RNA-seq data processing: raw counts are normalized and log-scaled (lognorm-counts) and the lowly-expressed genes are filtered out. 2. Exploratory Data Analysis: quality metrics of the samples are compared across groups, the poor-quality samples are filtered and both sample-level and gene-level effects of sample variables are explored to identify those that are main drivers of gene expression variation to include in the models for DGE. 3. Differential Expression Analysis: under the limma-voom pipeline the expression of each gene is linearly modeled by the selected variables in the previous step; after fitting the model gene-wise log2-fold changes (log2FC) and p-values are obtained for the variable of interest and other statistics of differential expression are also computed and compared. Here DEGs are determined based on the significance threshold (controlling for the False Discovery Rate or FDR). 4. Functional Enrichment Analysis: an overrepresentation analysis (ORA) is performed to find statistically significant associations between our groups of DEGs and gene sets annotated in GO terms and KEGG pathways; here we identify biological processes, cellular functions and components, and pathways potentially affected or involved in the experimental condition under study. 5. DE visualization: heatmaps are created to visually contrast gene expression levels of DEGs in the experimental groups. Abbreviations: CPM: counts per million; QC: quality control; PC: principal component; DEG(s): differentially expressed gene(s); Ctrl: control; Expt: experimental; GO: Gene Ontology; KEGG: Kyoto Encyclopedia of Genes and Genomes. 4.1 Preliminary steps Evident computational steps right after sequencing involve raw sequencing reads Quality Control (QC) analysis and read alignment to a reference genome for the subsequent gene expression quantification, generating the input for DGE. Comprehensive pipelines have been developed for these purposes, such as the RNA-seq processing pipeline SPEAQeasy (Eagles, N.J. et al. 2021) that provides a flexible, user-friendly, and reproducible pipeline to perform all such analyses through the implementation of a single workflow, liberating from the need of performing each step individually. p.link{ background-color: #FFFFFF; padding: 10px; border: 0px solid black; margin-left: 0px; border-radius: 1px; font-size: 15px; font-family: sans-serif; } 👉🏼 More details of this pipeline are provided in the original manuscript, the documentation website, and other in created resources. 4.1.1 RNA-seq data processing Once the gene expression matrix has been generated we can proceed to process the read counts. Raw counts are typically zero-enriched and not normally-distributed, which is required for the application of several statistical methods. Furthermore, raw gene expression values may reflect protocol-specific biases and biological factors other than the one of interest. Therefore raw counts must be normalized and lowly-expressed genes filtered out. 4.1.1.1 Data normalization Differences between samples such as library sizes (sequencing depths), and RNA composition, as well as different gene lengths and GC contents make raw gene expression data not comparable between samples. Several normalization strategies can be applied to surpass such differences; commonly counts-per-million (cpm) are used. In addition to count normalization, a log-transformation is required to make cpm follow an approximately normal distribution. 4.1.1.2 Gene filtering Often the expression profiling platform (microarray or RNA-seq) includes genes that do not appear to be expressed to a worthwhile degree in any or most of the samples. This might occur, for instance, in cases where genes are not expressed in any of the cell types being experimentally profiled [1]. We want to remove those genes prior to posterior analyses, which is justified on both biological and statistical grounds [2]: Biologically, it is considered that a gene must have a minimal expression level to be translated into a protein or to be of biological importance. Statistically, lowly-expressed genes are unlikely to be detected as DE because low counts don’t provide the required statistical evidence to assess differential expression. Different approaches exist for this step, ranging from the simple definition of a gene expression cutoff to those taking into account not only global gene expression but also the number of samples in which they have a minimum expression level. 👉🏼 More details about normalization and filtering can be consulted in the course material of 2023 (Statistical Analysis of Genome Scale Data 2023: Data preparation). Figure 2: RNA-seq data processing steps. 1. Count log-normalization: distribution of read counts before and after normalization and log-transformation into \\(log_2(cpm+0.5)\\) using calcNormFactors() and cpm() of edgeR. 2. Gene filtering: distribution of \\(log_2(cpm+0.5)\\) before and after filtering lowly-expressed genes; note the elimination of originally zero-expressed genes. 4.1.2 Exploratory Data Analysis The Exploratory Data Analysis (EDA) is a primordial step in which, as the name refers, we explore relevant aspects of the RNA-seq data. In this process we basically create tons of plots, charts and graphs to visualize the data, assess their quality and inspect their variability. This clearly exposes low-quality samples and relationships and contributions in gene expression variance of sample-level variables. This allows to draw valuable information from our data that could impact posterior analyses, including DGE. Thus EDA guides filtering steps, the execution of additional analyses, the selection of covariates for DGE models and of statistical tests based on data features, and could also aid in more accurate interpretations of the results. Although here we describe EDA as being comprised by QCA, dimensionality reduction to explore sample-level effects, and variance partition analysis to explore gene-level effects, EDA is not a well defined process that can be followed by concrete instructions or steps. The analyses you run and what you plot depends on the particular questions you’re trying to answer, what you would like to know about your data and of course, it completely depends on the specific characteristics of your own dataset. 4.1.2.1 Quality Control Analysis (QCA) First, the quality metrics of the samples regarding read and RNA contents, and read mapping rates have to be compared to (Figure 3: step 1): Identify punctual samples or groups of samples of poor quality that may have arisen by technical causes during experimental steps. Evaluate if samples from the groups of interest for DGE (diagnostic, treatment, etc.) differ in their quality metrics as these can represent confounding factors for differential expression. Detect high biological variability to subsequently support data partition to perform subanalyses of the data. Further, we are also interested in investigating trends and relationships between sample variables to unveil underlying technical and biological aspects of the observed data (Figure 3: step 2). After having identified poor-quality samples, we have to remove them to not include the unreliable expression data they provide in downstream analyses. Cutoffs can be defined for specific QC metrics to decide which samples to keep; this however, is not strongly recommended as no consolidated references exist to define them and therefore rather represent arbitrary values. Other approaches include identifying outlier QC metrics (Figure 3: step 3), but again, caution must be taken as outlier definition is also arbitrary and we could be discarding good-quality samples. Figure 3: Quality Control Analysis steps. 1. Evaluate QC metrics for groups of samples: sample QC metrics such as the fraction of reads that mapped to the mitochondrial chromosome (mitoRate) and to the reference genome (overallMapRate) are compared between sample groups given by the variable of interest (Group in this example), technical variables (e.g. plate for sample library preparation), and biological variables (e.g. Age). 2. Examine relationships between sample variables: pairs of QC metrics are compared; here mitoRate and the fraction of reads assigned to rRNA genes (rRNA_rate), as well as the library size (sum) and the number of expressed genes (detected) are plotted to explore the relationships they present with each other and with other sample metadata variables. (Group and Age). 3. QC-based sample filtering: outlier QC metrics (red) are detected based on +/- 3 median-absolute-deviations (MADs) away (dotted lines) from the median (solid line). 👉🏼 See more details about QCA in Statistical Analysis of Genome Scale Data 2023: Quality Control Analysis. 4.1.2.2 Exploration of sample-level effects Sample gene expression profiles can be analyzed and compared after dimensionality reduction procedures such as Principal Component Analysis (PCA) and Multidimensional-Scaling (MDS). These analyses are useful to potentially detect samples with outlier transcriptomic profiles to further remove and to identify sample variables driving gene expression variations (Figure 4). Figure 4: Exploration of sample-level effects through PCA 1. Detection of atypical samples (manual PCA-based sample filtering): PCx vs PCy plots can expose outlier samples that appear segregated from the rest (purple-squared sample) or samples of a particular group (Sex: F or M) closer to samples from the other group (blue-squared sample). These should be further examined to evalute if they can be kept or must be discarded. In this case, after removing them, PC2 that explains a higher % of variance in gene expression, separates samples by sex. 2. Identification of drivers of sample gene expression variation: reducing the dimensionality of our data enables to recognize sample variables explaining differences in the gene expression of the samples (Age), ascertain technical variables and batch effects are not impacting on the transcriptome (plate), and inquire to what extent our variable of interest is contributing to changes in gene expression (Group). 4.1.2.3 Model building: covariate selection for limma-voom DGE methods fitting linear models to gene expression data to assess if a covariate impacts significantly on the expression of a gene, require the selection of sample-level variables to model transcriptomic data. If very few variables are present, normally they are all included in the model but that’s not often the case with RNA-seq and it doesn’t represent a well founded strategy. Usually, multiple technical and biological variables are implicated in the experiments and sample QC metrics can affect the gene expression levels, even after count normalization, whereas other variables are redundant and/or minimally informative. Therefore, we’d like to identify an optimal set of variables to adjust gene expression for, in addition to the covariate of interest. We have already introduced one first approximation to that with PCA as this analysis allows us to identify variables explaining high percentages of gene expression variance between samples. In Chapter XX we will review how correlation and variance partition analyses at the gene level can help us determine a suitable set of highly explanatory variables. 4.2 Differential Gene Expression Different mathematical and statistical approaches exist to compare gene expression between two or more conditions. In Chapter XX we’ll briefly introduce methods based on the negative binomial distribution and address how to perform DGE under the empirical Bayes limma-voom framework, distinguishing how it operates, its main specifications, inputs, and outputs. 4.3 Downstream analyses After finding DEGs, volcano plots and heat maps are commonly used to graphically represent them, plotting relevant information about them and their expression levels, respectively. In Chapter XX we’ll also check how to create and interpret these plots. References Smyth, G. K., Ritchie, M., Thorne, N., Wettenhall, J., Shi, W., &amp; Hu, Y. (2002). limma: linear models for microarray and RNA-Seq data user’s guide. Bioinformatics Division, The Walter and Eliza Hall Institute of Medical Research, Melbourne, Australia. Chen, Y., Lun, A. T., &amp; Smyth, G. K. (2016). From reads to genes to pathways: differential expression analysis of RNA-Seq experiments using Rsubread and the edgeR quasi-likelihood pipeline. F1000Research, 5. "],["differential-gene-expression-analysis-with-limma-voom.html", "5 Differential Gene Expression analysis with limma-voom 5.1 NB-based DGE methods? 5.2 limma-voom pipeline 5.3 DE visualization References", " 5 Differential Gene Expression analysis with limma-voom Instructor: Daianna In this chapter you’ll learn how DGE analysis is performed under the empirical Bayes framework of the popular limma-voom pipeline, highlighting key assumptions and concepts, and main differences with other methodologies. 5.1 NB-based DGE methods? An initial central point of discussion around DGE method development is how to model the distribution of the reads. Many methods model the read counts (\\(y_{k,ij}\\), non-negative integers) of a gene \\(i\\) in the \\(j\\) samples of condition \\(k\\) through the Poisson or the Negative Binomial (NB) distribution. Of these, NB is often preferred as it allows the mean (\\(\\mu\\)) and the variance (\\(\\sigma\\)) of the reads to be different, compared to the Poisson distribution where \\(\\mu\\)=\\(\\sigma\\). This is of particular importance as controlling the variance allows to account for variability in the gene expression levels across biological samples [1]. Figure 1: NB-distributed read counts. Modeling of read counts for gene \\(i\\) in the samples of the first and second conditions based on the NB model. Modified from Li, W. V., &amp; Li, J. J. (2018). Estimating the NB distribution parameters is necessary to assess DE of each gene \\(i\\) between any two conditions \\(k=1,2\\) (Figure 1). Bayesian models are used defining prior distributions and relationships of such parameters. Briefly, after 1) estimating gene-wise NB parameters, 2) the mean-variance relationship across all genes can be used to shrink the gene variance estimations borrowing information from all genes or incorporating prior knowledge, something advantageous when sample sizes are small. 3) A statistical test is used to assess for each gene \\(i\\) if its true expression in the first and second condition (\\(\\theta_{1i}\\) and \\(\\theta_{2i}\\)) is the same (null hypothesis) or differs (alternative hypothesis): \\(H_0: \\theta_{1i}=\\theta_{2i}\\) \\(H_1: \\theta_{1i}≠\\theta_{2i}\\), where the \\(\\theta_{i}\\)’s are parameters included in the mean of the NB distributions (\\(\\mu\\)). 4) The test statistic is computed for each gene and 5) its associated p-value is calculated based on the null distribution. 6) Finally, p-values are corrected for multiple-testing and DEGs are determined based on an adjusted p-values cutoff [1]. Examples of popular methods based on the NB distribution are edgeR and DESeq2. Nevertheless, one limitation NB-based methods face is that they set dispersion of the data as a known and global parameter, ignoring observation-specific variation and importantly, there’s a reduced number of statistical methods for count distributions compared to the normal distribution [1,2]. Here, we’ll focus on limma that does not rely on a certain distribution but rather works on \\(log_2(cpm)\\) and fits linear models for DGE enabling the incorporation of additional predictors to model gene expression, a feature specially valuable for complex experimental settings. 5.2 limma-voom pipeline limma is a package for the analysis of gene expression data arising from microarray or RNA-seq technologies. It has features that make the analyses stable even for experiments with small number of arrays or samples —this is achieved by borrowing information across genes. It is specially designed for analyzing complex experiments with a variety of experimental conditions and predictors [3]. Usually, limma DGE analysis is carried out in five main steps, the last four of them completed by limma R functions, as described below. We’ll continue using our bulk RNA-seq data from smokingMouse to exemplify the steps. ## Load the container package for RSE library(&quot;SummarizedExperiment&quot;) ## Connect to ExperimentHub library(&quot;ExperimentHub&quot;) eh &lt;- ExperimentHub::ExperimentHub() ## Load package datasets myfiles &lt;- query(eh, &quot;smokingMouse&quot;) ## Download the mouse gene data rse_gene &lt;- myfiles[[&quot;EH8313&quot;]] ## Samples from the nicotine experiment and from pups only rse_gene_nic &lt;- rse_gene[, which(rse_gene$Expt == &quot;Nicotine&quot; &amp; rse_gene$Age == &quot;Pup&quot;)] ## Retain only expressed genes (passed the filtering step) rse_gene_filt &lt;- rse_gene_nic[rowData(rse_gene_nic)$retained_after_feature_filtering == TRUE, ] Let’s explore a little the data. ## Data dimensions: number of genes and samples dim(rse_gene_filt) #&gt; [1] 19974 42 ## Raw counts for first 3 genes in the first 5 samples assays(rse_gene_filt)$counts[1:3, 1:5] #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; ENSMUSG00000051951.5 2652 2107 1978 2691 1833 #&gt; ENSMUSG00000102331.1 15 15 9 15 13 #&gt; ENSMUSG00000025900.13 10 7 28 11 8 ## Log-normalized counts for first 3 genes in the first 5 samples assays(rse_gene_filt)$logcounts[1:3, 1:5] #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; ENSMUSG00000051951.5 5.639967 5.953457 5.4923034 5.903313 5.800879 #&gt; ENSMUSG00000102331.1 -1.747878 -1.130265 -2.1809593 -1.517393 -1.282590 #&gt; ENSMUSG00000025900.13 -2.295096 -2.173926 -0.6153596 -1.941338 -1.948814 ## Data for the first 2 samples head(colData(rse_gene_filt), 2) #&gt; DataFrame with 2 rows and 71 columns #&gt; SAMPLE_ID FQCbasicStats perBaseQual perTileQual perSeqQual perBaseContent GCcontent Ncontent #&gt; SeqLengthDist SeqDuplication OverrepSeqs AdapterContent KmerContent SeqLength_R1 percentGC_R1 phred15-19_R1 #&gt; phred65-69_R1 phred115-119_R1 phred150-151_R1 phredGT30_R1 phredGT35_R1 Adapter65-69_R1 Adapter100-104_R1 #&gt; Adapter140_R1 SeqLength_R2 percentGC_R2 phred15-19_R2 phred65-69_R2 phred115-119_R2 phred150-151_R2 phredGT30_R2 #&gt; phredGT35_R2 Adapter65-69_R2 Adapter100-104_R2 Adapter140_R2 ERCCsumLogErr bamFile trimmed numReads #&gt; numMapped numUnmapped overallMapRate concordMapRate totalMapped mitoMapped mitoRate totalAssignedGene rRNA_rate #&gt; Tissue Age Sex Expt Group Pregnant plate location concentration #&gt; medium date Pregnancy flowcell sum detected subsets_Mito_sum subsets_Mito_detected #&gt; subsets_Mito_percent subsets_Ribo_sum subsets_Ribo_detected subsets_Ribo_percent retained_after_QC_sample_filtering #&gt; retained_after_manual_sample_filtering #&gt; [ reached getOption(&quot;max.print&quot;) -- omitted 3 rows ] 📝 Exercise 1: in order for you to perform a DGE analysis, locate your own RNA-seq datasets if you have any, or download expression data from a study of your interest and build a RSE object using recount3 (see chapter XX: recount3 introduction). A third option you have is to download data from the smokingMouse package used here. 5.2.1 model.matrix() limma fits a linear model to the expression data of each gene (response variable), modeling the systematic part of the data by sample-level covariates (predictors). p.exercise { background-color: #FFFAFA; padding: 15px; border: 2px solid black; margin-left: 0px; border-radius: 1px; font-family: sans-serif; } p.info { background-color: #FFFFF0; padding: 20px; border: 1px solid black; margin-left: 0px; border-radius: 1px; font-family: sans-serif; } p.conclusion { background-color: #EEE9E9; padding: 20px; border: 1px solid black; margin-left: 0px; border-radius: 1px; font-family: sans-serif; } p.question{ background-color: #E3E3E3; padding: 20px; border: 1px solid black; margin-left: 0px; border-radius: 1px; font-family: sans-serif; } p.link{ background-color: #FFFFFF; padding: 10px; border: 0px solid black; margin-left: 0px; border-radius: 1px; font-size: 13px; font-family: sans-serif; } p.comment { background-color: #F0F0F0; padding: 20px; border: 0px solid black; margin-left: 0px; border-radius: 1px; font-family: sans-serif; } p.alert { background-color: #FFE4E1; padding: 14px; border: 0px solid black; margin-left: 0px; border-radius: 1px; font-family: sans-serif; } p.success { background-color: #E0EEE0; padding: 14px; border: 0px solid black; margin-left: 0px; border-radius: 1px; font-family: sans-serif; } 💡 A model is a specification of how a set of variables relate to each other. In the case of a linear model, it is a linear equation that describes how the dependent or response variable is explained by the independent variables, also called predictors. A regression analysis with more than one independent variable is called multiple regression. Regression with only one independent variable is called simple regression [4]. The limma model is specified with a design matrix, also known as model matrix or regressor matrix, often denoted by \\(X\\). This is a matrix of values for explanatory variables of the samples: rows correspond to samples and columns to sample variables. Say that the values the \\(i\\)th sample take in the \\(h\\) covariates are \\(X_{ih}\\)’s and their coefficients are \\(\\beta_{h}\\)’s. The predicted expression of a gene in the \\(i\\)th sample is given by \\(\\hat y_i =\\beta_0 + \\sum_{1}^h\\beta_{h}X_{ih}\\). \\[ \\hat y = X\\beta=\\displaystyle {\\begin{bmatrix} \\hat y_{1}\\\\ \\hat y _{2}\\\\ \\hat y_{3}\\\\...\\\\ \\hat y_{n-1}\\\\ \\hat y_{n}\\end{bmatrix}}={\\begin{bmatrix}1&amp;X_{11}&amp;X_{12}&amp;X_{13}&amp;\\cdots&amp;X_{1,h-1}&amp;X_{1h}\\\\1&amp;X_{21}&amp;X_{22}&amp;X_{23}&amp;\\cdots&amp;X_{2,h-1}&amp;X_{2h}\\\\1&amp;X_{31}&amp;X_{32}&amp;X_{33}&amp;\\cdots&amp;X_{3,h-1}&amp;X_{3h} \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots \\\\1&amp;X_{n-1,1}&amp;X_{n-1,2}&amp;X_{n-1,3}&amp;\\cdots&amp;X_{n-1,h-1}&amp;X_{n-1,h} \\\\1&amp;X_{n,1}&amp;X_{n,2}&amp;X_{n,3}&amp;\\cdots&amp;X_{n,h-1}&amp;X_{n,h} \\end{bmatrix}}{\\begin{bmatrix}\\beta _{0}\\\\\\beta _{1}\\\\\\beta _{2}\\\\\\beta_{3}\\\\...\\\\\\beta_{h-1}\\\\\\beta_{h}\\end{bmatrix}} \\] where \\(n\\) is the number of samples. In the first step we create this matrix using model.matrix() that receives a formula with the variables to include in the models and the sample data. ## Define formula formula &lt;- ~ Group + Sex + flowcell + mitoRate + overallMapRate + totalAssignedGene + detected + ERCCsumLogErr ## Model matrix model &lt;- model.matrix(formula, data = colData(rse_gene_filt)) head(model) #&gt; (Intercept) GroupExperimental SexM flowcellHKCMHDSXX flowcellHKCNKDSXX flowcellHKCTMDSXX mitoRate overallMapRate #&gt; 1 1 0 0 0 1 0 0.03876995 0.9811 #&gt; 2 1 1 0 0 1 0 0.03337699 0.9791 #&gt; 3 1 0 1 0 1 0 0.03606147 0.9825 #&gt; 4 1 1 1 1 0 0 0.03962591 0.9855 #&gt; totalAssignedGene detected ERCCsumLogErr #&gt; 1 0.7715862 26545 -67.33211 #&gt; 2 0.7778447 24545 -66.38868 #&gt; 3 0.7870034 25640 -58.89350 #&gt; 4 0.7786461 25905 -84.91929 #&gt; [ reached getOption(&quot;max.print&quot;) -- omitted 2 rows ] ❓ Which variables to include as covariates in the models? A straightforward strategy is to keep the model as simple as possible and after fitting the model evaluate the comparisons of interest [3]. In Chapter XX we have discussed how correlation and variance partition analyses can help us to set up the best models. ⚠️ Very important: always check which condition group is set as the reference in you model for the coefficient/contrast of interest (column named as [Coefficient_name][Reference_Group]) as this determines if a DEG is up or downregulated in the given condition compared to the other. ## Comparison of interest: Group coef &lt;- &quot;GroupExperimental&quot; 📝 Exercise 2: perform a variance partition analysis (see Chapter XX:DGE model building with variancePartition) to select the sample variables to include in your models for DGE based on your data and create the respective design matrix. 5.2.2 voom() Compared to NB-based methods, limma works with \\(log(cpm)\\) which are approximately normally distributed (as we have seen) and thus, opens the possibility to leverage a wide range of normal-based statistical tools not available for count distributions, including methods developed for microarray data. However, limma doesn’t assume nor require data to follow a normal distribution, but it does apply normal-based microarray-like statistical methods to RNA-seq read counts [2]. “… limma does not make any assumption that the data appears normal in a histogram.” - Gordon Smyth, author of limma, in the Bioconductor support website 2021. The benefit of using \\(log(cpm)\\), however, is not immediate. One limitation for the direct application of normal-based methods to log-counts is that reads counts have unequal variabilities even after a log-transformation depending on the count sizes: probability distributions for counts are naturally heteroscedastic, with log-cpm not having constant variances (larger variances for larger counts) [2]. It has been proposed that to design powerful statistical analysis for RNA-seq, it is more important to model the relationship between the mean and the variance in the data than to specify which probabilistic distribution to use for the counts [2]. And importantly, converting count data taking such relationship into account does open up access to their analysis with normal-based methods. That’s why we use voom(). What voom() does is: First, to compute log-cpm. Log-normalized expression for gene \\(g\\) in sample \\(i\\) (\\(y_{gi}\\)) is given by \\[ y_{gi}=log_2(\\frac{r_{gi} + 0.5}{R_i + 1.0} \\times 10^6) \\] where \\(r_{gi}\\) is the raw count for the gene in the sample and \\(R_i\\) the library size of the sample. We add +0.5 to the counts to avoid log of zero and +1 to the library size to ensure that \\(\\frac{r_{gi}+0.5}{R_i+1}\\) is strictly less than 1 (if \\(r_{gi} = R_i\\)). A linear model is fitted to gene log-cpm values by ordinary least squares as: \\[ E(y_{gi})=\\mu_{gi}=X_i\\beta_g \\] where \\(E(y_{gi})\\) is the expected expression of gene \\(g\\) in sample \\(i\\), \\(X_i\\) is the vector with the sample values for the covariates and \\(\\beta_g\\) the vector of covariate coefficients for the gene. As a result, we have the estimated \\(\\hat\\beta_g\\), the fitted log-cpm’s \\(\\hat\\mu_{gi}=X_i\\hat\\beta_g\\) and the residual standard deviations \\(s_g\\). Then it estimates the mean-variance trend of the data by fitting a smooth curve to the \\(\\sqrt s_g\\) of the genes presented as a function of the average gene expression (in log-counts, not log-cpm). The \\(\\sqrt s_g\\)’s are used because they are symmetrically distributed. Log-counts typically show a decreasing mean-variance trend. voom() then predicts the standard deviation of each individual normalized observation \\(y_{gi}\\) (limma-trend does that at the gene level) using this trend curve: the fitted log-count of each observation is mapped to the curve and its \\(\\sqrt s_{gi}\\)value is obtained. The observation weights are \\(w_{gi}=\\frac{1}{s_{gi}^2}\\). Figure 2: voom() procedure to estimate observation-level variance weights for limma. Extracted from the original voom publication ( Law, C. W. et al. 2018). Log-cpm (\\(y_{gi}\\)) and associated weights (\\(w_{gi}\\)) can then be entered into the limma framework for linear modeling. These weights are used in the linear modeling to adjust for count heteroscedasticity [2]. library(&quot;limma&quot;) ## voom(): # 1. Transform counts to log2(cpm) # ---------------------------------------------------------------------------- # . | Note we passed voom() raw counts as input, not the lognorm counts!!! | # ---------------------------------------------------------------------------- # 2. Estimate mean-variance relationship for each gene # 3. Compute observation weights for limma (next step) vGene &lt;- voom(assay(rse_gene_filt), design = model, plot = TRUE) Let’s explore the outpus of this function. ## Returned data names(vGene) #&gt; [1] &quot;E&quot; &quot;weights&quot; &quot;design&quot; &quot;targets&quot; ## E: contains the computed log(cpm) dim(vGene$E) #&gt; [1] 19974 42 vGene$E[1:5, 1:5] #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; ENSMUSG00000051951.5 5.906572 6.1425731 5.7434780 6.133741 6.061250 #&gt; ENSMUSG00000102331.1 -1.512368 -0.9445475 -1.9587859 -1.306258 -1.024247 #&gt; ENSMUSG00000025900.13 -2.074247 -1.9918532 -0.3738234 -1.736892 -1.691672 #&gt; ENSMUSG00000025902.13 1.446325 1.2611275 1.3707154 1.419026 1.688471 #&gt; ENSMUSG00000098104.1 1.572354 1.2408075 1.4727667 1.404882 1.533748 ## weights: contains the computed variance weight for each observation dim(vGene$weights) #&gt; [1] 19974 42 vGene$weights[1:5, 1:5] #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] 143.326885 117.323375 139.214140 141.247546 128.818305 #&gt; [2,] 4.255525 4.277395 2.698902 5.113520 3.377285 #&gt; [3,] 4.009671 3.341317 5.555186 4.020098 2.546810 #&gt; [4,] 20.584769 15.108579 15.521441 19.219652 16.893714 #&gt; [5,] 22.473314 16.369739 18.359068 17.691839 14.325510 ## design: is the provided design matrix head(vGene$design) #&gt; (Intercept) GroupExperimental SexM flowcellHKCMHDSXX flowcellHKCNKDSXX flowcellHKCTMDSXX mitoRate overallMapRate #&gt; 1 1 0 0 0 1 0 0.03876995 0.9811 #&gt; 2 1 1 0 0 1 0 0.03337699 0.9791 #&gt; 3 1 0 1 0 1 0 0.03606147 0.9825 #&gt; 4 1 1 1 1 0 0 0.03962591 0.9855 #&gt; totalAssignedGene detected ERCCsumLogErr #&gt; 1 0.7715862 26545 -67.33211 #&gt; 2 0.7778447 24545 -66.38868 #&gt; 3 0.7870034 25640 -58.89350 #&gt; 4 0.7786461 25905 -84.91929 #&gt; [ reached getOption(&quot;max.print&quot;) -- omitted 2 rows ] ## targets: the sample library sizes used to compute log(cpm) in the first step dim(vGene$targets) #&gt; [1] 42 1 head(vGene$targets) #&gt; lib.size #&gt; 1 44218086 #&gt; 2 29831069 #&gt; 3 36929795 #&gt; 4 38331383 #&gt; 5 27457620 #&gt; 6 27113922 identical(vGene$targets$lib.size, colSums(assay(rse_gene_filt))) #&gt; [1] TRUE ➡️ In summary, voom() estimates non-parametrically the global mean-variance trend of the count data based on the expression of the genes and uses that to predict the variance of each individual expression observation (each log-cpm value) based on their predicted count sizes. The predicted variances are then associated as inverse weights to each observation that when used in linear modeling eliminate the log-cpm mean-variance trend [2]. 👉🏼 Advantages: ✅ voom() estimates the mean-variance relationship in a non-parametric way. “The parametric advantages of the Poisson or NB distributions are mitigated by the fact that the observed mean-variance relationship of RNA-seq data does not perfectly match the theoretical mean-variance relationships inherent in these distributions. While the quadratic mean-variance relationship of the NB distribution captures most of the mean-variance trend, the NB dispersion still shows a non-ignorable trend with gene abundance.” [2] ✅ Since voom() is a method to adapt count data to normal models, these give access to tractable empirical Bayes distribution theory. ✅ The use of normal distribution approaches and variance modeling is supported by generalized linear model theory. 📝 Exercise 3: compute the \\(log(cpm)\\) and the residual variance weights for each observation in your data using voom(). 5.2.3 lmFit() This limma function fits a multiple linear model to the expression of each gene by weighted or generalized least squares to estimate the coefficients of the sample covariates which correspond to the logFC’s comparing gene expression between sample groups. Ordinary least squares (OLS) This is used to estimate the coefficients of a linear regression by minimizing the residual sum of squares [5]. Figure 3: Graphical representation of the OLS method for simple regression analysis. Source: Gulve, A. (2020). Ordinary Least Square (OLS) Method for Linear Regression. For simplicity, let’s work with one gene and say we have \\(n\\) samples. The fitted expression of the gene in the \\(j\\)th sample is \\(\\hat y_j =\\beta_{0} + \\sum_{1}^h\\beta_{h}X_{jh}\\) , where \\(\\beta_h\\) is the coefficient for the \\(h\\)th covariate and \\(X_{jh}\\) the value the \\(j\\)th sample takes for the \\(h\\)th covariate. It can also be written as \\(\\hat y_j =\\sum_{0}^h\\beta_{h}X_{jh}\\) if \\(X_{j0}=1\\). So we have an overdetermined system of \\(n\\) linear equations and \\(h\\) unknown parameters with \\(n&gt;h\\): \\(\\hat y_j =\\sum_{0}^h\\beta_{h}X_{jh}\\) with \\(j=(1,2, ..., n)\\). Such system usually has no exact solution, so we need to estimate the coefficients that better fit the data in a linear regression. The problem is reduced to solving a quadratic minimization problem: \\(\\hat \\beta=arg \\ _\\beta\\ min \\ \\ S(\\beta)\\) where \\(S(\\beta)=\\sum_j(y_j -\\hat y_j)^2=RSS\\) (residual sum of squares). 💡 We can think of these \\(\\beta\\)’s as differences in the fitted (expected) expression of a gene. Say we have two binary categorical variables in the model (\\(X_1\\) and \\(X_2\\)), then the expected gene expression in a sample is \\(E(y|X_1, X_2) =\\hat y =\\beta_{0} + \\beta_1X_1+\\beta_2X_2\\), where \\(X_1\\) and \\(X_2\\) equal to 1 or 0. Then we have the following 4 combinations: \\(E(y|X_1=1, X_2=1) = \\mu_{12}=\\beta_{0} + \\beta_1+\\beta_2\\) \\(E(y|X_1=1, X_2=0) =\\mu_{1}=\\beta_{0} + \\beta_1\\) \\(E(y|X_1=0, X_2=1) =\\mu_{2}=\\beta_{0} + \\beta_2\\) \\(E(y|X_1=0, X_2=0) =\\mu_{0}=\\beta_{0}\\) So \\(\\beta_1=\\) \\(\\mu_1-\\mu_0\\) \\(=\\) \\(\\mu_{12}-\\mu_2\\) and \\(\\beta_2=\\) \\(\\mu_2\\)\\(-\\) \\(\\mu_0\\). Say our variable of interest is \\(\\beta_1\\). Then what we are testing is if the expected expression of a gene is different when \\(X_1=1\\) (in the first sample group) and \\(X_1=0\\) (in the second sample group), fixing \\(X_2\\) in either 1 or 0. Generalized least squares (GLS) Is a generalization of OLS that allows for heteroskedasticity and correlation between the residuals [6]. Weighted least squares (WLS) In this case the function to be minimized becomes the weighted sum of the squared residuals: squared residuals are weighted by the reciprocal of their variance so that more noisy observations have less weight. That’s what we used voom() for. lmFit() returns a fitted model object with the estimated coefficients, standard errors (\\(SE=sd/\\sqrt n\\)) and residual standard errors/deviations (\\(RSE=s_g=\\sqrt {RSS/ n-2}\\)) for each gene. Depending on the arguments and correlations in the data, this function calls one of the following functions to fit a linear model for each gene [7]: mrlm: for a robust regression if method=\"robust”. gls.series: GLS estimator if method=\"ls” and a correlation structure has been specified. lm.series: OLS method if method=\"ls” and there is no correlation structure. For the weights argument of lmFit(), the precision weights for the observations previously computed are extracted from the voom() output. ## lmFit(): # 1. Fit linear model for each gene to estimate logFCs fitGene &lt;- lmFit(vGene) ## Corroborate &quot;ls&quot; method was applied fitGene$method #&gt; [1] &quot;ls&quot; ## Explore outputs: estimated coefficients (logFCs) head(fitGene$coefficients) #&gt; (Intercept) GroupExperimental SexM flowcellHKCMHDSXX flowcellHKCNKDSXX flowcellHKCTMDSXX #&gt; ENSMUSG00000051951.5 -35.637900 -0.05125195 0.05690091 -0.47469588 -0.38545404 -0.66545820 #&gt; ENSMUSG00000102331.1 37.943310 0.72450620 0.19887963 -0.20803712 -0.40926270 -0.10900553 #&gt; ENSMUSG00000025900.13 -43.586603 0.17256694 0.28895786 -0.04476551 0.15257245 -0.06949759 #&gt; ENSMUSG00000025902.13 5.657837 -0.05025788 -0.04808144 -0.18732331 -0.26041436 0.07364071 #&gt; mitoRate overallMapRate totalAssignedGene detected ERCCsumLogErr #&gt; ENSMUSG00000051951.5 -11.487040 37.443647 4.753830 6.442499e-05 -0.0043851842 #&gt; ENSMUSG00000102331.1 -21.871815 27.323603 -79.223111 -1.026687e-04 0.0166190950 #&gt; ENSMUSG00000025900.13 16.727251 7.179484 42.367908 8.535604e-05 0.0133260060 #&gt; ENSMUSG00000025902.13 -24.538883 11.174017 -18.548282 -1.231546e-05 -0.0092194951 #&gt; [ reached getOption(&quot;max.print&quot;) -- omitted 2 rows ] 💡 Interaction terms in linear models There may be cases where we want to assess gene expression differences between 2 conditions within more than one specific group; for example if we were interested in knowing what are the effects of a treatment (\\(X_1=1\\) for treatment and 0 for controls) in females and males separately (\\(X_2=1\\) for females and 0 for males). In such cases we can fit an interaction model in which we include the product of \\(X_1\\) and \\(X_2\\) so that \\(X_1X_2=1\\) if a sample comes from a female that was treated and 0 otherwise: \\[E(y|X_1, X_2) =\\beta_{0} + \\beta_1X_1+\\beta_2X_2 + \\beta_3X_1X_2\\] \\(E(y|X_1=1, X_2=1) =\\mu_{12} =\\beta_{0} + \\beta_1+\\beta_2+\\beta_3\\) \\(E(y|X_1=1, X_2=0) =\\mu_{1} =\\beta_{0} + \\beta_1\\) \\(E(y|X_1=0, X_2=1) =\\mu_{2} =\\beta_{0} + \\beta_2\\) \\(E(y|X_1=0, X_2=0) =\\mu_{0} =\\beta_{0}\\) \\(\\beta_1 + \\beta_3=\\) \\(\\mu_{12}-\\mu_2\\) which is the expression difference between treated and control female samples (\\(X_2=1\\)) and \\(\\beta_1 =\\) \\(\\mu_{1}-\\mu_0\\) for male samples (\\(X_2=0\\)). Finally \\(\\beta_3\\), called the interaction term, is (\\(\\mu_{12}-\\mu_2\\))\\(-\\)(\\(\\mu_1-\\mu_0\\)), described as the difference in gene expression changes driven by the treatment in females compared to males [8]. 📝 Exercise 4: fit a linear regression model to the expression data of your genes and extract the coefficients for the included covariates. 5.2.4 eBayes() Next, we want to assess if the differences in gene expression between the sample groups are statistically significant. Initially, we can think of comparing the mean expression of a gene in the sample groups (e.g. cases and controls) which can be handled applying a two-sample t-test assuming that the values in both groups have an approximately normal distribution. Here we use the t-score (t-stats) to define if the difference in the means is statistically significant based on a t-distribution. The t-stats is given by: \\[ t=\\frac{\\bar x_1 - \\bar x_2}{\\sqrt{\\frac{s_1^2}{n_1}+\\frac{s_2^2}{n_2}}} \\] where \\(\\bar x_1\\) and \\(\\bar x_2\\) are the means of the expression values of a gene in the first and second sample groups, \\(s_1\\) and \\(s_2\\) are the sample standard deviations of gene expression in the same groups, and \\(n_1\\), \\(n_2\\) the corresponding sample group sizes: \\(s_1 = \\sqrt{\\frac{\\sum_{i=1}^ {n_1} (x_i-\\bar x_1)^2}{n_1-1}}\\) and \\(s_2 = \\sqrt{\\frac{\\sum_{j=1}^ {n_2} (x_j-\\bar x_2)^2}{n_2-1}}\\), with \\(x_i\\) and \\(x_j\\) the gene expression values in the samples of group 1 and 2, respectively. ➡️ Note that we say sample means and sample standard deviations because they are estimators of the population parameters, computed based on the data that we have. We can think of this t-stats as a ratio of signal and noise. The numerator contains the difference between the two means, taken as the signal for DE. The denominator corresponds to the standard error and represents the noise in terms of gene expression variance within the sample groups. This represents how spread out the signal is [9]. In that way, the t-stats is a measure of how strong is the DE signal. Once computed, the t-stats have an associated p-value based on a Student t-distribution under the null hypothesis (\\(H_o\\): \\(\\bar x_1 - \\bar x_2=0\\)). This is exactly what we can get using lm(): ## Lognorm expression of first gene rse_gene_one_gene &lt;- rse_gene_filt[1, ] colData(rse_gene_one_gene) &lt;- cbind(colData(rse_gene_one_gene), &quot;lognorm_expr&quot; = assays(rse_gene_one_gene)$logcounts[1, ] ) ## Fit simple linear model formula &lt;- lognorm_expr ~ Group lm &lt;- lm(formula, data = colData(rse_gene_one_gene)) summary(lm) #&gt; #&gt; Call: #&gt; lm(formula = formula, data = colData(rse_gene_one_gene)) #&gt; #&gt; Residuals: #&gt; Min 1Q Median 3Q Max #&gt; -1.05368 -0.06304 0.03012 0.10254 0.24844 #&gt; #&gt; Coefficients: #&gt; Estimate Std. Error t value Pr(&gt;|t|) #&gt; (Intercept) 5.75377 0.04502 127.800 &lt;2e-16 *** #&gt; GroupExperimental -0.04292 0.06694 -0.641 0.525 #&gt; --- #&gt; Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 #&gt; #&gt; Residual standard error: 0.2159 on 40 degrees of freedom #&gt; Multiple R-squared: 0.01017, Adjusted R-squared: -0.01457 #&gt; F-statistic: 0.4111 on 1 and 40 DF, p-value: 0.525 ## Two sample t-test t.test(formula, data = colData(rse_gene_one_gene), var.equal = TRUE) #&gt; #&gt; Two Sample t-test #&gt; #&gt; data: lognorm_expr by Group #&gt; t = 0.64121, df = 40, p-value = 0.525 #&gt; alternative hypothesis: true difference in means between group Control and group Experimental is not equal to 0 #&gt; 95 percent confidence interval: #&gt; -0.09236465 0.17820636 #&gt; sample estimates: #&gt; mean in group Control mean in group Experimental #&gt; 5.753765 5.710845 💡 Sample sizes are critical! Larger sample sizes increase the power of the tests and reduce the false discovery rate (FDR) as they decrease the denominator of the t-stats (increasing their values) and slight differences can then be detected. ⚠️ Now consider that for genes with small variances in their expression the t-stats will be greater and we could be detecting non-DEGs as DE (false positives). But two things must be considered at least when working with gene expression data: The first is that expression values are usually not normally distributed. Second, the distributions and variances of expression values vary across genes and conditions. ➡️ With that in mind, inference at the individual gene level can be addressed borrowing information from all the genes in the experiment through a Bayes or empirical Bayes method that produces more powerful tests. The idea of Bayesian statistics is to give unknown quantities a prior distribution, considering each feature as a member of a population of features such as genes. More specifically, empirical Bayes methods are procedures for statistical inference in which the (empirical) prior distribution is estimated from the population of all features (from the data) [8]; in standard Bayesian methods this prior distribution is fixed before observing any data [10]. Inspired by the work of Lönnstedt and Speed (2002) in which a simple expression for the posterior odds of differential expression for each gene was computed using a parametric empirical Bayes approach, Smyth, G. K. (2004) generalized this model for its application to experiments with any numbers of samples and conditions and reformulated the posterior odds statistic in terms of a moderated t-statistic in which the posterior residual standard deviations are used instead of the ordinary ones, eliminating the requirement of knowing the non-null prior guess for the proportion of differentially expressed genes required in the log-odds [11]. Let’s see how it proceeds. First, for each gene \\(g\\) we have a vector with the expression values in the \\(n\\) samples: \\[ y_{g}= (y_{g1}, y_{g2}, ..., y_{gn}) \\] We already know that the expected (predicted) gene expression in the samples is \\(E(y_{g})=X\\alpha_g\\) with \\(X\\) the design matrix and \\(\\alpha_g\\) the vector of the coefficients for the \\(h\\) covariates in the model; of these the ones of biological interest are the \\(\\beta_g\\)’s (contrasts of interest). Then, as previously described, a linear model is fitted to the expression data for each gene to obtain the coefficient estimators (\\(\\hat \\alpha_g\\)) (as well as \\(\\hat \\beta_g\\)), the residual sample variances (\\(s_g^2\\)) as estimators of the (true but unknown) residual variances (\\(\\sigma_g^2\\)), and the estimated covariance matrices. Two relevant considerations here: The expression values are not necessarily assumed to be normally distributed. The linear model is not assumed to be necessarily by least squares. However, there are two assumptions: The contrast estimators \\(\\hat \\beta_g\\) are assumed to be approximately normally distributed with mean \\(\\beta_g\\). The residual sample variances (\\(s_g^2\\)) are assumed to follow approximately a scaled chisquare distribution. Under such assumptions the ordinary t-stats for the covariate \\(j\\) in the gene \\(g\\) is defined by: \\[ t_{gj}=\\frac{\\hat \\beta_{gj}}{s_g u_{gj}}=\\frac{\\hat \\beta_{gj}}{SE(\\hat \\beta_{gj})} \\] with \\(s_g\\) the residual sample standard deviation of the gene and \\(u_{gj}\\) the unscaled standard deviation. \\(SE\\) stands for standard error. The key step in the empirical Bayes approach of limma is to leverage the information across all genes by defining prior distributions for the unknown coefficients \\(\\beta_{gj}\\) and residual variance \\(\\sigma_g^2\\) of the genes. For \\(\\beta_{gj}\\) it models the prior distribution of the coefficients that are not zero, i.e. is the expected distribution of the logFC of the genes that are DE, is given by: \\[\\beta_{gj}|\\sigma_{g}^2, \\beta_{gj}≠0 \\sim N(0, v_{0j}\\sigma_g^2)\\] “Saying that the betas have prior information centered around zero implies that we are ignorant of the sign (+/-) of the beta.” – Vincent Carey (personal communication) For the residual variances what limma does is to take the residual sample variances of all genes (\\(s_g^2\\)’s) and estimate the empirical parameters of the gamma distribution it is assumed that they follow. Specifically, \\(\\frac{1}{\\sigma_g^2}\\) is modeled by a scaled chisquare (gamma) prior distribution with mean \\(\\frac{1}{s_0^2}\\) and \\(d_0\\) degrees of freedom, describing how the residual variances are expected to vary across genes: \\[\\frac{1}{\\sigma_g^2} \\sim \\frac{1}{d_0s_0^2}\\chi_{d_0}^2\\] What we want to do next is not only to take the mean of the residual variances in the distribution (prior mean\\(\\frac{1}{s_0^2}\\)) but to estimate each gene residual variance as a Bayes predictor: as a weighted average of the prior mean (\\(\\frac{1}{s_0^2}\\)) and the observed sample variance (\\(s_g^2\\)) of each gene. This is called the moderated variance and what is graphically happening is that we are pulling the observed gene variances towards the prior mean variance: large variances are reduced and the |t-stats| increases (more powerful t-test for those genes) and small variances are increased, decreasing the |t-stats| and the power of the t-test. Under this model the posterior residual sample variance or posterior residual variance estimator (\\(\\tilde s_g^2\\)) is: \\[ \\tilde s_g^2=E(\\sigma_g^2|s_g^2)=\\frac{d_0s_0^2 + d_gs_g^2}{d_0+d_g} \\] Moderation is somehow like having larger sample sizes for the estimation of variance given that the moderated variances are (on average) closer to the population variance than the original sample variances. The moderated t-statistic can be now defined in terms of this posterior residual sample standard deviations instead of the usual ones: \\[ \\tilde t_{gj}=\\frac{\\hat \\beta_{gj}}{\\tilde s_g u_{gj}} \\] These moderated t-stats follow a t-distribution under the null hypothesis (\\(H_o:B_{gj}=0\\)) with degrees of freedom \\(d_g+d_0\\) and the associated p-values can be computed based on such distribution. As previously stated, with this redefined formula, large t-stats merely from very small \\(s_g\\)’s are avoided. This results in increased power and reduced false non-discovery rate (FNR) (non detected DEGs) and the number of DEGs obtained increases [8]. In the end we say we have moderated the residual sample standard deviations of each gene in the t-stats denominator by using the distribution of all of them across the population of genes. ✅ The approach of using the posterior values results in shrinking the gene-wise residual sample variances (\\(s_g^2\\)) towards the prior mean, making a more stable inference when a small number of samples is available. eBayes() will implement this empirical Bayes model to compute for each gene and for each contrast these moderated t-statistic and their unadjusted p-values. Additionally, it returns moderated F-statistic and log-odds of differential expression. The moderated F-statistic tests whether any of the contrasts for a gene is non-zero (\\(H_0:B_{g}=0\\)), i.e., whether that gene is differentially expressed for any contrast; it is similar to the ordinary F-statistic from analysis of variance (ANOVAR). The t-test does that for each individual contrast \\(j\\) (\\(H_0:B_{gj}=0\\)). 👉🏼 Check more about F-stats and other statistics computed by eBayes() here: https://support.bioconductor.org/p/6124/. ## eBayes() ## 1. Compute the empirical Bayes statistics for DE eBGene &lt;- eBayes(fitGene) ## Outputs of interest: ## s2.prior -&gt; prior residual variance (prior mean 1/s0^2) ## in prior distribution of residual variances eBGene$s2.prior #&gt; [1] 0.78987 ## df.prior -&gt; degrees of freedom d0 in prior distribution ## of residual variances eBGene$df.prior #&gt; [1] 4.913248 ## s2.post -&gt; posterior residual sample variances of the genes (~sg^2) length(eBGene$s2.post) #&gt; [1] 19974 head(eBGene$s2.post) #&gt; [1] 2.3397702 0.7092520 1.1613995 0.9579389 0.7390718 0.4996251 ## t -&gt; moderated t-stats of the genes for each contrast dim(eBGene$t) #&gt; [1] 19974 11 eBGene$t[1:5, 1:5] #&gt; (Intercept) GroupExperimental SexM flowcellHKCMHDSXX flowcellHKCNKDSXX #&gt; ENSMUSG00000051951.5 -4.4458336 -1.0615386 1.2467597 -4.8896590 -4.2555598 #&gt; ENSMUSG00000102331.1 1.5930925 4.5298885 1.3144392 -0.6934431 -1.3930231 #&gt; ENSMUSG00000025900.13 -1.2896585 0.8392518 1.4887297 -0.1047634 0.3829694 #&gt; ENSMUSG00000025902.13 0.4035855 -0.5885950 -0.5891347 -1.0922124 -1.6131630 #&gt; ENSMUSG00000098104.1 0.7120536 -0.3614893 -1.0031002 0.6473100 1.0165548 ## p.value: corresponding unadjusted p-values of moderated t-stats dim(eBGene$p.value) #&gt; [1] 19974 11 eBGene$p.value[1:5, 1:5] #&gt; (Intercept) GroupExperimental SexM flowcellHKCMHDSXX flowcellHKCNKDSXX #&gt; ENSMUSG00000051951.5 8.086618e-05 2.955320e-01 0.2205562 2.114989e-05 0.0001425797 #&gt; ENSMUSG00000102331.1 1.199041e-01 6.283899e-05 0.1970317 4.924924e-01 0.1721763827 #&gt; ENSMUSG00000025900.13 2.054130e-01 4.068800e-01 0.1452882 9.171465e-01 0.7039999597 #&gt; ENSMUSG00000025902.13 6.889106e-01 5.598170e-01 0.5594589 2.820128e-01 0.1154631942 #&gt; ENSMUSG00000098104.1 4.810321e-01 7.198519e-01 0.3225237 5.215478e-01 0.3161651149 📝 Exercise 5: obtain the moderated t-stats and associated p-values of all genes in you data for all covariates included in your model. 5.2.5 topTable() This function is also provided by limma and summarizes the results of the linear model, performs hypothesis tests and adjusts the p-values for multiple testing [12]. Among the summary statistics presented, it returns the log2FCs, moderated t-statistics, p-values, and FDR-adjusted p-values of the genes for a given contrast of interest. The default form of p-value adjustment is the Benjamini and Hochberg’s method to control the false discovery rate (FDR) which assumes independence between genes. Relevant concepts: q-value → is the FDR-adjusted p-value used to control the False Discovery Rate (FDR) that is the expected proportion of false discoveries among the discoveries (DEGs). Selecting discoveries as those being below \\(\\alpha\\) in q-value, we control FDR ≤ \\(\\alpha\\). Now we have the final statistics to determine wich genes are DE. ## topTable() ## 1. Obtain gene-wise DE stats for Group (Nicotine vs Ctrl) top_genes &lt;- topTable(eBGene, coef = coef, p.value = 1, number = nrow(rse_gene_filt), sort.by = &quot;none&quot;) ## Outputs for each gene and for the coeff selected (Group): ## logFC: log2-fold-changes head(top_genes$logFC) #&gt; [1] -0.05125195 0.72450620 0.17256694 -0.05025788 -0.02726320 -0.02684710 In limma the \\(\\beta_{gj}\\)’s are the logFC’s: setdiff(top_genes$logFC, eBGene$coefficients[, &quot;GroupExperimental&quot;]) #&gt; numeric(0) ## t: moderated t-stats head(top_genes$t) #&gt; [1] -1.0615386 4.5298885 0.8392518 -0.5885950 -0.3614893 -1.0959528 ## . P.value: unadjusted p-values of t-stats head(top_genes$P.Value) #&gt; [1] 2.955320e-01 6.283899e-05 4.068800e-01 5.598170e-01 7.198519e-01 2.803946e-01 ## adj.P.Val: p-values adjusted to control the FDR head(top_genes$adj.P.Val) #&gt; [1] 0.53854173 0.00412576 0.63704026 0.75340755 0.85943342 0.52324928 After running all these 5 steps, one main initial plot we have to look at is the histogram of the p-values of the moderated t-stats of the genes. If there were DEGs, we’d expect to see a flat distribution of p-values corresponding to non-DEGs and a peak near p=0 for DEGs (for which we reject the null hypothesis). If this peak is absent but a uniform distribution still appears, DEGs might be detected after correcting for multiple testing. ## Histogram of unadjusted p-values hist(top_genes$P.Value, xlab = &quot;p-values&quot;, main = &quot;&quot;) If very different p-value distributions are obtained from the uniform one, the best we can do is trying to explore if there are specific groups of genes (e.g. lowly-expressed genes) presenting such variable p-values and revisiting the assumptions and considerations of the statistical tests implemented [13]. 📝 Exercise 6: obtain the DE logFCs, t-stats, p-values, and adjusted p-values of the genes for a given constrast/covariate under study. 5.3 DE visualization DEGs are identified defining a significance threshold (on the adjusted p-values). Let’s quantify the number of DEGs for nicotine exposure in pup brain and visualize their expression and DE statistics. ## DEGs for FDR&lt;0.05 de_genes &lt;- top_genes[which(top_genes$adj.P.Val &lt; 0.05), ] ## Number of DEGs dim(de_genes) #&gt; [1] 1895 6 5.3.1 Volcano plots A very practical and useful plot to graphically represent DEGs and visualize their expression differences between conditions is a volcano plot. This is a scatter plot of the logFC’s of the genes in the x-axis vs their adjusted p-values in a -log scale in the y-axis. library(&quot;ggplot2&quot;) ## Define up- and down-regulated DEGs, and non-DEGs FDR &lt;- 0.05 DE &lt;- vector() for (i in 1:dim(top_genes)[1]) { if (top_genes$adj.P.Val[i] &gt; FDR) { DE &lt;- append(DE, &quot;n.s.&quot;) } else { if (top_genes$logFC[i] &gt; 0) { DE &lt;- append(DE, &quot;Up&quot;) } else { DE &lt;- append(DE, &quot;Down&quot;) } } } top_genes$DE &lt;- DE ## Colors, sizes and transparencies for up &amp; down DEGs and non-DEGs cols &lt;- c(&quot;Up&quot; = &quot;indianred2&quot;, &quot;Down&quot; = &quot;steelblue2&quot;, &quot;n.s.&quot; = &quot;grey&quot;) sizes &lt;- c(&quot;Up&quot; = 1.3, &quot;Down&quot; = 1.3, &quot;n.s.&quot; = 0.8) alphas &lt;- c(&quot;Up&quot; = 0.4, &quot;Down&quot; = 0.6, &quot;n.s.&quot; = 0.5) ## Plot volcano plot ggplot( data = top_genes, aes( x = logFC, y = -log10(adj.P.Val), color = DE, fill = DE, size = DE, alpha = DE ) ) + geom_point(shape = 21) + geom_hline( yintercept = -log10(FDR), linetype = &quot;dashed&quot;, color = &quot;gray35&quot;, linewidth = 0.5 ) + geom_vline( xintercept = c(-1, 1), linetype = &quot;dashed&quot;, color = &quot;gray35&quot;, linewidth = 0.5 ) + labs(y = &quot;-log10(FDR)&quot;, x = &quot;logFC(Nicotine vs Control)&quot;) + theme_bw() + scale_color_manual(values = cols, name = &quot;Differential expression&quot;) + scale_fill_manual(values = cols, name = &quot;Differential expression&quot;) + scale_size_manual(values = sizes, name = &quot;Differential expression&quot;) + scale_alpha_manual(values = alphas, name = &quot;Differential expression&quot;) + theme( plot.margin = unit(c(1, 1, 1, 1), &quot;cm&quot;), legend.key.height = unit(0.15, &quot;cm&quot;), axis.title = element_text(size = (13)), legend.title = element_text(size = 13), legend.text = element_text(size = 12) ) 5.3.2 Heat maps Another common way to represent differential expression results is through a heat map. The package ComplexHeatmap offers a flexible toolkit to easily create heat maps with row and column annotations, a feature of particular value to plot expression data of genes across samples with multiple biological and technical differences. Although initially all genes in your data can be plotted, frequently only DEGs are included as they tend to show clearer gene expression patterns. library(&quot;ComplexHeatmap&quot;) ## We plot lognorm counts lognorm_data &lt;- assays(rse_gene_filt)$logcounts ## Subset to DEGs only lognorm_data &lt;- lognorm_data[rownames(de_genes), ] ## Define column (sample) names to display colnames(lognorm_data) &lt;- paste0(&quot;Pup_&quot;, 1:dim(lognorm_data)[2]) 🗒️ Notes: It is sometimes convenient to regress out the technical variables’ contributions on gene expression to see more clearly the effects of interest. This can happen, for instance, when the logFCs are too small to see any significant differences in the plots or when there are other strong confounding factors. Functions such as cleaningY() of jaffelab can be used for this purpose. The lognorm counts have to be correctly scaled and centered (around zero) to make the differences in the expression of the genes more notorious in the heat map. A simple way to do that is substracting from each lognorm count \\(y_{gi}\\) (from the gene \\(g\\) and sample \\(i\\)) the mean expression of the gene* and dividing by the standard deviation (\\(\\sigma\\)) of the same gene expression values. This is formally called the z-score: the number of standard deviations away from the mean. \\[ z=\\frac{y_{gi} - \\frac{\\sum_{k=1}^{n}{y_{gk}}}{n}}{\\sigma}, \\] \\(n\\) is the number of samples. * This can also be done by columns (samples), not only by rows (genes). 👉🏼 For more on centering and scaling, see this video: ## Center and scale the data to make differences more evident lognorm_data &lt;- (lognorm_data - rowMeans(lognorm_data)) / rowSds(lognorm_data) ## Sample annotation: Sex, Group, and library size col_anno &lt;- HeatmapAnnotation( df = as.data.frame(colData(rse_gene_filt)[, c(&quot;Sex&quot;, &quot;Group&quot;)]), library_size = anno_barplot(colData(rse_gene_filt)$sum, gp = gpar(fill = &quot;lightyellow2&quot;)), col = list( &quot;Sex&quot; = c(&quot;F&quot; = &quot;hotpink1&quot;, &quot;M&quot; = &quot;dodgerblue&quot;), &quot;Group&quot; = c(&quot;Control&quot; = &quot;gray68&quot;, &quot;Experimental&quot; = &quot;gold2&quot;) ) ) ## Gene annotation: logFC and biotype de_genes$logFC_binary &lt;- sapply(de_genes$logFC, function(x) { if (x &gt; 0) { &quot;&gt;0&quot; } else { &quot;&lt;0&quot; } }) de_genes$protein_coding_gene &lt;- sapply(rowData(rse_gene_filt[rownames(de_genes), ])$gene_type, function(x) { if (x == &quot;protein_coding&quot;) { &quot;TRUE&quot; } else { &quot;FALSE&quot; } }) gene_anno &lt;- rowAnnotation( df = as.data.frame(cbind( &quot;logFC&quot; = de_genes$logFC_binary, &quot;protein_coding_gene&quot; = de_genes$protein_coding_gene )), col = list( &quot;logFC&quot; = c(&quot;&lt;0&quot; = &quot;deepskyblue3&quot;, &quot;&gt;0&quot; = &quot;brown2&quot;), &quot;protein_coding_gene&quot; = c(&quot;TRUE&quot; = &quot;darkseagreen3&quot;, &quot;FALSE&quot; = &quot;magenta&quot;) ) ) library(&quot;circlize&quot;) ## Plot Heatmap(lognorm_data, name = &quot;lognorm counts&quot;, show_row_names = FALSE, top_annotation = col_anno, left_annotation = gene_anno, row_km = 2, column_km = 2, col = colorRamp2(c(-4, -0.0001, 00001, 4), c(&quot;darkblue&quot;, &quot;lightblue&quot;, &quot;lightsalmon&quot;, &quot;darkred&quot;)), row_title = &quot;DEGs&quot;, column_title = &quot;Samples&quot;, column_names_gp = gpar(fontsize = 7), heatmap_width = unit(12.5, &quot;cm&quot;), heatmap_height = unit(12.5, &quot;cm&quot;) ) 📝 Exercise 7: obtain the number of DEGs you got and represent them in a volcano plot and a heat map. Include all the sample and gene information you consider relevant in the latter. References Li, W. V., &amp; Li, J. J. (2018). Modeling and analysis of RNA‐seq data: a review from a statistical perspective. Quantitative Biology, 6(3), 195-209. Law, C. W., Chen, Y., Shi, W., &amp; Smyth, G. K. (2014). voom: Precision weights unlock linear model analysis tools for RNA-seq read counts. Genome biology, 15(2), 1-17. Smyth, G. K., Ritchie, M., Thorne, N., Wettenhall, J., Shi, W., &amp; Hu, Y. (2002). limma: linear models for microarray and RNA-Seq data user’s guide. Bioinformatics Division, The Walter and Eliza Hall Institute of Medical Research, Melbourne, Australia. van den Berg, S. M. (2022). Analysing data using linear models. Web site: https://bookdown.org/pingapang9/linear_models_bookdown/ Wikipedia. (n.d.). Ordinary least squares. Web site: https://en.wikipedia.org/wiki/Ordinary_least_squares Taboga, Marco (2021). “Generalized least squares”, Lectures on probability theory and mathematical statistics. Kindle Direct Publishing. Online appendix. https://www.statlect.com/fundamentals-of-statistics/generalized-least-squares. Documentation for lmFit: https://rdrr.io/bioc/limma/man/lmFit.html The Pennsylvania State University. (2018). Statistical Analysis of Genomics Data. Web site: https://online.stat.psu.edu/stat555/node/36/ Tushe, M. (2021). A Simple Trick to Understand the t-test. Web site: https://miroslavtushev.medium.com/a-simple-trick-to-understand-the-t-test-2c2a9e7f1dc5 Wikipedia. (n.d.). Empirical Bayes method. Web site: https://en.wikipedia.org/wiki/Empirical_Bayes_method#:~:text=Empirical Bayes methods are procedures,before any data are observed. Smyth, G. K. (2004). Linear models and empirical bayes methods for assessing differential expression in microarray experiments. Statistical applications in genetics and molecular biology, 3(1). Documentation for topTable: https://www.rdocumentation.org/packages/limma/versions/3.28.14/topics/toptable Robinson, D. (2014). How to interpret a p-value histogram. Web site: http://varianceexplained.org/statistics/interpreting-pvalue-histogram/ "],["interpreting-model-coefficients-with-exploremodelmatrix.html", "6 Interpreting model coefficients with ExploreModelMatrix 6.1 Model objects in R 6.2 ExploreModelMatrix 6.3 Example 1 6.4 Example 2 6.5 Example 3 6.6 Exercise 6.7 To learn more 6.8 Community", " 6 Interpreting model coefficients with ExploreModelMatrix Instructor: Leo 6.1 Model objects in R Linear regression review https://lcolladotor.github.io/bioc_team_ds/helping-others.html#linear-regression-example With R, we use the model.matrix() to build regression models using the Y ~ X1 + X2 formula syntax as exemplified below. ## ?model.matrix mat &lt;- with(trees, model.matrix(log(Volume) ~ log(Height) + log(Girth))) mat #&gt; (Intercept) log(Height) log(Girth) #&gt; 1 1 4.248495 2.116256 #&gt; 2 1 4.174387 2.151762 #&gt; 3 1 4.143135 2.174752 #&gt; 4 1 4.276666 2.351375 #&gt; 5 1 4.394449 2.370244 #&gt; 6 1 4.418841 2.379546 #&gt; 7 1 4.189655 2.397895 #&gt; 8 1 4.317488 2.397895 #&gt; 9 1 4.382027 2.406945 #&gt; 10 1 4.317488 2.415914 #&gt; 11 1 4.369448 2.424803 #&gt; 12 1 4.330733 2.433613 #&gt; 13 1 4.330733 2.433613 #&gt; 14 1 4.234107 2.459589 #&gt; 15 1 4.317488 2.484907 #&gt; 16 1 4.304065 2.557227 #&gt; [ reached getOption(&quot;max.print&quot;) -- omitted 15 rows ] #&gt; attr(,&quot;assign&quot;) #&gt; [1] 0 1 2 colnames(mat) #&gt; [1] &quot;(Intercept)&quot; &quot;log(Height)&quot; &quot;log(Girth)&quot; How do we interpret the columns of our model matrix mat? summary(lm(log(Volume) ~ log(Height) + log(Girth), data = trees)) #&gt; #&gt; Call: #&gt; lm(formula = log(Volume) ~ log(Height) + log(Girth), data = trees) #&gt; #&gt; Residuals: #&gt; Min 1Q Median 3Q Max #&gt; -0.168561 -0.048488 0.002431 0.063637 0.129223 #&gt; #&gt; Coefficients: #&gt; Estimate Std. Error t value Pr(&gt;|t|) #&gt; (Intercept) -6.63162 0.79979 -8.292 5.06e-09 *** #&gt; log(Height) 1.11712 0.20444 5.464 7.81e-06 *** #&gt; log(Girth) 1.98265 0.07501 26.432 &lt; 2e-16 *** #&gt; --- #&gt; Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 #&gt; #&gt; Residual standard error: 0.08139 on 28 degrees of freedom #&gt; Multiple R-squared: 0.9777, Adjusted R-squared: 0.9761 #&gt; F-statistic: 613.2 on 2 and 28 DF, p-value: &lt; 2.2e-16 6.2 ExploreModelMatrix It’s a Bioconductor package which is useful to understand statistical models we use in differential expression analyses. It is interactive and helps us by creating some visual aids. http://www.bioconductor.org/packages/ExploreModelMatrix For more details, check their paper https://doi.org/10.12688/f1000research.24187.2. We’ll go over the examples they provide at http://www.bioconductor.org/packages/release/bioc/vignettes/ExploreModelMatrix/inst/doc/ExploreModelMatrix.html 6.3 Example 1 ## Load ExploreModelMatrix library(&quot;ExploreModelMatrix&quot;) ## Example data (sampleData &lt;- data.frame( genotype = rep(c(&quot;A&quot;, &quot;B&quot;), each = 4), treatment = rep(c(&quot;ctrl&quot;, &quot;trt&quot;), 4) )) #&gt; genotype treatment #&gt; 1 A ctrl #&gt; 2 A trt #&gt; 3 A ctrl #&gt; 4 A trt #&gt; 5 B ctrl #&gt; 6 B trt #&gt; 7 B ctrl #&gt; 8 B trt ## Let&#39;s make the visual aids provided by ExploreModelMatrix vd &lt;- ExploreModelMatrix::VisualizeDesign( sampleData = sampleData, designFormula = ~ genotype + treatment, textSizeFitted = 4 ) ## Now lets plot these images cowplot::plot_grid(plotlist = vd$plotlist) Interactively, we can run the following code: ## We are using shiny again here app &lt;- ExploreModelMatrix( sampleData = sampleData, designFormula = ~ genotype + treatment ) if (interactive()) shiny::runApp(app) 6.4 Example 2 http://bioconductor.org/packages/release/bioc/vignettes/ExploreModelMatrix/inst/doc/ExploreModelMatrix.html#example-2 6.5 Example 3 http://bioconductor.org/packages/release/bioc/vignettes/ExploreModelMatrix/inst/doc/ExploreModelMatrix.html#example-3 6.6 Exercise p.exercise { background-color: #E4EDE2; padding: 9px; border: 1px solid black; border-radius: 10px; font-family: sans-serif; } Exercise 1: Interpret ResponseResistant.Treatmentpre from the second example. It could be useful to take a screenshot and to draw some annotations on it. Exercise 2: Whis is the 0 important at the beginning of the formula in the third example? 6.7 To learn more A guide to creating design matrices for gene expression experiments: http://bioconductor.org/packages/release/workflows/vignettes/RNAseq123/inst/doc/designmatrices.html https://f1000research.com/articles/9-1444 “Model matrix not full rank” http://bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#model-matrix-not-full-rank 6.8 Community Some of the ExploreModelMatrix authors: https://twitter.com/CSoneson https://twitter.com/FedeBioinfo https://twitter.com/mikelove "],["differential-gene-expression-analysis-with-limma.html", "7 Differential gene expression analysis with limma 7.1 SRP045638 data 7.2 Data normalization 7.3 Differential expression 7.4 Visualizing DEGs 7.5 Community", " 7 Differential gene expression analysis with limma Instructor: Leo 7.1 SRP045638 data We’ll use data from https://www.ncbi.nlm.nih.gov/sra/?term=SRP045638 processed and made available through the recount3 project. First, we need to download the data with the same commands we saw earlier. library(&quot;recount3&quot;) human_projects &lt;- available_projects() #&gt; 2024-06-06 18:34:48.255447 caching file sra.recount_project.MD.gz. #&gt; 2024-06-06 18:34:48.561094 caching file gtex.recount_project.MD.gz. #&gt; 2024-06-06 18:34:48.909313 caching file tcga.recount_project.MD.gz. rse_gene_SRP045638 &lt;- create_rse( subset( human_projects, project == &quot;SRP045638&quot; &amp; project_type == &quot;data_sources&quot; ) ) #&gt; 2024-06-06 18:34:51.226221 downloading and reading the metadata. #&gt; 2024-06-06 18:34:51.459789 caching file sra.sra.SRP045638.MD.gz. #&gt; adding rname &#39;http://duffel.rail.bio/recount3/human/data_sources/sra/metadata/38/SRP045638/sra.sra.SRP045638.MD.gz&#39; #&gt; 2024-06-06 18:34:52.247184 caching file sra.recount_project.SRP045638.MD.gz. #&gt; adding rname &#39;http://duffel.rail.bio/recount3/human/data_sources/sra/metadata/38/SRP045638/sra.recount_project.SRP045638.MD.gz&#39; #&gt; 2024-06-06 18:34:53.121973 caching file sra.recount_qc.SRP045638.MD.gz. #&gt; adding rname &#39;http://duffel.rail.bio/recount3/human/data_sources/sra/metadata/38/SRP045638/sra.recount_qc.SRP045638.MD.gz&#39; #&gt; 2024-06-06 18:34:53.966259 caching file sra.recount_seq_qc.SRP045638.MD.gz. #&gt; adding rname &#39;http://duffel.rail.bio/recount3/human/data_sources/sra/metadata/38/SRP045638/sra.recount_seq_qc.SRP045638.MD.gz&#39; #&gt; 2024-06-06 18:34:54.799806 caching file sra.recount_pred.SRP045638.MD.gz. #&gt; adding rname &#39;http://duffel.rail.bio/recount3/human/data_sources/sra/metadata/38/SRP045638/sra.recount_pred.SRP045638.MD.gz&#39; #&gt; 2024-06-06 18:34:55.452049 downloading and reading the feature information. #&gt; 2024-06-06 18:34:55.691336 caching file human.gene_sums.G026.gtf.gz. #&gt; 2024-06-06 18:34:56.11464 downloading and reading the counts: 66 samples across 63856 features. #&gt; 2024-06-06 18:34:56.329927 caching file sra.gene_sums.SRP045638.G026.gz. #&gt; adding rname &#39;http://duffel.rail.bio/recount3/human/data_sources/sra/gene_sums/38/SRP045638/sra.gene_sums.SRP045638.G026.gz&#39; #&gt; 2024-06-06 18:34:58.559167 constructing the RangedSummarizedExperiment (rse) object. assay(rse_gene_SRP045638, &quot;counts&quot;) &lt;- compute_read_counts(rse_gene_SRP045638) Now that we have the data and have computed the read counts (which will be needed for downstream analyses), we can use expand_sra_attributes() to make it easier to use the sample information in downstream analyses. However, we have to resolve some issues with this data first. ## Can you notice the problem with the sample information? rse_gene_SRP045638$sra.sample_attributes[1:3] #&gt; [1] &quot;age;;67.78|biomaterial_provider;;LIBD|BioSampleModel;;Human|dev_stage;;Fetal|disease;;Control|Fraction;;total|isolate;;DLPFC|race;;AA|RIN;;8.3|sex;;female|tissue;;DLPFC&quot; #&gt; [2] &quot;age;;40.42|biomaterial_provider;;LIBD|BioSampleModel;;Human|disease;;Control|Fraction;;total|isolate;;DLPFC|race;;AA|RIN;;8.4|sex;;male|tissue;;DLPFC&quot; #&gt; [3] &quot;age;;41.58|biomaterial_provider;;LIBD|BioSampleModel;;Human|disease;;control|Fraction;;total|isolate;;R2869|race;;AA|RIN;;8.7|sex;;male|tissue;;DLPFC&quot; Lets resolve the issue we detected with this sample information. We’ll resolve this by eliminating some information that is only present in a subset of samples and that we don’t need. rse_gene_SRP045638$sra.sample_attributes &lt;- gsub(&quot;dev_stage;;Fetal\\\\|&quot;, &quot;&quot;, rse_gene_SRP045638$sra.sample_attributes) rse_gene_SRP045638$sra.sample_attributes[1:3] #&gt; [1] &quot;age;;67.78|biomaterial_provider;;LIBD|BioSampleModel;;Human|disease;;Control|Fraction;;total|isolate;;DLPFC|race;;AA|RIN;;8.3|sex;;female|tissue;;DLPFC&quot; #&gt; [2] &quot;age;;40.42|biomaterial_provider;;LIBD|BioSampleModel;;Human|disease;;Control|Fraction;;total|isolate;;DLPFC|race;;AA|RIN;;8.4|sex;;male|tissue;;DLPFC&quot; #&gt; [3] &quot;age;;41.58|biomaterial_provider;;LIBD|BioSampleModel;;Human|disease;;control|Fraction;;total|isolate;;R2869|race;;AA|RIN;;8.7|sex;;male|tissue;;DLPFC&quot; Now we can continue our work using similar code from the one we used earlier. rse_gene_SRP045638 &lt;- expand_sra_attributes(rse_gene_SRP045638) colData(rse_gene_SRP045638)[ , grepl(&quot;^sra_attribute&quot;, colnames(colData(rse_gene_SRP045638))) ] #&gt; DataFrame with 66 rows and 10 columns #&gt; sra_attribute.age sra_attribute.biomaterial_provider sra_attribute.BioSampleModel sra_attribute.disease #&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; #&gt; SRR2071341 67.78 LIBD Human Control #&gt; SRR2071345 40.42 LIBD Human Control #&gt; SRR2071346 41.58 LIBD Human control #&gt; SRR2071347 44.17 LIBD Human control #&gt; sra_attribute.Fraction sra_attribute.isolate sra_attribute.race sra_attribute.RIN sra_attribute.sex #&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; #&gt; SRR2071341 total DLPFC AA 8.3 female #&gt; SRR2071345 total DLPFC AA 8.4 male #&gt; SRR2071346 total R2869 AA 8.7 male #&gt; SRR2071347 total R3098 AA 5.3 female #&gt; sra_attribute.tissue #&gt; &lt;character&gt; #&gt; SRR2071341 DLPFC #&gt; SRR2071345 DLPFC #&gt; SRR2071346 DLPFC #&gt; SRR2071347 DLPFC #&gt; [ reached getOption(&quot;max.print&quot;) -- omitted 7 rows ] As well use the sampel information for building our statistical model, it will important that we make sure that it is on the correct format R expects later on. ## Recast character vectors into numeric or factor ones rse_gene_SRP045638$sra_attribute.age &lt;- as.numeric(rse_gene_SRP045638$sra_attribute.age) rse_gene_SRP045638$sra_attribute.disease &lt;- factor(tolower(rse_gene_SRP045638$sra_attribute.disease)) rse_gene_SRP045638$sra_attribute.RIN &lt;- as.numeric(rse_gene_SRP045638$sra_attribute.RIN) rse_gene_SRP045638$sra_attribute.sex &lt;- factor(rse_gene_SRP045638$sra_attribute.sex) ## Summary of our variables of interest summary(as.data.frame(colData(rse_gene_SRP045638)[ , grepl(&quot;^sra_attribute.[age|disease|RIN|sex]&quot;, colnames(colData(rse_gene_SRP045638))) ])) #&gt; sra_attribute.age sra_attribute.disease sra_attribute.isolate sra_attribute.RIN sra_attribute.sex #&gt; Min. :-0.4986 control:66 Length:66 Min. :5.30 female:22 #&gt; 1st Qu.: 0.3424 Class :character 1st Qu.:8.00 male :44 #&gt; Median :14.9000 Mode :character Median :8.30 #&gt; Mean :22.6286 Mean :8.15 #&gt; 3rd Qu.:41.2900 3rd Qu.:8.70 #&gt; Max. :73.9100 Max. :9.60 We’ll now create a few variables from this sample information so we can use them in our analysis. ## We&#39;ll want to look for differences between prenatal and postnatal samples rse_gene_SRP045638$prenatal &lt;- factor(ifelse(rse_gene_SRP045638$sra_attribute.age &lt; 0, &quot;prenatal&quot;, &quot;postnatal&quot;)) table(rse_gene_SRP045638$prenatal) #&gt; #&gt; postnatal prenatal #&gt; 56 10 ## http://rna.recount.bio/docs/quality-check-fields.html rse_gene_SRP045638$assigned_gene_prop &lt;- rse_gene_SRP045638$recount_qc.gene_fc_count_all.assigned / rse_gene_SRP045638$recount_qc.gene_fc_count_all.total summary(rse_gene_SRP045638$assigned_gene_prop) #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 0.1942 0.7004 0.7591 0.7170 0.7991 0.8493 with(colData(rse_gene_SRP045638), plot(assigned_gene_prop, sra_attribute.RIN)) ## Hm... lets check if there is a difference between these two groups with(colData(rse_gene_SRP045638), tapply(assigned_gene_prop, prenatal, summary)) #&gt; $postnatal #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 0.1942 0.7072 0.7719 0.7179 0.8017 0.8493 #&gt; #&gt; $prenatal #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 0.6856 0.7004 0.7088 0.7116 0.7259 0.7347 We can next drop some samples that we consider of low quality as well as genes that have low expression levels. ## Lets save our full object for now in case we change our minds later on rse_gene_SRP045638_unfiltered &lt;- rse_gene_SRP045638 ## Lets drop some bad samples. On a real analysis, you would likely use ## some statistical method for identifying outliers such as scuttle::isOutlier() hist(rse_gene_SRP045638$assigned_gene_prop) table(rse_gene_SRP045638$assigned_gene_prop &lt; 0.3) #&gt; #&gt; FALSE TRUE #&gt; 65 1 rse_gene_SRP045638 &lt;- rse_gene_SRP045638[, rse_gene_SRP045638$assigned_gene_prop &gt; 0.3] ## Lets compute the mean expression levels. ## ## Note: in a real analysis we would likely do this with RPKMs or CPMs instead ## of counts. That is, we would use one of the following options: # edgeR::filterByExpr() https://bioconductor.org/packages/edgeR/ https://rdrr.io/bioc/edgeR/man/filterByExpr.html # genefilter::genefilter() https://bioconductor.org/packages/genefilter/ https://rdrr.io/bioc/genefilter/man/genefilter.html # jaffelab::expression_cutoff() http://research.libd.org/jaffelab/reference/expression_cutoff.html # gene_means &lt;- rowMeans(assay(rse_gene_SRP045638, &quot;counts&quot;)) summary(gene_means) #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 0.0 0.1 2.5 815.2 170.2 1362047.9 ## We can now drop genes with low expression levels rse_gene_SRP045638 &lt;- rse_gene_SRP045638[gene_means &gt; 0.1, ] ## Final dimensions of our RSE object dim(rse_gene_SRP045638) #&gt; [1] 46929 65 ## Percent of genes that we retained: round(nrow(rse_gene_SRP045638) / nrow(rse_gene_SRP045638_unfiltered) * 100, 2) #&gt; [1] 73.49 We are now ready to continue with the differential expression analysis. Well, almost! 😅 7.2 Data normalization Read the A hypothetical scenario in one of the edgeR papers https://genomebiology.biomedcentral.com/articles/10.1186/gb-2010-11-3-r25#Sec2 to understand the concept of composition bias. This concept is still relevant nowadays with single cell RNA-seq (scRNA-seq) data as you can see at http://bioconductor.org/books/3.16/OSCA.multisample/multi-sample-comparisons.html#performing-the-de-analysis. In that chapter they describe a series of steps for re-using bulk RNA-seq methods with scRNA-seq data. ## Use edgeR::calcNormFactors() to address the composition bias library(&quot;edgeR&quot;) dge &lt;- DGEList( counts = assay(rse_gene_SRP045638, &quot;counts&quot;), genes = rowData(rse_gene_SRP045638) ) dge &lt;- calcNormFactors(dge) 7.3 Differential expression First of all, lets define our differential expression model. Typically, we would explore the data more to check that there are no other quality control issues with our samples and to explore in more detail the relationship between our sample phenotype variables. library(&quot;ggplot2&quot;) ggplot(as.data.frame(colData(rse_gene_SRP045638)), aes(y = assigned_gene_prop, x = prenatal)) + geom_boxplot() + theme_bw(base_size = 20) + ylab(&quot;Assigned Gene Prop&quot;) + xlab(&quot;Age Group&quot;) For example, we would explore the contribution of different variables to the gene expression variability we observe using the variancePartition and scater Bioconductor packages, among others. We’ll do more of this tomorrow but you can also check these LIBD rstats club notes. For now, we’ll use the following stastistical model. mod &lt;- model.matrix(~ prenatal + sra_attribute.RIN + sra_attribute.sex + assigned_gene_prop, data = colData(rse_gene_SRP045638) ) colnames(mod) #&gt; [1] &quot;(Intercept)&quot; &quot;prenatalprenatal&quot; &quot;sra_attribute.RIN&quot; &quot;sra_attribute.sexmale&quot; #&gt; [5] &quot;assigned_gene_prop&quot; Now that we have a model, we can use limma to actually compute the differential expression statistics and extract the results. library(&quot;limma&quot;) vGene &lt;- voom(dge, mod, plot = TRUE) eb_results &lt;- eBayes(lmFit(vGene)) de_results &lt;- topTable( eb_results, coef = 2, number = nrow(rse_gene_SRP045638), sort.by = &quot;none&quot; ) dim(de_results) #&gt; [1] 46929 16 head(de_results) #&gt; source type bp_length phase gene_id gene_type gene_name level #&gt; ENSG00000223972.5 HAVANA gene 1735 NA ENSG00000223972.5 transcribed_unprocessed_pseudogene DDX11L1 2 #&gt; ENSG00000278267.1 ENSEMBL gene 68 NA ENSG00000278267.1 miRNA MIR6859-1 3 #&gt; ENSG00000227232.5 HAVANA gene 1351 NA ENSG00000227232.5 unprocessed_pseudogene WASH7P 2 #&gt; havana_gene tag logFC AveExpr t P.Value adj.P.Val B #&gt; ENSG00000223972.5 OTTHUMG00000000961.2 &lt;NA&gt; -0.4522185 -3.444164 -1.637034 1.064080e-01 1.348462e-01 -5.554484 #&gt; ENSG00000278267.1 &lt;NA&gt; &lt;NA&gt; 1.1158860 -1.311645 6.123756 5.743771e-08 2.105690e-07 7.763912 #&gt; ENSG00000227232.5 OTTHUMG00000000958.1 &lt;NA&gt; 0.6860298 3.641131 5.644804 3.816951e-07 1.247133e-06 5.500784 #&gt; [ reached &#39;max&#39; / getOption(&quot;max.print&quot;) -- omitted 3 rows ] ## Differentially expressed genes between pre and post natal with FDR &lt; 5% table(de_results$adj.P.Val &lt; 0.05) #&gt; #&gt; FALSE TRUE #&gt; 12851 34078 ## We can now visualize the resulting differential expression results plotMA(eb_results, coef = 2) ## We can also make a volcano plot volcanoplot(eb_results, coef = 2, highlight = 3, names = de_results$gene_name) de_results[de_results$gene_name %in% c(&quot;ZSCAN2&quot;, &quot;VASH2&quot;, &quot;KIAA0922&quot;), ] #&gt; source type bp_length phase gene_id gene_type gene_name level havana_gene #&gt; ENSG00000143494.15 HAVANA gene 9086 NA ENSG00000143494.15 protein_coding VASH2 2 OTTHUMG00000036925.5 #&gt; ENSG00000176371.13 HAVANA gene 4878 NA ENSG00000176371.13 protein_coding ZSCAN2 1 OTTHUMG00000074027.5 #&gt; ENSG00000121210.15 HAVANA gene 6393 NA ENSG00000121210.15 protein_coding KIAA0922 2 OTTHUMG00000153244.5 #&gt; tag logFC AveExpr t P.Value adj.P.Val B #&gt; ENSG00000143494.15 &lt;NA&gt; 5.444271 1.876990 37.85216 2.561452e-46 6.010319e-42 95.10126 #&gt; ENSG00000176371.13 &lt;NA&gt; 2.735639 2.751109 36.59344 2.137022e-45 3.342943e-41 92.99949 #&gt; ENSG00000121210.15 &lt;NA&gt; 3.283050 2.945269 41.89725 4.235912e-49 1.987871e-44 101.31124 https://www.genecards.org/cgi-bin/carddisp.pl?gene=ZSCAN2 https://www.genecards.org/cgi-bin/carddisp.pl?gene=VASH2 https://www.genecards.org/cgi-bin/carddisp.pl?gene=KIAA0922 7.4 Visualizing DEGs From vGene$E we can extract the normalized expression values that limma-voom computed. We can check the top 50 differentially expressed genes (DEGs) for example. ## Extract the normalized expression values from our limma-voom result ## from earlier exprs_heatmap &lt;- vGene$E[rank(de_results$adj.P.Val) &lt;= 50, ] ## We can now build a table with information about our samples and ## then make the names a bit more friendly by making them easier to ## understand df &lt;- as.data.frame(colData(rse_gene_SRP045638)[, c(&quot;prenatal&quot;, &quot;sra_attribute.RIN&quot;, &quot;sra_attribute.sex&quot;)]) colnames(df) &lt;- c(&quot;AgeGroup&quot;, &quot;RIN&quot;, &quot;Sex&quot;) ## Next, we can make a basic heatmap library(&quot;pheatmap&quot;) pheatmap( exprs_heatmap, cluster_rows = TRUE, cluster_cols = TRUE, show_rownames = FALSE, show_colnames = FALSE, annotation_col = df ) We’ll learn more about gene expression heatmaps tomorrow! Overall, these DEG results are not as surprising since there is a huge difference between pre and post natal gene expression in the human DLPFC. We can see that more clearly with a MDS (multidimensional scaling) plot just like its described in the limma workflow. Tomas will teach you more about dimension reduction tomorrow. ## For nicer colors library(&quot;RColorBrewer&quot;) ## Mapping age groups into colors col.group &lt;- df$AgeGroup levels(col.group) &lt;- brewer.pal(nlevels(col.group), &quot;Set1&quot;) #&gt; Warning in brewer.pal(nlevels(col.group), &quot;Set1&quot;): minimal value for n is 3, returning requested palette with 3 different levels col.group &lt;- as.character(col.group) ## MDS by age groups limma::plotMDS(vGene$E, labels = df$AgeGroup, col = col.group) ## Mapping Sex values into colors col.sex &lt;- df$Sex levels(col.sex) &lt;- brewer.pal(nlevels(col.sex), &quot;Dark2&quot;) #&gt; Warning in brewer.pal(nlevels(col.sex), &quot;Dark2&quot;): minimal value for n is 3, returning requested palette with 3 different levels col.sex &lt;- as.character(col.sex) ## MDS by Sex limma::plotMDS(vGene$E, labels = df$Sex, col = col.sex) A lot of times, running the differential expression analysis is not the hard part. Building your model and having all the covariates you need can take much more work! 7.5 Community Some edgeR and limma authors: https://twitter.com/mritchieau https://twitter.com/davisjmcc https://twitter.com/markrobinsonca https://twitter.com/AliciaOshlack If you've ever been dazed by design matrices or confused by contrasts when performing gene expression analysis in limma, the new article by Charity Law is for you https://t.co/ZSMOA20tdm #bioconductor #rstats (1/2) — Matt Ritchie (@mritchieau) December 15, 2020 "],["dge-model-building-with-variancepartition.html", "8 DGE model building with variancePartition 8.1 Canonical Correlation Analysis 8.2 Fit model and extract fraction of variance explained 8.3 Examine the expression of most affected genes by each sample variable References", " 8 DGE model building with variancePartition Instructor: Daianna After having processed RNA-seq data and assessed the quality and the variability of the samples the next step for DGE is to explore the variance in the expression of the genes themselves according to sample groups, or in other words, to quantify the contribution of the multiple sample variables in the gene expression variation. To determine which variables are the major drivers of expression variability, and importantly to define if the technical variability of RNA-seq data is low enough to study the condition of interest, we can implement an analysis of variance partition. variancePartition is a package that decomposes for each gene the expression variation into fractions of variance explained (FVE) by the sample variables in the experimental design of high-throughput genomics studies [1]. In order to exemplify how to implement this analysis and the type of conclusions that can be drawn from it, we’ll use bulk RNA-seq data from the smokingMouse package. ## Load the container package for this type of data library(&quot;SummarizedExperiment&quot;) ## Connect to ExperimentHub library(&quot;ExperimentHub&quot;) eh &lt;- ExperimentHub::ExperimentHub() ## Load the datasets of the package myfiles &lt;- query(eh, &quot;smokingMouse&quot;) ## Download the mouse gene data rse_gene &lt;- myfiles[[&quot;EH8313&quot;]] ## Keep samples from nicotine experiment and pups only rse_gene_nic &lt;- rse_gene[, which(rse_gene$Expt == &quot;Nicotine&quot; &amp; rse_gene$Age == &quot;Pup&quot;)] ## Use expressed genes only (i.e. that passed the filtering step) rse_gene_filt &lt;- rse_gene_nic[rowData(rse_gene_nic)$retained_after_feature_filtering == TRUE, ] ## Keep samples that passed QC and manual sample filtering steps (all passed) rse_gene_filt &lt;- rse_gene_filt[, rse_gene_filt$retained_after_QC_sample_filtering == TRUE &amp; rse_gene_filt$retained_after_manual_sample_filtering == TRUE] 8.1 Canonical Correlation Analysis Prior to the variance partition analysis, evaluating the correlation between sample variables is crucial because highly correlated variables can produce unstable estimates of the variance fractions and impede the identification of the variables that really contribute to the expression variation. There are at least two problems with correlated variables: If two variables are highly correlated we could incorrectly determine that one of them contributes to gene expression changes when it was actually not explanatory but just correlated with a real contributory variable. The part of variance explained by a biologically relevant variable can be reduced by the apparent contributions of correlated variables, if for example, they contain very similar information (i.e. are redundant variables). Additionally, the analysis is better performed with simpler models, specially when we have a limited number of samples in the study. Hence, to remove such variables we must first identify them. We will perform a Canonical Correlation Analysis (CCA) with canCorPairs() that assesses the degree to which the variables co-vary and contain the same information. With CCA, linear combinations that maximize the correlation between variable sets are estimated. CCA is just like a normal correlation analysis between 2 vectors but it can accommodate matrices as well (variable sets). Note that CCA returns correlations values between 0 and 1 [2]. library(&quot;variancePartition&quot;) library(&quot;pheatmap&quot;) ## Plot heatmap of correlations ## Define all variables to examine; remove those with single values formula &lt;- ~ Group + Sex + plate + flowcell + mitoRate + overallMapRate + totalAssignedGene + rRNA_rate + sum + detected + ERCCsumLogErr ## Measure correlations CCA &lt;- canCorPairs(formula, colData(rse_gene_filt)) ## Heatmap pheatmap( CCA, ## data color = hcl.colors(50, &quot;YlOrRd&quot;, rev = TRUE), ## color scale fontsize = 8, ## text size border_color = &quot;black&quot;, ## border color for heatmap cells cellwidth = unit(0.4, &quot;cm&quot;), ## height of cells cellheight = unit(0.4, &quot;cm&quot;) ## width of cells ) p.alert { background-color: #FFE4E1; padding: 14px; border: 0px solid black; margin-left: 0px; border-radius: 1px; font-family: sans-serif; } ⚠️ Very important: always inspect if there are any correlated variables with the one of interest in your study! This is extremely important as correlated variables could represent confounding factors and/or hinder the detection of significant DE events, thus yielding to misleading results. Importantly, Group is not highly correlated with any other variable in this study, but overallMapRate is correlated with rRNA_rate, library preparation plate, and the sequencing flowcell; sum (library size) and detected (number of expressed genes) are also correlated. For a detailed definition of these variables check here. Depending on your results there’s sometimes convenient to dig a little deeper into the relationship between correlated variables and to analyze these metrics among our control and experimental samples. Let’s work on that! library(&quot;ggplot2&quot;) library(&quot;cowplot&quot;) ## Boxplots/Scatterplots/Barplots for each pair of correlated variables corr_plots &lt;- function(sample_var1, sample_var2, sample_color) { ## Define sample colors by variable colors &lt;- list( &quot;Group&quot; = c(&quot;Control&quot; = &quot;brown2&quot;, &quot;Experimental&quot; = &quot;deepskyblue3&quot;), &quot;Sex&quot; = c(&quot;F&quot; = &quot;hotpink1&quot;, &quot;M&quot; = &quot;dodgerblue&quot;), &quot;plate&quot; = c(&quot;Plate1&quot; = &quot;darkorange&quot;, &quot;Plate2&quot; = &quot;lightskyblue&quot;, &quot;Plate3&quot; = &quot;deeppink1&quot;), &quot;flowcell&quot; = c( &quot;HKCG7DSXX&quot; = &quot;chartreuse2&quot;, &quot;HKCMHDSXX&quot; = &quot;magenta&quot;, &quot;HKCNKDSXX&quot; = &quot;turquoise3&quot;, &quot;HKCTMDSXX&quot; = &quot;tomato&quot; ) ) data &lt;- colData(rse_gene_filt) ## a) Barplots for categorical variable vs categorical variable if (class(data[, sample_var1]) == &quot;character&quot; &amp; class(data[, sample_var2]) == &quot;character&quot;) { ## y-axis label y_label &lt;- paste(&quot;Number of samples from each &quot;, sample_var2, sep = &quot;&quot;) ## Stacked barplot with counts for 2nd variable plot &lt;- ggplot(data = as.data.frame(data), aes( x = !!rlang::sym(sample_var1), fill = !!rlang::sym(sample_var2) )) + geom_bar(position = &quot;stack&quot;) + ## Colors by 2nd variable scale_fill_manual(values = colors[[sample_var2]]) + ## Show sample counts on stacked bars geom_text(aes(label = after_stat(count)), stat = &quot;count&quot;, position = position_stack(vjust = 0.5), colour = &quot;gray20&quot;, size = 3 ) + theme_bw() + labs( subtitle = paste0(&quot;Corr: &quot;, signif(CCA[sample_var1, sample_var2], digits = 3)), y = y_label ) + theme( axis.title = element_text(size = (7)), axis.text = element_text(size = (6)), plot.subtitle = element_text(size = 7, color = &quot;gray40&quot;), legend.text = element_text(size = 6), legend.title = element_text(size = 7) ) } ## b) Boxplots for categorical variable vs continuous variable else if (class(data[, sample_var1]) == &quot;character&quot; &amp; class(data[, sample_var2]) == &quot;numeric&quot;) { plot &lt;- ggplot(data = as.data.frame(data), mapping = aes( x = !!rlang::sym(sample_var1), y = !!rlang::sym(sample_var2), color = !!rlang::sym(sample_var1) )) + geom_boxplot(size = 0.25, width = 0.32, color = &quot;black&quot;, outlier.color = NA) + geom_jitter(width = 0.15, alpha = 1, size = 1.5) + stat_smooth(method = &quot;lm&quot;, geom = &quot;line&quot;, alpha = 0.6, size = 0.4, span = 0.3, aes(group = 1), color = &quot;orangered3&quot;) + scale_color_manual(values = colors[[sample_var1]]) + theme_bw() + guides(color = &quot;none&quot;) + labs( subtitle = paste0(&quot;Corr: &quot;, signif(CCA[sample_var1, sample_var2], digits = 3)), y = gsub(&quot;_&quot;, &quot; &quot;, sample_var2), x = sample_var1 ) + theme( axis.title = element_text(size = (7)), axis.text = element_text(size = (6)), plot.subtitle = element_text(size = 7, color = &quot;gray40&quot;), legend.text = element_text(size = 6), legend.title = element_text(size = 7) ) } ## c) Scatterplots for continuous variable vs continuous variable else if (class(data[, sample_var1]) == &quot;numeric&quot; &amp; class(data[, sample_var2]) == &quot;numeric&quot;) { plot &lt;- ggplot(as.data.frame(data), aes( x = !!rlang::sym(sample_var1), y = !!rlang::sym(sample_var2), color = !!rlang::sym(sample_color) )) + geom_point(size = 2) + stat_smooth(method = &quot;lm&quot;, geom = &quot;line&quot;, alpha = 0.6, size = 0.6, span = 0.25, color = &quot;orangered3&quot;) + ## Color by sample_color variable scale_color_manual(name = sample_color, values = colors[[sample_color]]) + theme_bw() + labs( subtitle = paste0(&quot;Corr: &quot;, signif(CCA[sample_var1, sample_var2], digits = 3)), y = gsub(&quot;_&quot;, &quot; &quot;, sample_var2), x = gsub(&quot;_&quot;, &quot; &quot;, sample_var1) ) + theme( axis.title = element_text(size = (7)), axis.text = element_text(size = (6)), plot.subtitle = element_text(size = 7, color = &quot;gray40&quot;), legend.text = element_text(size = 6), legend.title = element_text(size = 7) ) } return(plot) } As shown below, Group and plate are moderately correlated given that 14 of the 23 (60.8%) control samples and 11 of the 19 (57.9%) exposed samples were in the first and second plate for library preparation, respectively. ## Correlation plot for Group and plate p &lt;- corr_plots(&quot;Group&quot;, &quot;plate&quot;, NULL) p + theme(plot.margin = unit(c(1, 5.5, 1, 5.5), &quot;cm&quot;)) We can also observe that even though QC metrics such as overallMapRate and rRNA_rate are correlated, there’s no distinction between control and exposed samples for these variables. ## Correlation plot for overallMapRate and rRNA_rate p &lt;- corr_plots(&quot;overallMapRate&quot;, &quot;rRNA_rate&quot;, &quot;Group&quot;) p + theme(plot.margin = unit(c(2, 3.5, 2, 3.5), &quot;cm&quot;)) Moreover, the correlation between overallMapRate and the library preparation plate is mainly given by the plate 1 samples that have lower rates, similar to what occurs with the samples from the first flowcell. ## Correlation plot for overallMapRate and plate p &lt;- corr_plots(&quot;plate&quot;, &quot;overallMapRate&quot;, NULL) p + theme(plot.margin = unit(c(2, 5, 2, 5), &quot;cm&quot;)) ## Correlation plot for overallMapRate and flowcell p &lt;- corr_plots(&quot;flowcell&quot;, &quot;overallMapRate&quot;, NULL) p + theme(plot.margin = unit(c(2, 5, 2, 5), &quot;cm&quot;)) Interestingly, control samples seem to present more expressed genes than exposed samples for a given library size, however none of these variables is correlated with Group. ## Correlation plots for sum and detected p &lt;- corr_plots(&quot;sum&quot;, &quot;detected&quot;, &quot;Group&quot;) p + theme(plot.margin = unit(c(2, 3.5, 2, 3.5), &quot;cm&quot;)) ❓ Now look at the following plot. Why is it important that experimental and control samples are distributed throughout all sequencing flowcells? p &lt;- corr_plots(&quot;Group&quot;, &quot;flowcell&quot;, NULL) plots &lt;- plot_grid(p) plots + theme(plot.margin = unit(c(0.5, 5, 0.5, 5), &quot;cm&quot;)) Hint: What would happen if all experimental samples were in one flowcell and all controls in another? After identifying which variables are correlated and exploring the metrics of control and experimental samples the next is to determine which variable from each pair of correlated variables should be discarded and which one included in the models. How do we discern which ones to keep? As recommended in the variancePartition user’s guide [2], initially we can fit a linear model to the expression data of each gene taking all sample variables and then investigate which ones explain higher percentages of variance for many genes. But first let’s review how variancePartition works. 8.2 Fit model and extract fraction of variance explained Briefly, what variancePartition does is to fit a linear model for each gene separately and to compute the fraction of the total data variance explained by each variable of the study design, as well as by the residuals, using the calcVarPart() function. These computed fractions of variation explained (FVE) summarize the contribution of each variable and naturally sum to 1 [1]. variancePartition fits two types of models: Linear mixed model (LMM) where all categorical variables are modeled as random effects and all continuous variables are fixed effects. The function lmer() from lme4 is used to fit this model. ## Fit LMM specifying the existence of random effects with &#39;(1| )&#39; fit &lt;- lmer(expr ~ a + b + (1|c), data=data) Fixed effects model, which is basically the standard linear model (LM), where all variables are modeled as fixed effects. The function lm() is used to fit this model. ## Fit LM modeling all variables as fixed effects fit &lt;- lm(expr ~ a + b + c, data=data) In our case, the function will be modeled as a mixed model since we have both effects. p.question{ background-color: #E3E3E3; padding: 20px; border: 1px solid black; margin-left: 0px; border-radius: 1px; font-family: sans-serif; } ❓ What are random and fixed effects? Categorical variables are usually modeled as random effects, i.e., variables such as flowcell, plate, donor, etc. whose levels are “randomly chosen or selected from a larger population”. These levels are not of interest by themselves but the grouping of the samples by them. Random effects correspond to those variables whose effect on the expression of a gene varies according to its sample groups/levels. On the other hand, continuous variables can be modeled as fixed effects. These are sample-level variables that preserve their impact on the expression of a gene irrespective of the sample. ❓ Why is this effect distinction important? Because when we have clustered data, like gene expression values grouped by sample sex, batch, etc. we are violating the relevant assumption of independence, making an incorrect inference when using a general linear model (GLM). If we have clustered data where the variables’ values have distinct effects on gene expression, we must work with an extension of GLM, i.e. with the linear mixed model (LMM) that contains a mix of both fixed and random effects [3]. Linear mixed model fit 1️⃣ After fitting a linear model to the expression data of each gene we obtain the predicted expression of the genes given by the estimated coefficients of the variables: \\(\\hat y =\\sum_{1}^j\\beta_{j}X_{j} + \\sum_{1}^k\\alpha_{k}Z_{k}\\) ← the expression of a gene across all samples is given by the samples’ values in the \\(j\\) fixed effects and \\(k\\) random effects. Therefore, the gene expression in the sample \\(i\\) is given by \\(\\hat y_i =\\sum_{1}^j\\beta_{j}X_{ij} + \\sum_{1}^k\\alpha_{k}Z_{ik}\\). Then \\(y=\\hat y+\\epsilon\\), which means that the true (observed) expression value is given by the predicted value plus an error term (\\(\\epsilon\\)), also called noise or residual: \\[y =\\sum_{1}^j\\beta_{j}X_{j} + \\sum_{1}^k\\alpha_{k}Z_{k} + \\epsilon\\] \\(X_j\\) is the vector of the values of the samples in the \\(j\\)th fixed effect. \\(\\beta_j\\) is the predicted coefficient of the fixed effect \\(j\\). \\[ X_j\\beta_j= \\ \\ _{n \\ \\ samples}\\stackrel{j^{th}\\ \\ fixed\\ \\ effect }{\\begin{bmatrix} X_{1j} \\\\ ... \\\\ X_{(n-1)j} \\\\ X_{nj} \\end{bmatrix}}\\beta_j = {\\begin{bmatrix} X_{1j}\\beta_j \\\\ ... \\\\ X_{(n-1)j}\\beta_j \\\\ X_{nj} \\beta_j \\end{bmatrix}} \\] \\(Z_k\\) is the vector of values the samples have for the \\(k\\)th random effect. \\(\\alpha_k\\) is the predicted coefficient of the random effect \\(k\\). These are drawn from a normal distribution \\(∼N(0, \\sigma_{\\alpha_k}^2 )\\). \\[ Z_k\\alpha_k= \\ \\ _{n \\ \\ samples}\\stackrel{{k^{th}\\ \\ random\\ \\ effect }}{\\begin{bmatrix} Z_{1k} \\\\ ... \\\\ Z_{(n-1)k}\\\\ Z_{nk} \\end{bmatrix}}\\alpha_k = {\\begin{bmatrix} Z_{1k}\\alpha_k \\\\ ... \\\\ Z_{(n-1)k}\\alpha_k\\\\ Z_{nk}\\alpha_k \\end{bmatrix}} \\] \\(\\epsilon\\) is the noise term which is \\(y-\\hat y\\), the difference between the observed and predicted expression and is also drawn from \\(∼N(0, \\sigma_{\\epsilon}^2 )\\). Expanding, \\[ y= {\\begin{bmatrix} X_{11}\\beta_1 \\\\ ... \\\\ X_{(n-1)1}\\beta_1 \\\\ X_{n1} \\beta_1 \\end{bmatrix}} + {\\begin{bmatrix} X_{12}\\beta_2 \\\\ ... \\\\ X_{(n-1)2}\\beta_2 \\\\ X_{n2} \\beta_2 \\end{bmatrix}} + ... +{\\begin{bmatrix} X_{1j}\\beta_j \\\\ ... \\\\ X_{(n-1)j}\\beta_j \\\\ X_{nj} \\beta_j \\end{bmatrix}} + {\\begin{bmatrix} Z_{11}\\alpha_1 \\\\ ... \\\\ Z_{(n-1)1}\\alpha_1\\\\ Z_{n1}\\alpha_1 \\end{bmatrix}} +{\\begin{bmatrix} Z_{12}\\alpha_2 \\\\ ... \\\\ Z_{(n-1)2}\\alpha_2\\\\ Z_{n2}\\alpha_2 \\end{bmatrix}} \\] \\[ + ... + {\\begin{bmatrix} Z_{1k}\\alpha_k \\\\ ... \\\\ Z_{(n-1)k}\\alpha_k\\\\ Z_{nk}\\alpha_k \\end{bmatrix}} + {\\begin{bmatrix} \\epsilon_1 \\\\ ... \\\\ \\epsilon_{(n-1)} \\\\ \\epsilon_n \\end{bmatrix}} \\] All parameters are estimated with maximum likelihood, the default method in the variancePartition software when random effects are specified because it performs best in simulations. 2️⃣ Then, calcVarPart() computes for each fixed effect \\(\\sum_{i=1}^n(\\beta_{j}X_{ij}-\\bar{\\beta_{j}X_{j}})^2=var(\\beta_{j}X_{j})(n-1)\\), the squared sum of the predicted expression values of a gene in the \\(n\\) samples only taking into account the variable \\(j\\) in the regression model: \\(\\hat y = \\beta_{j}X_{j}\\). Each of these squared sums is scaled by additional factors but to simplify let’s just explain this analysis in terms of the variance (that is proportional to the squared sum): The variance explained by the \\(j\\)th fixed effect is: \\(\\sigma_{\\beta_j}^2=var(X_j{\\beta_j})\\) For random effects the variances are computed by variance component estimates with VarCorr() from nmle: The variance of the \\(k\\)th random effect is \\(\\sigma_{\\alpha_k}^2=var(Z_k{\\alpha_k})\\) The total variance of the expression values is calculated by \\(\\sum_{i=1}^n(y_i - \\bar { y})^2=var(y)(n-1)\\), where \\(y_i = \\sum_{1}^j\\beta_{j}X_{ij} + \\sum_{1}^k\\alpha_{k}Z_{ik} + \\epsilon_i\\) considering all variables in the model and the error: The total variance is: \\(var(y)= \\sigma_{Total}^2= var(X_{1}\\beta_1)+var(X_{2}\\beta_2)+...+var(X_{j}\\beta_j)+var(Z_{1}\\alpha_1)+var(Z_{2}\\alpha_2)+...+var(Z_{k}\\alpha_k)+var(\\epsilon)=\\) \\(\\sum_1^jvar(X_j\\beta_j)+\\sum_1^kvar(Z_k\\alpha_k)+var(\\epsilon)=\\) \\(\\sigma_{Total}^2=\\sum_1^j{ \\sigma_{\\beta_j}^2} + \\sum_1^k{ \\sigma_{\\alpha_k}^2} + \\sigma_{\\epsilon}^2\\) 3️⃣ Finally, it computes: The fraction of the total data variance explained by the \\(j\\)th fixed effect is \\(\\sigma_{\\beta_j}^2\\) / \\(\\sigma_{Total}^2\\) The fraction of the total data variance explained by the \\(k\\)th random effect is \\(\\sigma_{\\alpha_k}^2\\) / \\(\\sigma_{Total}^2\\) Note that \\(y=\\hat y+\\epsilon\\) because the expression can’t be completely described by a straight line, so not all the variation of \\(y\\) can be explained by the variation of the sample variables, instead \\(var(y)=var(\\hat y)+var(\\epsilon)=var(\\hat y) + \\sigma_{\\epsilon}^2\\), where \\(\\sigma_{\\epsilon}^2=\\sum_{i=1}^n(\\hat y_i -y_i)^2/n-1\\). The residual variance is \\(\\sigma_{\\epsilon}^2\\) / \\(\\sigma_{Total}^2\\) ; this is the variance that the model (with the included covariates) couldn’t explain. p.link{ background-color: #FFFFFF; padding: 10px; border: 0px solid black; margin-left: 0px; border-radius: 1px; font-size: 13px; font-family: sans-serif; } 👉🏼 Source code of calcVarPart() here. Once we have reviewed what variancePartition computes and how, we can use it to quantify the FVE for each variable. ## Fit a linear mixed model (LMM) that takes continuous variables as fixed effects and categorical variables as random effects varPartAnalysis &lt;- function(formula) { ## Ignore genes with variance 0 genes_var_zero &lt;- which(apply(assays(rse_gene_filt)$logcounts, 1, var) == 0) if (length(genes_var_zero) &gt; 0) { rse_gene_filt &lt;- rse_gene_filt[-genes_var_zero, ] } ## Loop over each gene to fit the model and extract variance explained by each variable varPart &lt;- fitExtractVarPartModel(assays(rse_gene_filt)$logcounts, formula, colData(rse_gene_filt)) # Sort variables by median fraction of variance explained (FVE) vp &lt;- sortCols(varPart) p &lt;- plotVarPart(vp) return(list(p, vp)) } In the following violin plots, we have the % of variance explained in the expression of each gene by each covariate, based on the model with all variables. Of our pairs of correlated variables, rRNA_rate has the highest median FVE and thus, should be included in the models for DGE, whereas variables correlated with it (overallMapRate) must be removed. Furthermore, library preparation plate must be excluded as it is correlated with Group. ##### Fit model with all variables ##### # sum, detected, and ERCCsumLogErr are not included as they are in very different scales! formula &lt;- ~ (1 | Group) + (1 | Sex) + (1 | plate) + (1 | flowcell) + mitoRate + overallMapRate + totalAssignedGene + rRNA_rate plot &lt;- varPartAnalysis(formula)[[1]] plot + theme( plot.margin = unit(c(1, 1, 1, 1), &quot;cm&quot;), axis.text.x = element_text(size = (7)), axis.text.y = element_text(size = (7.5)) ) ⚠️ Note that some variables such as the library size and the number of detected genes that are in different orders of magnitude to the rest of the QC metrics and categorical variables are not included in this analysis as they can impact the model predictions and the interpretability of the regression results [4]. These variables can be analyzed only after rescaling. After re-running the analysis without the previous correlated variables, now Group contribution increases but so does the residual source, i.e., the % of gene expression variance that the model couldn’t explain increases, although the increase is rather low. This occurs because when we remove independent variables to a regression equation, we can explain less of the variance of the dependent variable [3]. That’s the price to pay when dropping variables, but it is convenient when we don’t have many samples for the model to determine variable unique contributions. ##### Fit model without correlated variables ##### ## Pup plots without overallMapRate and plate formula &lt;- ~ (1 | Group) + (1 | Sex) + (1 | flowcell) + mitoRate + overallMapRate + totalAssignedGene varPart &lt;- varPartAnalysis(formula) varPart_data &lt;- varPart[[2]] plot &lt;- varPart[[1]] plot + theme( plot.margin = unit(c(1, 1, 1, 1), &quot;cm&quot;), axis.text.x = element_text(size = (7)), axis.text.y = element_text(size = (7.5)) ) But what does it mean that a variable explains a high percentage of the expression variation of a gene? In the following section will visualize the existing relationships between the gene expression values in the samples and the sample-level variables. 8.3 Examine the expression of most affected genes by each sample variable In the plots presented below we can appreciate the expression levels across samples of the most affected genes by each variable, i.e., the genes for which the variable explains the highest percentages of variance, plotted against the sample values for the same variable. Observe the strong correlations that exist for the sample variables and the gene expression of such affected genes, which ends up causing these variables to explain high percentages of gene expression variation and which obligate us to adjust for them in the models. library(&quot;rlang&quot;) ## Plot of gene expression lognorm counts vs. sample variable plot_gene_expr &lt;- function(sample_var, gene_id) { colors &lt;- list( &quot;Group&quot; = c(&quot;Control&quot; = &quot;brown2&quot;, &quot;Experimental&quot; = &quot;deepskyblue3&quot;), &quot;Age&quot; = c(&quot;Adult&quot; = &quot;slateblue3&quot;, &quot;Pup&quot; = &quot;yellow3&quot;), &quot;Sex&quot; = c(&quot;F&quot; = &quot;hotpink1&quot;, &quot;M&quot; = &quot;dodgerblue&quot;), &quot;Pregnancy&quot; = c(&quot;Yes&quot; = &quot;darkorchid3&quot;, &quot;No&quot; = &quot;darkolivegreen4&quot;), &quot;plate&quot; = c(&quot;Plate1&quot; = &quot;darkorange&quot;, &quot;Plate2&quot; = &quot;lightskyblue&quot;, &quot;Plate3&quot; = &quot;deeppink1&quot;), &quot;flowcell&quot; = c( &quot;HKCG7DSXX&quot; = &quot;chartreuse2&quot;, &quot;HKCMHDSXX&quot; = &quot;magenta&quot;, &quot;HKCNKDSXX&quot; = &quot;turquoise3&quot;, &quot;HKCTMDSXX&quot; = &quot;tomato&quot; ) ) ## Lognorm counts of the gene across samples data &lt;- colData(rse_gene_filt) data$gene_expr &lt;- assays(rse_gene_filt)$logcounts[gene_id, ] ## Percentage of variance explained by the variable percentage &lt;- 100 * signif(varPart_data[gene_id, sample_var], digits = 3) ## Boxplots for categorical variables if (class(data[, sample_var]) == &quot;character&quot;) { plot &lt;- ggplot(data = as.data.frame(data), mapping = aes( x = !!rlang::sym(sample_var), y = gene_expr, color = !!rlang::sym(sample_var) )) + geom_boxplot(size = 0.25, width = 0.32, color = &quot;black&quot;, outlier.color = &quot;#FFFFFFFF&quot;) + geom_jitter(width = 0.15, alpha = 1, size = 1) + stat_smooth(geom = &quot;line&quot;, alpha = 0.6, size = 0.4, span = 0.3, method = &quot;lm&quot;, aes(group = 1), color = &quot;orangered3&quot;) + scale_color_manual(values = colors[[sample_var]]) + theme_bw() + guides(color = &quot;none&quot;) + labs( title = gene_id, subtitle = paste0(&quot;Variance explained: &quot;, percentage, &quot;%&quot;), y = &quot;lognorm counts&quot;, x = sample_var ) + theme( axis.title = element_text(size = (7)), axis.text = element_text(size = (6)), plot.title = element_text(hjust = 0.5, size = 7.5, face = &quot;bold&quot;), plot.subtitle = element_text(size = 7, color = &quot;gray40&quot;), legend.text = element_text(size = 6), legend.title = element_text(size = 7) ) } ## Scatterplots for continuous variables else { colors &lt;- c( &quot;mitoRate&quot; = &quot;khaki3&quot;, &quot;overallMapRate&quot; = &quot;turquoise&quot;, &quot;totalAssignedGene&quot; = &quot;plum2&quot;, &quot;rRNA_rate&quot; = &quot;orange3&quot;, &quot;sum&quot; = &quot;palegreen3&quot;, &quot;detected&quot; = &quot;skyblue2&quot;, &quot;ERCCsumLogErr&quot; = &quot;slateblue1&quot; ) plot &lt;- ggplot(as.data.frame(data), aes(x = eval(parse_expr(sample_var)), y = gene_expr)) + geom_point(color = colors[[sample_var]], size = 2) + stat_smooth(geom = &quot;line&quot;, alpha = 0.4, size = 0.4, span = 0.25, method = &quot;lm&quot;, color = &quot;orangered3&quot;) + theme_bw() + guides(color = &quot;none&quot;) + labs( title = gene_id, subtitle = paste0(&quot;Variance explained: &quot;, percentage, &quot;%&quot;), y = &quot;lognorm counts&quot;, x = gsub(&quot;_&quot;, &quot; &quot;, sample_var) ) + theme( plot.margin = unit(c(0.4, 0.1, 0.4, 0.1), &quot;cm&quot;), axis.title = element_text(size = (7)), axis.text = element_text(size = (6)), plot.title = element_text(hjust = 0.5, size = 7.5, face = &quot;bold&quot;), plot.subtitle = element_text(size = 7, color = &quot;gray40&quot;), legend.text = element_text(size = 6), legend.title = element_text(size = 7) ) } return(plot) } ## Function to plot gene expression vs sample variable data for top 3 most affected genes plot_gene_expr_sample &lt;- function(sample_var) { ## Top 3 genes most affected by sample variable affected_genes &lt;- rownames(varPart_data[order(varPart_data[, sample_var], decreasing = TRUE), ][1:3, ]) ## Plots plots &lt;- list() for (i in 1:length(affected_genes)) { plots[[i]] &lt;- plot_gene_expr(sample_var, affected_genes[i]) } plot_grid(plots[[1]], plots[[2]], plots[[3]], ncol = 3) } ## Plots for top affected genes by &#39;overallMapRate&#39; plots &lt;- plot_gene_expr_sample(&quot;overallMapRate&quot;) plots + theme(plot.margin = unit(c(3, 1, 2, 3), &quot;cm&quot;)) ## Plots for top affected genes by &#39;totalAssignedGene&#39; plots &lt;- plot_gene_expr_sample(&quot;totalAssignedGene&quot;) plots + theme(plot.margin = unit(c(3, 1, 2, 3), &quot;cm&quot;)) ## Plots for top affected genes by &#39;Group&#39; plots &lt;- plot_gene_expr_sample(&quot;Group&quot;) plots + theme(plot.margin = unit(c(3, 1, 2, 3), &quot;cm&quot;)) ## Plots for top affected genes by &#39;Sex&#39; (genes in sexual chrs) plots &lt;- plot_gene_expr_sample(&quot;Sex&quot;) plots + theme(plot.margin = unit(c(3, 1, 2, 3), &quot;cm&quot;)) p.exercise { background-color: #FFFAFA; padding: 15px; border: 2px solid black; margin-left: 0px; border-radius: 1px; font-family: sans-serif; } 📝 Exercise 1: What % of variance does Group explain for the gene ENSMUSG00000042348.10? Create the boxplots for its counts in control and experimental samples. Is it more likely that the gene is up-regulated or down-regulated? 📝 Exercise 2: Do the same for the gene ENSMUSG00000064372.1. What do you observe in terms of variance percentage and sample differences? References Hoffman, G. E., &amp; Schadt, E. E. (2016). variancePartition: interpreting drivers of variation in complex gene expression studies.BMC bioinformatics, 17(1), 1-13. Hoffman, G. (2022). variancePartition: Quantifying and interpreting drivers of variation in multilevel gene expression experiments. van den Berg, S. M. (2022). Analysing data using linear models. Web site: https://bookdown.org/pingapang9/linear_models_bookdown/ Simoiu, C. &amp; Savage, J. (2016). A bag of tips and tricks for dealing with scale issues. Web site: https://rpubs.com/jimsavage/scale_issues "],["differential-gene-expression-exercise.html", "9 Differential gene expression exercise 9.1 Recap 9.2 Exercise", " 9 Differential gene expression exercise Instructor: Leo 9.1 Recap So far we know how to: choose a study from recount3 download data for a study with recount3::create_rse() explore the data interactively with iSEE expand Sequence Read Archive (SRA) attributes sometimes we need to clean them up a bit before we can use them use edgeR::calcNormFactors() to reduce composition bias build a differential gene expression model with model.matrix() explore and interpret the model with ExploreModelMatrix use limma::voom() and related functions to compute the differential gene expression statistics extract the DEG statistics with limma::topTable(sort.by = \"none\") use some limma functions for making MA or volcano plots among several other plots and tools we learned along the way. Alternatively to recount3, we have learned about the RangedSummarizedExperiment objects produced by SPEAQeasy and in particular the one we are using on the smokingMouse project. You might have your own data already. Maybe you have it as an AnnData python object. If so, you can convert it to R with zellkonverter. 9.2 Exercise p.exercise { background-color: #E4EDE2; padding: 9px; border: 1px solid black; border-radius: 10px; font-family: sans-serif; } Exercise option 1: This will be an open ended exercise. Think of it as time to practice what we’ve learnt using data from recount3 or another subset of the smokingMouse dataset. You could also choose to re-run code from earlier parts of the course and ask clarifying questions. You could also use this time to adapt some of the code we’ve covered to use it with your own dataset. If you prefer a more structured exercise: Exercise option 2: Choose two recount3 studies that can be used to study similar research questions. For example, two studies with brain samples across age. Download and process each dataset independently, up to the point where you have differential expression t-statistics for both. Skip most of the exploratory data analyses steps as for the purpose of this exercise, we are most interested in the DEG t-statistics. If you don’t want to choose another recount3 study, you could use the smokingMouse data and subset it once to the pups in nicotine arm of the study and a second time for the pups in the smoking arm of the study. Or you could use the GTEx brain data from recount3, subset it to the prefrontal cortex (PFC), and compute age related expression changes. That would be in addition to SRA study SRP045638 that we used previously. recount3::create_rse_manual( project = &quot;BRAIN&quot;, project_home = &quot;data_sources/gtex&quot;, organism = &quot;human&quot;, annotation = &quot;gencode_v26&quot;, type = &quot;gene&quot; ) Make a scatterplot of the t-statistics between the two datasets to assess correlation / concordance. You might want to use GGally::ggpairs() for this https://ggobi.github.io/ggally/reference/ggpairs.html. Or ggpubr::ggscatter() https://rpkgs.datanovia.com/ggpubr/reference/ggscatter.html. For example, between the GTEx PFC data and the data we used previously from SRA study SRP045638. Or between the nicotine-exposed pups and the smoking-exposed pups in smokingMouse. Or using the two recount3 studies you chose. Are there any DEGs FDR &lt; 5% in both datasets? Or FDR &lt; 5% in dataset 1 that have a p-value &lt; 5% in the other one? You could choose to make a concordance at the top plot like at http://leekgroup.github.io/recount-analyses/example_de/recount_SRP019936.html, though you will likely need more time to complete this. "],["expression-heatmaps-with-complexheatmap.html", "10 Expression heatmaps with ComplexHeatmap 10.1 Introduction 10.2 ComplexHeatmap 10.3 Heatmap with expression data", " 10 Expression heatmaps with ComplexHeatmap Instructor: Renee Congrats to @rodriguez_lion - final chapter of his PhD thesis - as well as co-1st author @mattntran, and @SubmarineGene who joined the project late, but was invaluable to getting it finished, and much thanks to @CerceoPage @lcolladotor for co-supervising! — Keri Martinowich (@martinowk) July 3, 2023 10.1 Introduction Heatmaps are efficient to visualize associations between different sources of data sets and reveal potential patterns (e.g. patterns of expression in your genes). There are multiple packages in R that allow you to create heatmaps, the most widely use include: ggplot2 heatmaps pheatmap ComplexHeatmap All of these are good and useful, but adding extra information to your heatmaps can get really messy depending on the package you are using. For example, in the next heatmap we are showing the expression of marker genes in multiple cell types. The columns are separated by the group from which they are markers. Then the rows (cell types), have two different classifications: group and Population, plus a barplot that shows the number of nuclei that cell type contains. 10.2 ComplexHeatmap The ComplexHeatmap package provides a highly flexible way to arrange multiple heatmaps and supports self-defined annotation graphics.The ComplexHeatmap package is implemented in an object-oriented way. To describe a heatmap list, there are following classes: Heatmap class: a single heatmap containing heatmap body, row/column names, titles, dendrograms and row/column annotations. HeatmapAnnotation class: defines a list of row annotations and column annotations. The heatmap annotations can be components of heatmap, also they can be independent as heatmaps. p.exercise { background-color: #E4EDE2; padding: 9px; border: 1px solid black; border-radius: 10px; font-family: sans-serif; } Exercise 1: Explore the Bioconductor page for this package, go to the vignette and find a function that would allow you to add the barplot on the right side of the heatmap previously shown. 10.3 Heatmap with expression data Now, we are gonna make our own heatmap with the SmokingMouse data. In this heatmap we want to see the difference of expression between both Control and Experimental for all the DEG in Pup, as well as the Sex of the samples and the FDR of the genes. Let’s download and prepare our data first. 10.3.1 Download data library(&quot;SummarizedExperiment&quot;) library(&quot;ComplexHeatmap&quot;) library(&quot;circlize&quot;) ## Download and cache the file library(&quot;BiocFileCache&quot;) bfc &lt;- BiocFileCache::BiocFileCache() cached_rse_gene &lt;- BiocFileCache::bfcrpath( x = bfc, &quot;https://github.com/LieberInstitute/SPEAQeasyWorkshop2023/raw/devel/provisional_data/rse_gene_mouse_RNAseq_nic-smo.Rdata&quot; ) #&gt; adding rname &#39;https://github.com/LieberInstitute/SPEAQeasyWorkshop2023/raw/devel/provisional_data/rse_gene_mouse_RNAseq_nic-smo.Rdata&#39; ## Check the local path on our cache cached_rse_gene #&gt; BFC1 #&gt; &quot;/github/home/.cache/R/BiocFileCache/46e5fb33621_rse_gene_mouse_RNAseq_nic-smo.Rdata&quot; ## Load the rse_gene object load(cached_rse_gene, verbose = TRUE) #&gt; Loading objects: #&gt; rse_gene ## General overview of the object rse_gene #&gt; class: RangedSummarizedExperiment #&gt; dim: 55401 208 #&gt; metadata(1): Obtained_from #&gt; assays(2): counts logcounts #&gt; rownames(55401): ENSMUSG00000102693.1 ENSMUSG00000064842.1 ... ENSMUSG00000064371.1 ENSMUSG00000064372.1 #&gt; rowData names(13): Length gencodeID ... DE_in_pup_brain_nicotine DE_in_pup_brain_smoking #&gt; colnames: NULL #&gt; colData names(71): SAMPLE_ID FQCbasicStats ... retained_after_QC_sample_filtering #&gt; retained_after_manual_sample_filtering 10.3.2 Prepare the data ## Extract genes and samples of interest rse_gene_pup_nic &lt;- rse_gene[ rowData(rse_gene)$DE_in_pup_brain_nicotine == TRUE, rse_gene$Age == &quot;Pup&quot; &amp; rse_gene$Expt == &quot;Nicotine&quot; ] ## Extract logcounts and add name columns logs_pup_nic &lt;- assay(rse_gene_pup_nic, 2) colnames(logs_pup_nic) &lt;- paste0(&quot;Pup_&quot;, 1:dim(rse_gene_pup_nic)[2]) ## Create function to remove technical variables&#39; contributions, ## this is from jaffelab package (https://github.com/LieberInstitute/jaffelab) cleaningY &lt;- function(y, mod, P) { stopifnot(P &lt;= ncol(mod)) stopifnot(`Input matrix is not full rank` = qr(mod)$rank == ncol(mod)) Hat &lt;- solve(t(mod) %*% mod) %*% t(mod) ty &lt;- t(y) ty[is.na(ty)] &lt;- 0 beta &lt;- (Hat %*% ty) cleany &lt;- y - t(as.matrix(mod[, -c(seq_len(P))]) %*% beta[-seq_len(P), ]) return(cleany) } ## Remove contribution of technical variables formula &lt;- ~ Group + Sex + plate + flowcell + rRNA_rate + totalAssignedGene + ERCCsumLogErr + overallMapRate + mitoRate model &lt;- model.matrix(formula, data = colData(rse_gene_pup_nic)) logs_pup_nic &lt;- cleaningY(logs_pup_nic, model, P = 2) ## Center the data to make differences more evident logs_pup_nic &lt;- (logs_pup_nic - rowMeans(logs_pup_nic)) / rowSds(logs_pup_nic) More for on centering and scaling, see this video: 10.3.3 Create annotations ## Prepare annotation for our heatmap ## For this heatmap I want to be able to see the Group to which each sample belongs ## as well as the Sex of the pup top_ans &lt;- HeatmapAnnotation( df = as.data.frame(colData(rse_gene_pup_nic)[, c(&quot;Sex&quot;, &quot;Group&quot;)]), col = list( &quot;Sex&quot; = c(&quot;F&quot; = &quot;hotpink1&quot;, &quot;M&quot; = &quot;dodgerblue&quot;), &quot;Group&quot; = c(&quot;Control&quot; = &quot;brown2&quot;, &quot;Experimental&quot; = &quot;deepskyblue3&quot;) ) ) ## Also, I want to add the FDR associated to each gene ## Even though we do have that data, for this particular exercise we are gonna simulate it rowData(rse_gene_pup_nic)$FDR &lt;- sample( x = 0:5000, size = dim(rse_gene_pup_nic)[1], prob = c(rep(0.0012, 1001), rep(0.00005, 4000)) ) / 10000 left_ans &lt;- rowAnnotation( FDR = rowData(rse_gene_pup_nic)$FDR, col = list(FDR = colorRamp2(c(0, 0.049), c(&quot;#ecf39e&quot;, &quot;#4f772d&quot;))), annotation_legend_param = list(FDR = list(at = c(0, 0.01, 0.02, 0.03, 0.04, 0.05))) ) 10.3.4 Plot our heatmap ## Finally, let&#39;s plot! Heatmap(logs_pup_nic, name = &quot;logcounts&quot;, show_row_names = FALSE, top_annotation = top_ans, left_annotation = left_ans, row_km = 2, column_km = 2, col = colorRamp2(c(-4, -0.0001, 00001, 4), c(&quot;darkblue&quot;, &quot;lightblue&quot;, &quot;lightsalmon&quot;, &quot;darkred&quot;)), row_title = NULL, column_title = NULL, column_names_gp = gpar(fontsize = 7) ) Exercise 2: a) Add a barplot as a topAnnotation with the library sizes (sum) of each sample. Fill the bars with the color of your choice b) Classify the genes according to whether they are proteing_coding or not (not_proteing_coding). "],["complexheatmap-exercise-solution.html", "11 ComplexHeatmap exercise solution", " 11 ComplexHeatmap exercise solution ## For a) we need to use he function anno_barplot() to generate the barplot and gpar() to fill the bars top_ans &lt;- HeatmapAnnotation( df = as.data.frame(colData(rse_gene_pup_nic)[, c(&quot;Sex&quot;, &quot;Group&quot;)]), library_size = anno_barplot(colData(rse_gene_pup_nic)$sum, gp = gpar(fill = &quot;#ffd500&quot;)), col = list( &quot;Sex&quot; = c(&quot;F&quot; = &quot;hotpink1&quot;, &quot;M&quot; = &quot;dodgerblue&quot;), &quot;Group&quot; = c(&quot;Control&quot; = &quot;brown2&quot;, &quot;Experimental&quot; = &quot;deepskyblue3&quot;) ) ) ## For b), I want to know if a gene is protein_coding or not_protein_coding. ## First, we can explore the rowData of our object to see if we have a column with ## that information names(rowData(rse_gene_pup_nic)) #&gt; [1] &quot;Length&quot; &quot;gencodeID&quot; &quot;ensemblID&quot; #&gt; [4] &quot;gene_type&quot; &quot;EntrezID&quot; &quot;Symbol&quot; #&gt; [7] &quot;meanExprs&quot; &quot;retained_after_feature_filtering&quot; &quot;DE_in_adult_blood_smoking&quot; #&gt; [10] &quot;DE_in_adult_brain_nicotine&quot; &quot;DE_in_adult_brain_smoking&quot; &quot;DE_in_pup_brain_nicotine&quot; #&gt; [13] &quot;DE_in_pup_brain_smoking&quot; &quot;FDR&quot; ## Maybe gene_type has what we need unique(rowData(rse_gene_pup_nic)$gene_type) #&gt; [1] &quot;sense_intronic&quot; &quot;protein_coding&quot; &quot;antisense&quot; #&gt; [4] &quot;processed_transcript&quot; &quot;unprocessed_pseudogene&quot; &quot;processed_pseudogene&quot; #&gt; [7] &quot;TEC&quot; &quot;transcribed_processed_pseudogene&quot; &quot;lincRNA&quot; #&gt; [10] &quot;transcribed_unitary_pseudogene&quot; &quot;snoRNA&quot; &quot;polymorphic_pseudogene&quot; #&gt; [13] &quot;transcribed_unprocessed_pseudogene&quot; &quot;bidirectional_promoter_lncRNA&quot; ## It does but not in the format we need it, so we need to create a new column to complete the task ## This columns is going to have protein_coding and not_protein_coding as elements rowData(rse_gene_pup_nic)$pc_status &lt;- &quot;protein_coding&quot; rowData(rse_gene_pup_nic)$pc_status[rowData(rse_gene_pup_nic)$gene_type != &quot;protein_coding&quot;] &lt;- &quot;not_protein_coding&quot; ## Now we can add the information and specify the color left_ans &lt;- rowAnnotation( FDR = sample(x = 0:5000, size = dim(rse_gene_pup_nic)[1], prob = c(rep(0.0012, 1001), rep(0.00005, 4000))) / 10000, pc_status = rowData(rse_gene_pup_nic)$pc_status, col = list(FDR = colorRamp2(c(0, 0.049), c(&quot;#ecf39e&quot;, &quot;#4f772d&quot;)), pc_status = c(&quot;not_protein_coding&quot; = &quot;#ffe5d9&quot;, &quot;protein_coding&quot; = &quot;#9d8189&quot;)), annotation_legend_param = list(FDR = list(at = c(0, 0.01, 0.02, 0.03, 0.04, 0.05))) ) Heatmap(logs_pup_nic, name = &quot; &quot;, show_row_names = FALSE, top_annotation = top_ans, left_annotation = left_ans, row_km = 2, column_km = 2, col = colorRamp2(c(-4, -0.0001, 00001, 4), c(&quot;darkblue&quot;, &quot;lightblue&quot;, &quot;lightsalmon&quot;, &quot;darkred&quot;)), row_title = NULL, column_title = NULL, column_names_gp = gpar(fontsize = 7) ) "],["research-talks.html", "12 Research talks 12.1 Fentanyl rat study 12.2 Cg Hb cell projectors study 12.3 deconvolution-benchmark", " 12 Research talks 12.1 Fentanyl rat study Daianna 12.2 Cg Hb cell projectors study Melissa 12.3 deconvolution-benchmark Leonardo "],["biocthis-introduction.html", "13 biocthis introduction 13.1 Related past materials 13.2 biocthis main commands 13.3 Live demo 13.4 Community", " 13 biocthis introduction Instructor: Leo 13.1 Related past materials I’ve taught a lot about biocthis over the years. Here’s a 2020 video: and more recently, these are the LIBD rstats club 2023-03-10 notes. 1 13.2 biocthis main commands https://bioconductor.org/packages/biocthis pkgdown documentation website: https://lcolladotor.github.io/biocthis/ biocthis::use_bioc_pkg_templates() documentation: https://lcolladotor.github.io/biocthis/reference/use_bioc_pkg_templates.html These are the main steps you will need to know to make a Bioconductor package with biocthis: You first will need to create a package using a command from usethis. For example: usethis::create_package(\"~/Desktop/cshl2023pkg\") Now that you have a package, we can use biocthis to create 4 template R scripts that will guide you and help you make the full structure for a Bioconductor R package. On your new R package (cshl2023pkg), we can now use biocthis::use_bioc_pkg_templates(). In part these commands were born out of my own self interest to make it easier to make new packages instead of copy-pasting the contents of an older one, then manually adjusting all the pieces for a new package. See https://lcolladotor.github.io/pkgs/ for the list of all the R packages I’ve been involved in. 13.3 Live demo Here is the live demo result https://github.com/lcolladotor/cshl2023pkg/ with its companion documentation website at https://lcolladotor.github.io/cshl2023pkg/. Note that you will currently need the development version of biocthis which addresses the issues documented at https://github.com/r-lib/usethis/issues/1856. ## Install biocthis development version BiocManager::install(&quot;lcolladotor/biocthis&quot;) Check the git commit history at https://github.com/lcolladotor/cshl2023pkg/commits/devel and the GitHub Actions history at https://github.com/lcolladotor/cshl2023pkg/actions. We can see at https://app.codecov.io/gh/lcolladotor/cshl2023pkg the code coverage results for this demonstration package. 13.4 Community For more materials on R/Bioconductor package development check http://contributions.bioconductor.org/. I’m on a Friday night mood now enjoying @lmwebr’s #OSTA workshop 🔥, feeling grateful 🙏🏽 to everyone who nominated me for the #BioC2021 community award 🥇&amp; celebrating 🍺 https://t.co/2oFLdGO3UhSee you in #BioC2022🤞🏽 @Bioconductor #rstats @CDSBMexico https://t.co/0SGHDfiRCs pic.twitter.com/UmM9nMP2W2 — 🇲🇽 Leonardo Collado-Torres (@lcolladotor) August 7, 2021 biocthis is one of the reasons for my 2021 Bioconductor community award :-) Do you want to play an active role? Join the cloud-working-group Slack channel. Soon I’ll process and upload the video to YouTube. By soon, I mean, later this summer.↩︎ "],["scrna-seq-data-analysis-overview.html", "14 scRNA-seq data analysis overview 14.1 Single cell RNA sequencing overview 14.2 The SingleCellExperiment class 14.3 Quality Control 14.4 Normalization 14.5 Feature selection 14.6 Dimensionality reduction 14.7 Clustering 14.8 Marker gene detection 14.9 Cell type annotation", " 14 scRNA-seq data analysis overview 14.1 Single cell RNA sequencing overview 14.2 The SingleCellExperiment class *** Agregar library(“scRNAseq”) !!! BiocManager::install(“OSCA.intro”) !!! *** 14.3 Quality Control 14.4 Normalization 14.5 Feature selection 14.6 Dimensionality reduction 14.7 Clustering 14.8 Marker gene detection 14.9 Cell type annotation "],["introduction-to-spatial-transcriptomics.html", "15 Introduction to spatial transcriptomics 15.1 3’ Visium spatial technology 15.2 Spatial data visualization Bibliography", " 15 Introduction to spatial transcriptomics In recent years, with constant improvements in the current sequencing technologies and the generation of more sophisticated omics methodologies and bioinformatic pipelines, we have been constantly demonstrating that specific cell types and cell-to-cell interactions play critical roles in the definition of numerous diseases and development-related processes. In fact, cell type-specific associations have been established for a number of diseases and disorders. Thus, understanding the cellular context and the spatial location in which normal and deregulated cellular events occur is necessary to unveil the molecular underpinnings of disease pathologies and malfunctions of the organisms. Spatial transcriptomics technologies are molecular profiling methods developed to measure gene expression levels in a tissue sample at the spatial resolution. These methods have been improved and expanded over time and are widely applied to study a wide range of biological processes and have provided numerous insights into disease and development mechanisms. In particular, the 10x Genomics Visium platform is a technology that spatially profiles the transcriptome of frozen and fixed tissue sections in combination with histology. 15.1 3’ Visium spatial technology This is the Visium technology more frequently used and it captures polyadenilated transcripts within individual spatially barcoded spots. In the Visium expression slide there are 4 capture areas, each of 6.5 (+1.5) mm\\(^2\\) with ~5k barcoded spots (55 µm in diameter each), within which mRNAs are captured by polyT primers that contain a read for sequencing (see below), a UMI, and a spatial barcode. In this way, all RNAs trapped in the same spot are tagged with the same spot-specific barcode and we can computationally trace the original location of the transcripts. Figure 1: Schematic representation of the Visium capture areas and spots. Source: SciLifeLab (2023). 15.2 Spatial data visualization In order to interactively visualize example spatial data we’ll use the shiny web application of spatialLIBD: http://spatial.libd.org/spatialLIBD/. This web application allows to browse the human dorsolateral pre-frontal cortex (DLPFC) spatial transcriptomics data generated at the LIBD using the 10x Genomics Visium platform. In total there are 12 DLPFC tissue sections from 3 donors, each spanning six classical histological layers plus the white matter (WM). Figure 2: Human DLPFC tissue section. Spot plot depicting the 6 classical histological layers (L1-L6) and the white matter (WM) in a human DLPFC sample. 15.2.1 Spot-level data exploration With this tool you can: Observe per-spot QC metrics and gene expression levels Explore spot clusters in the tissue sections Visualize the spot data on reduced dimensions Manually annotate spots to layers and export your manual annotations Customize the spatial images p.exercise { background-color: #FFFAFA; padding: 15px; border: 2px solid black; margin-left: 0px; border-radius: 1px; font-family: sans-serif; } 📝 Exercise 1: visualize the clustering of spots in all tissue sections using the different discrete variables to plot. Which one recapitulates better the six histological layers (plus the white matter) of the human DLPFC? 📝 Exercise 2: explore the expression of SNAP25 (neuronal marker gene), MOBP (oligodendrocyte/WM marker gene), and PCP4 (layer 5 marker gene) in each DLPFC tissue section. What do you observe? Are there any spatial patterns in the expression of these genes? 15.2.2 Layer-level data exploration Layer-level data result from pseudo-bulking the spot-level data, i.e. from aggregating spot data from all spots assigned to a given layer. At this level the tool allows to: Visualize the gene expression data at the layer level in reduced dimensions Plot the layer-level lognorm or raw expression of a gene across all tissue sections and extract DEGs among layers (ANOVA model), in a specific layer compared to the rest (enrichment model) or compared to another layer (pairwise model) Assess the enrichment of your own sets of genes of interest among the DEGs from these spatial DLPFC data Correlate gene-wise statistics for DE between sn/scRNA-seq data clusters/cell populations with the DE statistics in the human DLPFC layers provided in this study. This can be used to label your sn/scRNA-seq groups or clusters with the more molecularly-defined histological layers 📝 Exercise 3: plot the expression of SNAP25, MOBP, and PCP4 in the different layers of each DLPFC tissue section. Are there any significant differences in the expression of these genes between layers under any of the statistical models for DGE? p.link{ background-color: #FFFFFF; padding: 10px; border: 0px solid black; margin-left: 0px; border-radius: 1px; font-size: 13px; font-family: sans-serif; } 👉🏼 There is also the spatialLIBD R/Bioconductor package you can use to interactively inspect your own spatial data in a shiny web app. Bibliography SciLifeLab (2023). 10X Genomics Visium for Fresh Frozen samples. Web site: https://ngisweden.scilifelab.se/methods/10x-visium/ 10x Genomics (n.d.). Whole transcriptome discovery in the tissue context. Web site: https://www.10xgenomics.com/platforms/visium "],["re-use-of-bulk-rna-seq-methods-for-spatial-data-exercise.html", "16 Re-use of bulk RNA-seq methods for spatial data exercise 16.1 Spatial registration 16.2 Exercise", " 16 Re-use of bulk RNA-seq methods for spatial data exercise Instructor: Leo Hot of the pre-print press! 🔥 Our latest work #spatialDLPFC pairs #snRNAseq and #Visium spatial transcriptomic data in the human #DLPFC building a neuroanatomical atlas of this critical brain region 🧠@LieberInstitute @10xGenomics #scitwitter📰 https://t.co/NJWJ1mwB9J pic.twitter.com/l8W154XZ50 — Louise Huuki-Myers (@lahuuki) February 17, 2023 16.1 Spatial registration Louise A. Huuki-Myers recently contributed a new vignette to spatialLIBD as noted on the package news / changelog: http://research.libd.org/spatialLIBD/news/index.html#spatiallibd-1132. To follow it, you might want to have the latest version of spatialLIBD installed. You can install it with this command: BiocManager::install(&quot;LieberInstitute/spatialLIBD&quot;) Alternatively, you could have a Bioconductor devel setup, but that’s beyond the scope of this course. Using the devel docker image at http://bioconductor.org/help/docker/ is probably the easiest option. After installing this version of spatialLIBD, you should be able to run without any issues the code Louise explains at http://research.libd.org/spatialLIBD/articles/guide_to_spatial_registration.html. This same information is displayed at https://bioconductor.org/packages/devel/data/experiment/vignettes/spatialLIBD/inst/doc/guide_to_spatial_registration.html. 16.2 Exercise p.exercise { background-color: #E4EDE2; padding: 9px; border: 1px solid black; border-radius: 10px; font-family: sans-serif; } Exercise: Follow the vignette on spatial registration. Do the results change when you use cutoff_merge_ratio = 0.1? What is this argument controlling? "],["making-your-own-website-with-postcards.html", "17 Making your own website with postcards 17.1 here 17.2 Usethis 17.3 Git + GitHub 17.4 R websites 17.5 postcards 17.6 Create your own website with postcards! 17.7 References", " 17 Making your own website with postcards Instructor: Melissa Mayén Quiroz Welcome to “Making your own website with postcards”! Here we will explore essential tools and techniques to help you create and publish your own website using R and the postcards package. Content: here usethis Git + GitHub R websites Postcards Create your own website with postcards! 17.1 here The here package is a powerful tool for managing file paths in your R projects. It helps you construct paths to files relative to your project’s root, ensuring your code is more robust and easier to share with others. Using here helps avoid issues with hard-coded paths and enhances the reproducibility of your analyses. The base directory it takes will be the one you are in when you load the here package, heuristically finding the root of the project and positioning itself there. In this case, the package is already installed so we just need to load it. ## Install the package manually # install.packages(&quot;here&quot;) ## Load &quot;here&quot; (previously installed) library(&quot;here&quot;) Sometimes there might be an error, as it might clash with other packages (like plyr). To avoid this, we can use here::here (which basically clarifies that the requested function is from the here package). here::here() Some usefull commands are “getwd” and “setwd”, which deal with the working directory, which is the default location where R looks for files to read or save. getwd() retrieves the current working directory. setwd() allows changing the current working directory. getwd() # returns the current path setwd(&quot;desired/directory&quot;) # changes to the specified path Best Practice: Instead of using “setwd” to manually set your working directory, it is often better to use the “here” package. Using “here” avoids issues with hard-coded paths and ensures your scripts work regardless of the specific setup of your working environment. ## Instead of &quot;C:/Users/user/Desktop/data/myfile.csv&quot; ## Use here to construct file paths file_path &lt;- here(&quot;Users&quot;, &quot;user&quot;, &quot;Desktop&quot;, &quot;data&quot;, &quot;myfile.csv&quot;) # file_path &lt;- here:here(&quot;Users&quot;, &quot;user&quot;, &quot;Desktop&quot;,&quot;data&quot;, &quot;myfile.csv&quot;) data &lt;- read.csv(file_path) Other examples of how “here” could be used: ## Example: save data to a file and load it a &lt;- 1 c &lt;- 23 save(a, c, file = here(&quot;test-data.RData&quot;)) # save(a, c, file = here:here(&quot;test-data.RData&quot;)) load(here(&quot;test-data.RData&quot;)) # load(here:here(&quot;test-data.RData&quot;)) ## Create a directory dir.create(here(&quot;subdirectory&quot;), showWarnings = FALSE) # dir.create(here:here(&quot;subdirectory&quot;), showWarnings = FALSE) ## Create a file, indicating the subdirectory (the first argument in this case) file.create(here(&quot;subdirectory&quot;, &quot;filename&quot;)) # file.create(here:here(&quot;subdirectory&quot;, &quot;filename&quot;)) ## Open the new created file file.show(here(&quot;subdirectory&quot;, &quot;filename&quot;)) # file.show(here:here(&quot;subdirectory&quot;, &quot;filename&quot;)) ## For example, if we want to see our files in the directory list.files(here(), recursive = TRUE) # list.files(here:here(), recursive = TRUE) 17.2 Usethis The usethis package simplifies many common setup tasks and workflows in R. It helps streamline the process of creating new projects, setting up Git repositories, and connecting with GitHub. Mastering usethis allows you to focus more on coding and less on configuration. In this case, the package is already installed so we just need to load it. ## Install the package manually # install.packages(&quot;usethis&quot;) ## Load &quot;usethis (previously installed) library(&quot;usethis&quot;) Usage: All use_* functions operate on the current directory. ## usethis::use_*() usethis::use_r() usethis::use_git() usethis::use_readme_md() ✔ indicates that usethis has setup everything for you. ● indicates that you’ll need to do some work yourself. ## For example, create a README file usethis::use_readme_md() #&gt; ✔ Writing &#39;README.md&#39; #&gt; ● Edit &#39;README.md&#39; More functions in usethis: usethis RDocumentation In the following exercises, we will see some uses of usethis. 17.3 Git + GitHub GitHub An Intro to Git and GitHub for Beginners (Tutorial) by HubSpot Version control is a critical skill. Git helps you track changes in your projects, collaborate with others, and maintain a history of your work. GitHub, a platform for hosting Git repositories, enables seamless collaboration and sharing of your projects with the world. Understanding Git and GitHub ensures your projects are well-organized and accessible. 17.3.1 Prerequisites We need a GitHub account. If you don’t have one, now is the time to create it! Create a GitHub account We also need to install Git on our computers as the “gitcreds” package requires it. Installing Git After installing Git, restart RStudio to allow it to annex. Hay que agregarlos a los paquetes a instalar ??? ## Packages we will need install.packages(c(&quot;gitcreds&quot;, &quot;gert&quot;, &quot;gh&quot;)) ## Load them separately library(&quot;gitcreds&quot;) library(&quot;gert&quot;) library(&quot;gh&quot;) 17.3.2 Creating a personal access token (PAT) To connect our RStudio repository with GitHub, we request a token, which allows GitHub to grant permission to our computer. You can request the token using R (choose a meaningful name). ## Initiate connection with GitHub usethis::create_github_token() # redirects to GitHub where you&#39;ll choose a specific name for the token Copy the token to enter it later with gitcreds_set() gitcreds::gitcreds_set() # here you place the token (NOT your GitHub password!!!) Another way to request the token is by going to GitHub Tokens, this option will provide a recommendation of the parameters to select. The token expiration parameter can be changed so it does not expire (for security, GitHub does not recommend this). Otherwise, consider its validity period. Once generated, you must save the token, as it will not appear again. You can always generate a new one (don’t forget to delete the previous token). The next step is to configure our GitHub user in the .gitconfig file: ## Configure GitHub user usethis::edit_git_config() # opens the .gitconfig file ## Place the name and email of your GitHub account. ## JUST remove the &quot;#&quot; and respect the other spaces # [user] # name = N A M E # email = github_email 17.3.3 Initialize Git and GitHub repository Now let’s initialize the repository in Git (locally on your computer) and then request to connect it with GitHub servers. (Git is the software while GitHub is the web platform (based on Git) that allows collaboration). ## Initialize the Git repository usethis::use_git() ## Connect your local Git repository with GitHub servers usethis::use_github() ** Done ** Useful command to check configuration: gh::gh_whoami() 17.3.4 Some other gert commands Once we have linked our repository with GitHub, we can continue updating it. Some useful commands for this are: git_add git_commit git_log git_push ## Write a new file, using here::here to specify the path writeLines(&quot;hello&quot;, here::here(&quot;R&quot;, &quot;test-here.R&quot;)) ## Another way is to use use_r usethis::use_r(&quot;test-file-github.R&quot;) # adds file to the project&#39;s R directory ## For example, we might try adding something new gert::git_add(&quot;R/test-file-github.R&quot;) ## Add commit of what was done gert::git_commit(&quot;uploaded test file&quot;) ## Gives info about the commits gert::git_log() ## Upload your changes from the local repo to GitHub gert::git_push() # IMPORTANT COMMAND It might be more user-friendly to use the Git pane that appears in RStudio :) 17.4 R websites Creating websites using R opens up new ways to share your analyses, reports, and research. Whether you are building static sites with R Markdown or dynamic applications with Shiny, R provides powerful tools to make your content interactive and engaging. Learning to create and deploy R websites enhances your ability to communicate your work effectively. 17.4.1 1. Set Up _site.yml Creating a website with R Markdown involves several key steps. First, you set up a _site.yml file, which configures the site’s name, navigation bar, and global options like themes and additional CSS or JavaScript files. This file ensures a consistent look and feel across all pages. YAML (.yml file) name: &quot;My Website&quot; output_dir: &quot;docs&quot; navbar: title: &quot;My Website&quot; left: - text: &quot;Home&quot; href: index.html - text: &quot;About&quot; href: about.html output: html_document: theme: cosmo highlight: tango 17.4.2 2. Create index.Rmd for the Homepage The homepage is created using an index.Rmd file, which acts as the main entry point for visitors, providing an introduction or overview of the site. Additional pages, such as about.Rmd, offer more detailed information about the website or its author. Markdown (index.Rmd file) --- title: &quot;Welcome to My Website&quot; author: &quot;Your Name&quot; date: &quot;2024-06-06&quot; output: html_document --- # Welcome to My Website This is a website created with R Markdown. Here you can share your analyses, reports, and research. ## Example Section Here is an example of a simple analysis: ## To insert a code block follow the sintaxis removing &quot;#&quot; !!! #` ``{r} summary(cars) # ``` 17.4.3 3. Render the Site To render the site, use the rmarkdown::render_site() function, which converts all R Markdown and Markdown files into HTML. The resulting HTML files and resources are placed in a directory, typically _site. RStudio facilitates this process with tools like the “Knit” button for individual pages and the “Build” pane for the entire site. Common elements, such as shared HTML files and CSS for styling, ensure consistency and avoid redundancy. A well-configured navigation bar enhances user experience by providing easy access to different sections. rmarkdown::render_site() 17.4.4 4. Publish the Website Publishing involves copying the contents of the _site directory to a web server, making your site accessible to others. For example, if you’re creating a personal blog, you would set up the _site.yml file with your site’s title and navigation links. The index.Rmd file would introduce your blog, while about.Rmd would provide information about you. After writing your blog posts in R Markdown files and rendering the site, you would upload the _site directory to your web server. 17.4.4.1 Choose a Hosting Platform: Consider platforms like GitHub Pages or Netlify for easy and free hosting. 17.4.4.2 Upload Files: For GitHub Pages, push your files to a GitHub repository named username.github.io. For Netlify, connect your GitHub repository and configure the deployment settings. 17.4.4.3 Configure Hosting: On GitHub Pages, enable GitHub Pages in the repository settings. On Netlify, configure the deployment settings to specify the build command (rmarkdown::render_site()) and output directory (docs if using _site.yml). Continuous Deployment (Netlify). If hosting on a different server, manually upload the files to your server using FTP or a similar method. 17.5 postcards The postcards package makes it easy to create beautiful, single-page websites with minimal effort. It’s perfect for personal websites, portfolios, and project showcases. Using postcards allows you to present your work professionally and creatively, without needing extensive web development knowledge. A collection of R Markdown templates for creating simple and easy-to-personalize single-page websites. “The goal of the package is to make it easy for anyone to create a one-page personal website using an R Markdown document.” Author: Sean Kross [aut, cre] Maintainer: Sean Kross &lt;sean at seankross.com&gt; https://CRAN.R-project.org/package=postcards GitHub: https://github.com/seankross/postcards Similar to https://pages.github.com/ Your webpage should say something about you, your interests, and your projects, as well as how to contact you. Some examples: https://amy-peterson.github.io/ via https://github.com/amy-peterson/amy-peterson.github.com http://jtleek.com/ via https://github.com/jtleek/jtleek.github.io http://aejaffe.com/ via https://github.com/andrewejaffe/andrewejaffe.github.io https://hadley.nz/ via https://github.com/hadley/hadley.github.com https://emarquezz.github.io/ via https://github.com/emarquezz/emarquezz.github.io https://bpardo99.github.io/ via https://github.com/bpardo99/bpardo99.github.io https://daianna21.github.io/ via https://github.com/daianna21/daianna21.github.io. 17.5.1 Installation In this case, the package is already installed Agregar postcards a los paquetes !!!! ## You can install Postcards with the following command: # install.packages(&quot;postcards&quot;) ## Or you can install the latest development version (not recommended): # remotes::install_github(&quot;seankross/postcards@main&quot;) 17.5.2 Templates Postcards include five templates: Jolla, Jolla Blue, Trestles, Onofre, and Solana. Each site is optimized for viewing on both desktop and mobile devices. The goal of the package is to make it easy for anyone to create a one-page personal website using an R Markdown document. Jolla: Jolla Blue: Trestles: Onofre: Solana: To start personalizing one of these templates, you need to create a new project. 17.6 Create your own website with postcards! Create your own website: Following the next steps you will be able to create your own personal website. You will need to have a GitHub account and connect Git. In case you missed it, you can go back to the “Git + GitHub” section. 17.6.1 Create a New Project in RStudio (Interactive Selection) If you use RStudio: Select “File”, “New Project”… Choose “New Directory”, “Postcards Website” Enter a directory name for your project in RStudio (“Your_Username.github.io”) Choose one of the templates from a dropdown menu Select “Create Project” after choosing a name for the folder that will contain your site. This folder will contain two important files: An R Markdown document with your site’s content A sample photo you should replace (with your own) ## Create a new project usethis::create_project(&quot;Your_Username.github.io&quot;) 17.6.2 Set Up Git and GitHub To save changes, you need to set up Git and GitHub ## Set up Git and GitHub usethis::use_git() # Restart the session usethis::use_github() 17.6.3 Choose a Template ## Choose only one template (the one you like the most) postcards::create_postcard(template = &quot;jolla&quot;) postcards::create_postcard(template = &quot;jolla-blue&quot;) postcards::create_postcard(template = &quot;trestles&quot;) postcards::create_postcard(template = &quot;onofre&quot;) postcards::create_postcard(template = &quot;solana&quot;) In this way, you will also get the 2 important files: An R Markdown document with your site’s content A sample photo you should replace 17.6.4 Edit with Your Information Now you should edit the R Markdown document with your information and replace the image with one of your choice :) Fill in your information using the Markdown format. For example, https://github.com/andrewejaffe/andrewejaffe.github.io/blob/master/index.Rmd#L17-L31. Add your profiles in the style of https://github.com/andrewejaffe/andrewejaffe.github.io/blob/master/index.Rmd#L7-L12 17.6.5 Deploy the Page To compile the self-contained HTML file for the site: In RStudio, you can use the “Knit” button or directly: ## Deploy the GitHub page rmarkdown::render(&quot;index.Rmd&quot;) ** Done ** 17.7 References https://comunidadbioinfo.github.io/cdsb2021_scRNAseq/ejercicio-usando-usethis-here-y-postcards.html#vinculando-rstudio-con-git-y-github https://here.r-lib.org/ https://usethis.r-lib.org/ https://rmarkdown.rstudio.com/lesson-13.html https://bookdown.org/yihui/rmarkdown/rmarkdown-site.html https://product.hubspot.com/blog/git-and-github-tutorial-for-beginners https://github.com/Melii99/rnaseq_2024_postcards/blob/master/Actividad_postcards.Rmd "],["final-r-session.html", "Final R Session", " Final R Session This is the final R session after all the code in this book is run sequentially. #&gt; ─ Session info ─────────────────────────────────────────────────────────────────────────────────────────────────────── #&gt; setting value #&gt; version R version 4.4.0 (2024-04-24) #&gt; os Ubuntu 22.04.4 LTS #&gt; system x86_64, linux-gnu #&gt; ui X11 #&gt; language (EN) #&gt; collate en_US.UTF-8 #&gt; ctype en_US.UTF-8 #&gt; tz UTC #&gt; date 2024-06-06 #&gt; pandoc 3.1.13 @ /usr/bin/ (via rmarkdown) #&gt; #&gt; ─ Packages ─────────────────────────────────────────────────────────────────────────────────────────────────────────── #&gt; package * version date (UTC) lib source #&gt; abind 1.4-5 2016-07-21 [1] RSPM (R 4.4.0) #&gt; airway * 1.24.0 2024-05-02 [1] Bioconductor 3.19 (R 4.4.0) #&gt; alabaster.base 1.4.1 2024-05-03 [1] Bioconductor 3.19 (R 4.4.0) #&gt; alabaster.matrix 1.4.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) #&gt; alabaster.ranges 1.4.1 2024-05-21 [1] Bioconductor 3.19 (R 4.4.0) #&gt; alabaster.sce 1.4.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) #&gt; alabaster.schemas 1.4.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) #&gt; alabaster.se 1.4.1 2024-05-21 [1] Bioconductor 3.19 (R 4.4.0) #&gt; AnnotationDbi 1.66.0 2024-05-01 [1] Bioconductor 3.19 (R 4.4.0) #&gt; AnnotationFilter 1.28.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) #&gt; AnnotationHub * 3.12.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) #&gt; aod 1.3.3 2023-12-13 [1] RSPM (R 4.4.0) #&gt; askpass 1.2.0 2023-09-03 [2] RSPM (R 4.4.0) #&gt; attempt 0.3.1 2020-05-03 [1] RSPM (R 4.4.0) #&gt; backports 1.5.0 2024-05-23 [1] RSPM (R 4.4.0) #&gt; base64enc 0.1-3 2015-07-28 [2] RSPM (R 4.4.0) #&gt; beachmat 2.20.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) #&gt; beeswarm 0.4.0 2021-06-01 [1] RSPM (R 4.4.0) #&gt; benchmarkme 1.0.8 2022-06-12 [1] RSPM (R 4.4.0) #&gt; benchmarkmeData 1.0.4 2020-04-23 [1] RSPM (R 4.4.0) #&gt; bibtex 0.5.1 2023-01-26 [1] RSPM (R 4.4.0) #&gt; Biobase * 2.64.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) #&gt; BiocFileCache * 2.12.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) #&gt; BiocGenerics * 0.50.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) #&gt; BiocIO 1.14.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) #&gt; BiocManager 1.30.23 2024-05-04 [2] CRAN (R 4.4.0) #&gt; BiocNeighbors 1.22.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) #&gt; BiocParallel * 1.38.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) #&gt; BiocSingular 1.20.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) #&gt; BiocStyle * 2.32.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) #&gt; biocthis * 1.14.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) #&gt; BiocVersion 3.19.1 2024-04-17 [2] Bioconductor 3.19 (R 4.4.0) #&gt; Biostrings 2.72.1 2024-06-02 [1] Bioconductor 3.19 (R 4.4.0) #&gt; bit 4.0.5 2022-11-15 [1] RSPM (R 4.4.0) #&gt; bit64 4.0.5 2020-08-30 [1] RSPM (R 4.4.0) #&gt; bitops 1.0-7 2021-04-24 [1] RSPM (R 4.4.0) #&gt; blob 1.2.4 2023-03-17 [1] RSPM (R 4.4.0) #&gt; bookdown 0.39 2024-04-15 [1] RSPM (R 4.4.0) #&gt; boot 1.3-30 2024-02-26 [3] CRAN (R 4.4.0) #&gt; broom 1.0.6 2024-05-17 [1] RSPM (R 4.4.0) #&gt; bslib 0.7.0 2024-03-29 [2] RSPM (R 4.4.0) #&gt; cachem 1.1.0 2024-05-16 [2] RSPM (R 4.4.0) #&gt; Cairo 1.6-2 2023-11-28 [1] RSPM (R 4.4.0) #&gt; caTools 1.18.2 2021-03-28 [1] RSPM (R 4.4.0) #&gt; checkmate 2.3.1 2023-12-04 [1] RSPM (R 4.4.0) #&gt; circlize * 0.4.16 2024-02-20 [1] RSPM (R 4.4.0) #&gt; cli 3.6.2 2023-12-11 [2] RSPM (R 4.4.0) #&gt; clue 0.3-65 2023-09-23 [1] RSPM (R 4.4.0) #&gt; cluster 2.1.6 2023-12-01 [3] CRAN (R 4.4.0) #&gt; codetools 0.2-20 2024-03-31 [3] CRAN (R 4.4.0) #&gt; colorspace 2.1-0 2023-01-23 [1] RSPM (R 4.4.0) #&gt; colourpicker 1.3.0 2023-08-21 [1] RSPM (R 4.4.0) #&gt; ComplexHeatmap * 2.20.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) #&gt; config 0.3.2 2023-08-30 [1] RSPM (R 4.4.0) #&gt; corpcor 1.6.10 2021-09-16 [1] RSPM (R 4.4.0) #&gt; cowplot * 1.1.3 2024-01-22 [1] RSPM (R 4.4.0) #&gt; crayon 1.5.2 2022-09-29 [2] RSPM (R 4.4.0) #&gt; credentials 2.0.1 2023-09-06 [2] RSPM (R 4.4.0) #&gt; curl 5.2.1 2024-03-01 [2] RSPM (R 4.4.0) #&gt; data.table 1.15.4 2024-03-30 [1] RSPM (R 4.4.0) #&gt; DBI 1.2.3 2024-06-02 [1] RSPM (R 4.4.0) #&gt; dbplyr * 2.5.0 2024-03-19 [1] RSPM (R 4.4.0) #&gt; DelayedArray 0.30.1 2024-05-07 [1] Bioconductor 3.19 (R 4.4.0) #&gt; DelayedMatrixStats 1.26.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) #&gt; digest 0.6.35 2024-03-11 [2] RSPM (R 4.4.0) #&gt; doParallel 1.0.17 2022-02-07 [1] RSPM (R 4.4.0) #&gt; dotCall64 1.1-1 2023-11-28 [1] RSPM (R 4.4.0) #&gt; dplyr 1.1.4 2023-11-17 [1] RSPM (R 4.4.0) #&gt; DT 0.33 2024-04-04 [1] RSPM (R 4.4.0) #&gt; edgeR * 4.2.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) #&gt; ensembldb 2.28.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) #&gt; EnvStats 2.8.1 2023-08-22 [1] RSPM (R 4.4.0) #&gt; evaluate 0.23 2023-11-01 [2] RSPM (R 4.4.0) #&gt; ExperimentHub * 2.12.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) #&gt; ExploreModelMatrix * 1.16.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) #&gt; fANCOVA 0.6-1 2020-11-13 [1] RSPM (R 4.4.0) #&gt; fansi 1.0.6 2023-12-08 [2] RSPM (R 4.4.0) #&gt; farver 2.1.2 2024-05-13 [1] RSPM (R 4.4.0) #&gt; fastmap 1.2.0 2024-05-15 [2] RSPM (R 4.4.0) #&gt; fields 15.2 2023-08-17 [1] RSPM (R 4.4.0) #&gt; filelock 1.0.3 2023-12-11 [1] RSPM (R 4.4.0) #&gt; foreach 1.5.2 2022-02-02 [1] RSPM (R 4.4.0) #&gt; foreign 0.8-86 2023-11-28 [3] CRAN (R 4.4.0) #&gt; Formula 1.2-5 2023-02-24 [1] RSPM (R 4.4.0) #&gt; fs 1.6.4 2024-04-25 [2] RSPM (R 4.4.0) #&gt; generics 0.1.3 2022-07-05 [1] RSPM (R 4.4.0) #&gt; GenomeInfoDb * 1.40.1 2024-05-24 [1] Bioconductor 3.19 (R 4.4.0) #&gt; GenomeInfoDbData 1.2.12 2024-05-26 [1] Bioconductor #&gt; GenomicAlignments 1.40.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) #&gt; GenomicFeatures 1.56.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) #&gt; GenomicRanges * 1.56.0 2024-05-01 [1] Bioconductor 3.19 (R 4.4.0) #&gt; gert * 2.0.1 2023-12-04 [2] RSPM (R 4.4.0) #&gt; GetoptLong 1.0.5 2020-12-15 [1] RSPM (R 4.4.0) #&gt; ggbeeswarm 0.7.2 2023-04-29 [1] RSPM (R 4.4.0) #&gt; ggplot2 * 3.5.1 2024-04-23 [1] RSPM (R 4.4.0) #&gt; ggrepel * 0.9.5 2024-01-10 [1] RSPM (R 4.4.0) #&gt; gh * 1.4.1 2024-03-28 [2] RSPM (R 4.4.0) #&gt; gitcreds * 0.1.2 2022-09-08 [2] RSPM (R 4.4.0) #&gt; GlobalOptions 0.1.2 2020-06-10 [1] RSPM (R 4.4.0) #&gt; glue 1.7.0 2024-01-09 [2] RSPM (R 4.4.0) #&gt; golem 0.4.1 2023-06-05 [1] RSPM (R 4.4.0) #&gt; gplots 3.1.3.1 2024-02-02 [1] RSPM (R 4.4.0) #&gt; gridExtra 2.3 2017-09-09 [1] RSPM (R 4.4.0) #&gt; gtable 0.3.5 2024-04-22 [1] RSPM (R 4.4.0) #&gt; gtools 3.9.5 2023-11-20 [1] RSPM (R 4.4.0) #&gt; gypsum 1.0.1 2024-05-08 [1] Bioconductor 3.19 (R 4.4.0) #&gt; HDF5Array 1.32.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) #&gt; here * 1.0.1 2020-12-13 [1] RSPM (R 4.4.0) #&gt; highr 0.11 2024-05-26 [2] RSPM (R 4.4.0) #&gt; Hmisc * 5.1-3 2024-05-28 [1] RSPM (R 4.4.0) #&gt; htmlTable 2.4.2 2023-10-29 [1] RSPM (R 4.4.0) #&gt; htmltools 0.5.8.1 2024-04-04 [2] RSPM (R 4.4.0) #&gt; htmlwidgets 1.6.4 2023-12-06 [2] RSPM (R 4.4.0) #&gt; httpuv 1.6.15 2024-03-26 [2] RSPM (R 4.4.0) #&gt; httr 1.4.7 2023-08-15 [2] RSPM (R 4.4.0) #&gt; httr2 1.0.1 2024-04-01 [2] RSPM (R 4.4.0) #&gt; igraph 2.0.3 2024-03-13 [1] RSPM (R 4.4.0) #&gt; IRanges * 2.38.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) #&gt; irlba 2.3.5.1 2022-10-03 [1] RSPM (R 4.4.0) #&gt; iSEE * 2.16.0 2024-05-01 [1] Bioconductor 3.19 (R 4.4.0) #&gt; iterators 1.0.14 2022-02-05 [1] RSPM (R 4.4.0) #&gt; jquerylib 0.1.4 2021-04-26 [2] RSPM (R 4.4.0) #&gt; jsonlite 1.8.8 2023-12-04 [2] RSPM (R 4.4.0) #&gt; KEGGREST 1.44.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) #&gt; KernSmooth 2.23-24 2024-05-17 [3] RSPM (R 4.4.0) #&gt; knitr 1.47 2024-05-29 [2] RSPM (R 4.4.0) #&gt; labeling 0.4.3 2023-08-29 [1] RSPM (R 4.4.0) #&gt; later 1.3.2 2023-12-06 [2] RSPM (R 4.4.0) #&gt; lattice 0.22-6 2024-03-20 [3] CRAN (R 4.4.0) #&gt; lazyeval 0.2.2 2019-03-15 [1] RSPM (R 4.4.0) #&gt; lifecycle 1.0.4 2023-11-07 [2] RSPM (R 4.4.0) #&gt; limma * 3.60.2 2024-05-19 [1] Bioconductor 3.19 (R 4.4.0) #&gt; listviewer 4.0.0 2023-09-30 [1] RSPM (R 4.4.0) #&gt; lme4 1.1-35.3 2024-04-16 [1] RSPM (R 4.4.0) #&gt; lmerTest 3.1-3 2020-10-23 [1] RSPM (R 4.4.0) #&gt; lobstr * 1.1.2 2022-06-22 [1] RSPM (R 4.4.0) #&gt; locfit 1.5-9.9 2024-03-01 [1] RSPM (R 4.4.0) #&gt; lubridate 1.9.3 2023-09-27 [1] RSPM (R 4.4.0) #&gt; magick 2.8.3 2024-02-18 [1] RSPM (R 4.4.0) #&gt; magrittr 2.0.3 2022-03-30 [2] RSPM (R 4.4.0) #&gt; maps 3.4.2 2023-12-15 [1] RSPM (R 4.4.0) #&gt; MASS 7.3-60.2 2024-05-06 [3] local #&gt; Matrix 1.7-0 2024-03-22 [3] CRAN (R 4.4.0) #&gt; MatrixGenerics * 1.16.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) #&gt; matrixStats * 1.3.0 2024-04-11 [1] RSPM (R 4.4.0) #&gt; memoise 2.0.1 2021-11-26 [2] RSPM (R 4.4.0) #&gt; mgcv 1.9-1 2023-12-21 [3] CRAN (R 4.4.0) #&gt; mime 0.12 2021-09-28 [2] RSPM (R 4.4.0) #&gt; miniUI 0.1.1.1 2018-05-18 [2] RSPM (R 4.4.0) #&gt; minqa 1.2.7 2024-05-20 [1] RSPM (R 4.4.0) #&gt; munsell 0.5.1 2024-04-01 [1] RSPM (R 4.4.0) #&gt; mvtnorm 1.2-5 2024-05-21 [1] RSPM (R 4.4.0) #&gt; nlme 3.1-164 2023-11-27 [3] CRAN (R 4.4.0) #&gt; nloptr 2.0.3 2022-05-26 [1] RSPM (R 4.4.0) #&gt; nnet 7.3-19 2023-05-03 [3] CRAN (R 4.4.0) #&gt; numDeriv 2016.8-1.1 2019-06-06 [1] RSPM (R 4.4.0) #&gt; openssl 2.2.0 2024-05-16 [2] RSPM (R 4.4.0) #&gt; paletteer 1.6.0 2024-01-21 [1] RSPM (R 4.4.0) #&gt; patchwork * 1.2.0 2024-01-08 [1] RSPM (R 4.4.0) #&gt; pbkrtest 0.5.2 2023-01-19 [1] RSPM (R 4.4.0) #&gt; pheatmap * 1.0.12 2019-01-04 [1] RSPM (R 4.4.0) #&gt; pillar 1.9.0 2023-03-22 [2] RSPM (R 4.4.0) #&gt; pkgconfig 2.0.3 2019-09-22 [2] RSPM (R 4.4.0) #&gt; plotly 4.10.4 2024-01-13 [1] RSPM (R 4.4.0) #&gt; plyr 1.8.9 2023-10-02 [1] RSPM (R 4.4.0) #&gt; png 0.1-8 2022-11-29 [1] RSPM (R 4.4.0) #&gt; Polychrome * 1.5.1 2022-05-03 [1] RSPM (R 4.4.0) #&gt; postcards * 0.2.3 2022-01-07 [1] RSPM (R 4.4.0) #&gt; prettyunits 1.2.0 2023-09-24 [2] RSPM (R 4.4.0) #&gt; promises 1.3.0 2024-04-05 [2] RSPM (R 4.4.0) #&gt; ProtGenerics 1.36.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) #&gt; purrr 1.0.2 2023-08-10 [2] RSPM (R 4.4.0) #&gt; R.cache 0.16.0 2022-07-21 [1] RSPM (R 4.4.0) #&gt; R.methodsS3 1.8.2 2022-06-13 [1] RSPM (R 4.4.0) #&gt; R.oo 1.26.0 2024-01-24 [1] RSPM (R 4.4.0) #&gt; R.utils 2.12.3 2023-11-18 [1] RSPM (R 4.4.0) #&gt; R6 2.5.1 2021-08-19 [2] RSPM (R 4.4.0) #&gt; rappdirs 0.3.3 2021-01-31 [2] RSPM (R 4.4.0) #&gt; rbibutils 2.2.16 2023-10-25 [1] RSPM (R 4.4.0) #&gt; RColorBrewer * 1.1-3 2022-04-03 [1] RSPM (R 4.4.0) #&gt; Rcpp 1.0.12 2024-01-09 [2] RSPM (R 4.4.0) #&gt; RCurl 1.98-1.14 2024-01-09 [1] RSPM (R 4.4.0) #&gt; Rdpack 2.6 2023-11-08 [1] RSPM (R 4.4.0) #&gt; recount3 * 1.14.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) #&gt; RefManageR * 1.4.0 2022-09-30 [1] RSPM (R 4.4.0) #&gt; remaCor 0.0.18 2024-02-08 [1] RSPM (R 4.4.0) #&gt; rematch2 2.1.2 2020-05-01 [2] RSPM (R 4.4.0) #&gt; reshape2 1.4.4 2020-04-09 [1] RSPM (R 4.4.0) #&gt; restfulr 0.0.15 2022-06-16 [1] RSPM (R 4.4.0) #&gt; rhdf5 2.48.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) #&gt; rhdf5filters 1.16.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) #&gt; Rhdf5lib 1.26.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) #&gt; RhpcBLASctl 0.23-42 2023-02-11 [1] RSPM (R 4.4.0) #&gt; rintrojs 0.3.4 2024-01-11 [1] RSPM (R 4.4.0) #&gt; rjson 0.2.21 2022-01-09 [1] RSPM (R 4.4.0) #&gt; rlang * 1.1.4 2024-06-04 [2] RSPM (R 4.4.0) #&gt; rmarkdown 2.27 2024-05-17 [2] RSPM (R 4.4.0) #&gt; rpart 4.1.23 2023-12-05 [3] CRAN (R 4.4.0) #&gt; rprojroot 2.0.4 2023-11-05 [2] RSPM (R 4.4.0) #&gt; Rsamtools 2.20.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) #&gt; RSQLite 2.3.7 2024-05-27 [1] RSPM (R 4.4.0) #&gt; rstudioapi 0.16.0 2024-03-24 [2] RSPM (R 4.4.0) #&gt; rsvd 1.0.5 2021-04-16 [1] RSPM (R 4.4.0) #&gt; rtracklayer 1.64.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) #&gt; S4Arrays 1.4.1 2024-05-20 [1] Bioconductor 3.19 (R 4.4.0) #&gt; S4Vectors * 0.42.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) #&gt; sass 0.4.9 2024-03-15 [2] RSPM (R 4.4.0) #&gt; ScaledMatrix 1.12.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) #&gt; scales 1.3.0 2023-11-28 [1] RSPM (R 4.4.0) #&gt; scater * 1.32.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) #&gt; scatterplot3d 0.3-44 2023-05-05 [1] RSPM (R 4.4.0) #&gt; scRNAseq * 2.18.0 2024-05-02 [1] Bioconductor 3.19 (R 4.4.0) #&gt; scuttle * 1.14.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) #&gt; sessioninfo * 1.2.2 2021-12-06 [2] RSPM (R 4.4.0) #&gt; shape 1.4.6.1 2024-02-23 [1] RSPM (R 4.4.0) #&gt; shiny 1.8.1.1 2024-04-02 [2] RSPM (R 4.4.0) #&gt; shinyAce 0.4.2 2022-05-06 [1] RSPM (R 4.4.0) #&gt; shinydashboard 0.7.2 2021-09-30 [1] RSPM (R 4.4.0) #&gt; shinyjs 2.1.0 2021-12-23 [1] RSPM (R 4.4.0) #&gt; shinyWidgets 0.8.6 2024-04-24 [1] RSPM (R 4.4.0) #&gt; SingleCellExperiment * 1.26.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) #&gt; smokingMouse * 0.99.91 2024-06-06 [1] Github (LieberInstitute/smokingMouse@96d8480) #&gt; spam 2.10-0 2023-10-23 [1] RSPM (R 4.4.0) #&gt; SparseArray 1.4.8 2024-05-24 [1] Bioconductor 3.19 (R 4.4.0) #&gt; sparseMatrixStats 1.16.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) #&gt; SpatialExperiment * 1.14.0 2024-05-01 [1] Bioconductor 3.19 (R 4.4.0) #&gt; spatialLIBD * 1.16.2 2024-05-28 [1] Bioconductor 3.19 (R 4.4.0) #&gt; statmod 1.5.0 2023-01-06 [1] RSPM (R 4.4.0) #&gt; stringi 1.8.4 2024-05-06 [2] RSPM (R 4.4.0) #&gt; stringr * 1.5.1 2023-11-14 [2] RSPM (R 4.4.0) #&gt; styler 1.10.3 2024-04-07 [1] RSPM (R 4.4.0) #&gt; SummarizedExperiment * 1.34.0 2024-05-01 [1] Bioconductor 3.19 (R 4.4.0) #&gt; sys 3.4.2 2023-05-23 [2] RSPM (R 4.4.0) #&gt; tibble 3.2.1 2023-03-20 [2] RSPM (R 4.4.0) #&gt; tidyr 1.3.1 2024-01-24 [1] RSPM (R 4.4.0) #&gt; tidyselect 1.2.1 2024-03-11 [1] RSPM (R 4.4.0) #&gt; timechange 0.3.0 2024-01-18 [1] RSPM (R 4.4.0) #&gt; UCSC.utils 1.0.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) #&gt; usethis * 2.2.3 2024-02-19 [2] RSPM (R 4.4.0) #&gt; utf8 1.2.4 2023-10-22 [2] RSPM (R 4.4.0) #&gt; variancePartition * 1.34.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) #&gt; vctrs 0.6.5 2023-12-01 [2] RSPM (R 4.4.0) #&gt; vipor 0.4.7 2023-12-18 [1] RSPM (R 4.4.0) #&gt; viridis 0.6.5 2024-01-29 [1] RSPM (R 4.4.0) #&gt; viridisLite 0.4.2 2023-05-02 [1] RSPM (R 4.4.0) #&gt; withr 3.0.0 2024-01-16 [2] RSPM (R 4.4.0) #&gt; xfun 0.44 2024-05-15 [2] RSPM (R 4.4.0) #&gt; XML 3.99-0.16.1 2024-01-22 [1] RSPM (R 4.4.0) #&gt; xml2 1.3.6 2023-12-04 [2] RSPM (R 4.4.0) #&gt; xtable 1.8-4 2019-04-21 [2] RSPM (R 4.4.0) #&gt; XVector 0.44.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) #&gt; yaml 2.3.8 2023-12-11 [2] RSPM (R 4.4.0) #&gt; zlibbioc 1.50.0 2024-04-30 [1] Bioconductor 3.19 (R 4.4.0) #&gt; #&gt; [1] /__w/_temp/Library #&gt; [2] /usr/local/lib/R/site-library #&gt; [3] /usr/local/lib/R/library #&gt; #&gt; ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── This interactive book was last updated at 2024-06-06 18:35:30.883795. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
